{
  "hash": "8dd3405bf08d9619df2c17e2bb379ff2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'You need a map - Parte 2'\ndate: '2024-01-05'\ncategories: ['data visualization', 'ggplot2', 'turorial-R']\ndescription: \"Neste segundo post mostro o básico de como trabalhar com objetos espaciais e como montar mapas coropléticos. Estes mapas apresentam a distribuição espacial de uma variável numérica e são extremamente úteis. Apresento também alguns mapas temáticas como o mapa de quebras naturais e o mapa de desvios-padrão.\"\nimage: \"/static/maps/ggplot2_tutorial.png\"\n---\n\n\n\n\n\n# Objetos espaciais\n\nDados espaciais são um tipo especial de dado geralmente representados por uma de três formas geométricas: pontos, linhas ou polígonos. Em alguns casos, como visto no post anterior, é possível tratar estes dados como dados tabulares quaisquer. Na maioria dos casos, contudo, será necessário maior cuidado. Isto acontece não somente por causa da complexidade das figuras geométricas, mas também porque dados espaciais carregam uma quantidade relativamente expressiva de metadados. Estes metadados caracterizam diversos aspectos sobre estes dados. Uma das funções destes metadados é de explicar ao `R` como aqueles dados estão projetados no espaço.\n\nEsta é uma discussão bastante técnica e neste post vou apresentar apenas o essencial para a construção de mapas. Isto é, vou ignorar os detalhes da projeção e até de convenções cartográficas e vou me focar em casos aplicados simples. Uma introdução a estes assuntos pode ser vista em [Geocomputation with R](https://r.geocompx.org/spatial-class).\n\nA lista completa de pacotes necessários para acompanhar este post segue abaixo.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(dplyr)\nlibrary(readr)\nlibrary(tibble)\nlibrary(sf)\nlibrary(spData)\nlibrary(geobr)\nlibrary(censobr)\nlibrary(arrow)\nlibrary(BAMMtools)\n```\n:::\n\n\n## Introdução ao `sf`\n\nO pacote `{sf}` funciona como um `data.frame` com uma coluna especial chamada `geometry`. É possível ignorar a existência desta coluna e trabalhar normalmente com seus dados, usando todo o seu conhecimento acumulado previamente com dados tabulares convencionais. Eventualmente, será necessário juntar um shapefile com uma base de dados e até com outro shapefile; o `{sf}` também facilita isto bastante.\n\nComo comentado acima, vou ignorar a maior parte das convenções cartográficas (escala, rosa dos ventos, etc.). Vale comentar, contudo, que é possível incluir estes elementos no `R` sem grandes problemas.\n\nVou discutir majoritariamente sobre objetos espaciais no formato de vetores (*vector shape file*) já que eles são mais prevalentes nas ciências socias em geral.\n\n### Introdução a objetos espaciais\n\nHá três peças fundamentais que vamos ver: pontos, linhas e polígonos. Nos três casos, usa-se a mesma função `geom_sf()` para montar a visualização. Os elementos estéticos seguem a mesma lógica das funções `geom_point()`, `geom_line()` e `geom_rect()`, respectivamente. Assim, para tornar um objeto espacial, em formato de linha, mais grosso, usa-se `linewidth = 2`, por exemplo.\n\nVou começar assumindo um conhecimento mínimo de `R` apesar deste ser um capítulo já avançado na série de tutoriais de ggplot2.\n\nA estrutura de objetos espaciais é um `sf`/`data.frame` ou um \"spatial data frame\". Este objeto é essencialmente igual a um `data.frame` convencional, mas ele possui uma coluna especial chamada `geom` ou `geometry`. Para criar um objeto `sf` a partir de um `data.frame` ou `tibble` usa-se a função `st_as_sf`.\n\n### Pontos\n\nO tipo mais simples de objeto geométrico é o ponto, definido por uma coordenada horizontal e uma coordenada vertical. O exemplo abaixo mostra como criar um spatial `data.frame` de pontos a partir dos dados de latitude e longitude da base do CEM. O primeiro código abaixo importa a base de dados tabulares e filtra os dados apenas para o ano de 2008 em São Paulo.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncem <- read_csv(\"...\")\n\ncem <- cem |>\n  mutate(code_muni = as.numeric(substr(ap2010, 1, 7))) |>\n  filter(code_muni == 3550308)\n\ncem08 <- filter(cem, ano_lanc == 2008)\n```\n:::\n\n\nNote que é preciso escolher um sistema de projeção e eu escolho o [SIRGAS 2000 EPSG: 4674](https://epsg.io/4674), um sistema de projeção de referência para a América Latina. Para verificar o tipo de geometria dos objetos uso `st_geometry`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npoints_cem <- st_as_sf(cem08, coords = c(\"lon\", \"lat\"), crs = 4674)\n\nst_geometry(points_cem)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGeometry set for 394 features \nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -46.79478 ymin: -23.70684 xmax: -46.43215 ymax: -23.45133\nGeodetic CRS:  SIRGAS 2000\nFirst 5 geometries:\n```\n\n\n:::\n:::\n\n\nPara gerar um gráfico a partir dos nossos dados, usa-se a função `geom_sf`, sem argumento algum. Note que este gráfico é idêntico ao que geramos antes usando `geom_point`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(points_cem) +\n  geom_sf()\n```\n\n::: {.cell-output-display}\n![](12-2-mapas_files/figure-html/unnamed-chunk-6-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nComo comentei, há três tipos principais de objetos geométricos: *pontos*, *linhas* e *polígonos*. É possível gerar linhas e polígonos arbitrários a partir de coordenadas usando as funções do pacote `sf`. Na prática, é pouco usual criar objetos geométricos desta maneira e a sintaxe para desenhar mesmo formas geométricas simples como triângulos e quadrados é bastante trabalhosa, como o código abaixo deixa evidente.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Define as coordenadas do quadrado\nquadrado = list(\n  rbind(\n    c(0, 0),\n    c(0, 1),\n    c(1, 1),\n    c(1, 0),\n    #> Note que é preciso repetir (0, 0)\n    c(0, 0)\n  )\n)\n#> Converte as coordenads em um POLYGON\nquadrado <- st_polygon(quadrado)\n#> Converte em SFC\nquadrado <- st_sfc(quadrado)\n#> Plota o quadrado\nggplot(quadrado) +\n  geom_sf()\n```\n\n::: {.cell-output-display}\n![](12-2-mapas_files/figure-html/unnamed-chunk-7-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n### Linhas\n\nO pacote `spData` traz várias bases de dados espaciais interessantes. Para exemplificar um caso de linhas, vamos explorar a base `seine` que mostra os rios Seine, Marne e Yonne, na França.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(spData)\nspData::seine\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 3 features and 1 field\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: 518344.7 ymin: 6660431 xmax: 879955.3 ymax: 6938864\nProjected CRS: RGF93 / Lambert-93\n   name                       geometry\n1 Marne MULTILINESTRING ((879955.3 ...\n2 Seine MULTILINESTRING ((828893.6 ...\n3 Yonne MULTILINESTRING ((773482.1 ...\n```\n\n\n:::\n:::\n\n\nNovamente, podemos verificar o tipo de geometria deste objeto. Note que os dados estão em uma projeção específica (RGF93 / EPSG2154) em que os dados não estão em latitude/longitude, mas sim em metros.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nst_geometry(seine)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGeometry set for 3 features \nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: 518344.7 ymin: 6660431 xmax: 879955.3 ymax: 6938864\nProjected CRS: RGF93 / Lambert-93\n```\n\n\n:::\n:::\n\n\nO gráfico abaixo mostra o gráfico padrão usando `geom_sf` e mais alguns exemplos de customização. Note que os argumentos são essencialmente os mesmos que se fornece à função `geom_line`/`geom_path`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#|\nggplot(seine) + geom_sf()\nggplot(seine) + geom_sf(lwd = 1)\nggplot(seine) + geom_sf(lwd = 0.4, color = \"dodgerblue3\")\nggplot(seine) + geom_sf(linetype = 2)\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](12-2-mapas_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n### Polígonos\n\nVamos começar importando um shapefile dos estados do Brasil, usando o excelente `{geobr}`. Note que este objeto possui uma coluna `geom` que guarda um objeto do tipo `MULTIPOLYGON`. Este é um tipo de polígono.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nufs <- geobr::read_state(showProgress = FALSE)\n\nufs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 27 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -73.99045 ymin: -33.75208 xmax: -28.83594 ymax: 5.271841\nGeodetic CRS:  SIRGAS 2000\nFirst 10 features:\n   code_state abbrev_state name_state code_region name_region\n1          11           RO   Rondônia           1       Norte\n2          12           AC       Acre           1       Norte\n3          13           AM   Amazonas           1       Norte\n4          14           RR    Roraima           1       Norte\n5          15           PA       Pará           1       Norte\n6          16           AP      Amapá           1       Norte\n7          17           TO  Tocantins           1       Norte\n8          21           MA   Maranhão           2    Nordeste\n9          22           PI      Piauí           2    Nordeste\n10         23           CE      Ceará           2    Nordeste\n                             geom\n1  MULTIPOLYGON (((-63.32721 -...\n2  MULTIPOLYGON (((-73.18253 -...\n3  MULTIPOLYGON (((-67.32609 2...\n4  MULTIPOLYGON (((-60.20051 5...\n5  MULTIPOLYGON (((-54.95431 2...\n6  MULTIPOLYGON (((-51.1797 4....\n7  MULTIPOLYGON (((-48.35878 -...\n8  MULTIPOLYGON (((-45.84073 -...\n9  MULTIPOLYGON (((-41.74605 -...\n10 MULTIPOLYGON (((-41.16703 -...\n```\n\n\n:::\n:::\n\n\nO código abaixo monta o mapa.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(ufs) +\n  geom_sf()\n```\n\n::: {.cell-output-display}\n![](12-2-mapas_files/figure-html/unnamed-chunk-13-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nA função `geom_sf` aceita vários argumentos estéticos já que ela desenha pontos, linhas e polígonos. No caso do mapa abaixo, `color` define a cor do contorno/fronteira do polígono, enquanto `fill` define a cor do interior do polígono.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(ufs) +\n  geom_sf(color = \"gray90\", aes(fill = name_region), lwd = 0.05) +\n  scale_fill_brewer(name = \"\", type = \"qual\") +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![](12-2-mapas_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nPor fim, vale notar que é possível usar a função `coord_sf` para fazer um \"zoom\" no mapa.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(ufs) +\n  geom_sf(aes(fill = name_region), lwd = 0.05) +\n  scale_fill_brewer(name = \"\", type = \"qual\") +\n  theme(legend.position = \"top\") +\n  coord_sf(xlim = c(-60, -48), ylim = c(-35, -20))\n```\n\n::: {.cell-output-display}\n![](12-2-mapas_files/figure-html/unnamed-chunk-15-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n# Mapas coropléticos\n\nUm mapa coroplético é um mapa colorido, em que as cores representam valores de alguma variável. Há inúmeros exemplos de mapas coropléticos. Abaixo listo alguns posts recentes em que faço mapas deste tipo.\n\n-   [Taxa de veículos em São Paulo](https://restateinsight.com/posts/general-posts/2023-11-wz-cars/)\n\n-   [Taxa de envelhecimento nos municípios do Brasil](https://restateinsight.com/posts/general-posts/2023-11-wz-census-ages/)\n\n-   [Taxa de crescimento geométrico nos municípios do Brasil](https://restateinsight.com/posts/general-posts/2023-10-wz-census/)\n\n## Juntando shapes e dados\n\nPara compor este tipo de mapa é necessário combinar dados tabulares com objetos geométricos. No exemplo abaixo, vamos novamente considerar a tabela de tipo de propriedade do domicílio por UF.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nrented <- tibble::tribble(\n  ~abbrev_state,\n  ~share_apto,\n  ~share_rented,\n  ~name_region,\n  #------------#------------#--------------#------------#\n  \"RO\",\n  8,\n  11.1,\n  \"Norte\",\n  \"AC\",\n  7.47,\n  6.93,\n  \"Norte\",\n  \"AM\",\n  15.8,\n  7.26,\n  \"Norte\",\n  \"RR\",\n  14.3,\n  11.7,\n  \"Norte\",\n  \"PA\",\n  4.53,\n  6.39,\n  \"Norte\",\n  \"AP\",\n  10.7,\n  6.34,\n  \"Norte\",\n  \"TO\",\n  3.17,\n  11.7,\n  \"Norte\",\n  \"MA\",\n  4.06,\n  5.74,\n  \"Nordeste\",\n  \"PI\",\n  4.08,\n  5.15,\n  \"Nordeste\",\n  \"CE\",\n  9.85,\n  9.68,\n  \"Nordeste\",\n  \"RN\",\n  9.27,\n  10.8,\n  \"Nordeste\",\n  \"PB\",\n  11.9,\n  9.18,\n  \"Nordeste\",\n  \"PE\",\n  10.4,\n  9.98,\n  \"Nordeste\",\n  \"AL\",\n  6.32,\n  10.0,\n  \"Nordeste\",\n  \"SE\",\n  12.0,\n  11,\n  \"Nordeste\",\n  \"BA\",\n  12.0,\n  7.61,\n  \"Nordeste\",\n  \"MG\",\n  14.0,\n  10.5,\n  \"Sudeste\",\n  \"ES\",\n  21.7,\n  10.7,\n  \"Sudeste\",\n  \"RJ\",\n  26.8,\n  10.7,\n  \"Sudeste\",\n  \"SP\",\n  19.4,\n  12.7,\n  \"Sudeste\",\n  \"PR\",\n  11.9,\n  11.7,\n  \"Sul\",\n  \"SC\",\n  17,\n  11.8,\n  \"Sul\",\n  \"RS\",\n  16.5,\n  8.46,\n  \"Sul\",\n  \"MS\",\n  3.67,\n  11.9,\n  \"Centro Oeste\",\n  \"MT\",\n  3.29,\n  12.7,\n  \"Centro Oeste\",\n  \"GO\",\n  9.88,\n  13.6,\n  \"Centro Oeste\",\n  \"DF\",\n  35.4,\n  17.8,\n  \"Centro Oeste\"\n)\n```\n:::\n\n\nPara juntar esta base com o shapefile das UFs, gerado pelo `geobr`, basta usar a função `left_join` do pacote `dplyr`. Esta função tem o cuidado de preservar a geometria do objeto espacial. Note que o objeto espacial (`sf`) deve sempre vir na esquerda: `left_join(objeto_espacial, base_de_dados, by = \"chave\")`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nufs_rent <- left_join(ufs, rented, by = \"abbrev_state\")\n\nggplot(ufs_rent) +\n  geom_sf(aes(fill = share_rented)) +\n  scale_fill_distiller(direction = 1) +\n  coord_sf(xlim = c(NA, -35))\n```\n\n::: {.cell-output-display}\n![](12-2-mapas_files/figure-html/unnamed-chunk-17-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n## Temas para mapas\n\nNão há grande variedade de temas para mapas. Em geral, usa-se ou `ggthemes::theme_map()` ou `theme_void()`. Estes temas apagam a maioria dos elementos temáticos do gráfico, como eixos e linhas de grade.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbase_map <- ggplot(ufs_rent) +\n  geom_sf(aes(fill = share_rented)) +\n  scale_fill_distiller(direction = 1, palette = 2) +\n  coord_sf(xlim = c(NA, -35))\n\nbase_map +\n  ggtitle(\"theme_map()\") +\n  ggthemes::theme_map()\n```\n\n::: {.cell-output-display}\n![](12-2-mapas_files/figure-html/unnamed-chunk-18-1.png){fig-align='center' fig-pos='hold' width=100%}\n:::\n\n```{.r .cell-code}\nbase_map +\n  ggtitle(\"theme_void()\") +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](12-2-mapas_files/figure-html/unnamed-chunk-18-2.png){fig-align='center' fig-pos='hold' width=100%}\n:::\n:::\n\n\n## Discretizando dados contínuos\n\nO olho humano não é particularmente apto a distinguir diferenças sutis entre cores, quando dispotas lado a lado. Neste sentido, pode ser difícil captar certas nuances nos mapas coropléticos acima.\n\nHá três maneiras simples de agrupar dados contínuos para fazer mapas:\n\n1.  Usar alguma variação de percentil, isto, quintis, decis, etc.\n2.  Usar o algoritmo de Jenks.\n3.  Usar a distribuição dos dados.\n4.  Definir quebras manualmente.\n\nVamos montar o mapa da renda domiciliar per capita de Porto Alegre a nível de setor censitário. Para importar os dados vamos usar o pacote `censobr`. O código abaixo é adaptado da páginas de exemplos do pacote.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(arrow)\nlibrary(censobr)\n\n#> Importa o shapefile dos setores censitários de Porto Alegre\ntracts <- geobr::read_census_tract(\n  code_tract = 4314902,\n  year = 2010,\n  simplified = FALSE,\n  showProgress = FALSE\n)\n\n#> Importa a tabela Basico do Censo (2010)\ntract_basico <- read_tracts(\n  year = 2010,\n  dataset = \"Basico\",\n  showProgress = FALSE\n)\n#> Importa a tabela DomicilioRenda do Censo (2010)\ntract_income <- read_tracts(\n  year = 2010,\n  dataset = \"DomicilioRenda\",\n  showProgress = FALSE\n)\n\n#> Seleciona as colunas relevantes\ntract_basico <- tract_basico |>\n  dplyr::filter(code_muni == \"4314902\") |>\n  dplyr::select('code_tract', 'V002')\n\ntract_income <- tract_income |>\n  dplyr::filter(code_muni == \"4314902\") |>\n  dplyr::select('code_tract', 'V003')\n\n#> Juntas as bases e importa os dados\ntracts_df <- dplyr::left_join(tract_basico, tract_income)\ntracts_df <- dplyr::collect(tracts_df)\n#> Calcula a renda per capita\ntracts_df <- dplyr::mutate(tracts_df, income_pc = V003 / V002)\n#> Junta os dados com o shapefile\npoa_tracts <- left_join(tracts, tracts_df, by = \"code_tract\")\n```\n:::\n\n\nO mapa abaixo mostra o renda domiciliar per capita na zona central de Porto Alegre em cada setor censitário. Pode-se ver, de maneira geral, uma concentração de alta renda na região central em torno dos bairros Moinhos de Vento e Auxiliadora. Já as regiões periféricas da cidade tem renda mais baixa, com exceção de uma parte da Zona Sul da cidade.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(poa_tracts) +\n  geom_sf(aes(fill = income_pc), color = \"white\", lwd = 0.01) +\n  scale_fill_distiller(name = \"\", palette = \"Greens\") +\n  coord_sf(xlim = c(-51.32, -51.1), ylim = c(-30.15, -30)) +\n  ggthemes::theme_map()\n```\n\n::: {.cell-output-display}\n![](12-2-mapas_files/figure-html/unnamed-chunk-20-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n### Quintis e decis\n\nÉ relativamente simples classificar os dados em percentis usando a função `dplyr::ntile`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Quintis e decis\npoa_tracts <- poa_tracts |>\n  mutate(\n    quintil = factor(ntile(income_pc, 5)),\n    decil = factor(ntile(income_pc, 10))\n  )\n```\n:::\n\n\nO mapa abaixo mostra a distribuição espacial do rendimento domiciliar per capita em Porto Alegre por quintis. Nesta visualização, é bastante imediato perceber os grupos de renda da cidade. Note que a legenda do mapa, infelizmente, não mostra o intervalo de renda de cada grupo. Para montar uma legenda mais instrutiva é preciso um pouco de criatividade. A solução mais imediata, que consome menos linhas de código, é usar a função `cut` em conjunto com a função `quantile`. Na minha experiência, os resultados desta combinação costumam ser pouco satisfatórios; o trabalho adicional de se construir a legenda costuma compensar.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(poa_tracts) +\n  geom_sf(aes(fill = quintil), color = \"white\", lwd = 0.1) +\n  scale_fill_brewer(name = \"\", palette = \"Greens\") +\n  ggtitle(\"Mapa de quintis\") +\n  coord_sf(xlim = c(-51.32, -51.1), ylim = c(-30.15, -30)) +\n  ggthemes::theme_map()\n```\n\n::: {.cell-output-display}\n![](12-2-mapas_files/figure-html/unnamed-chunk-22-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nO código abaixo calcula os quantis e monta uma legenda. O código pode parecer um pouco grande, mas é fácil criar uma função que reproduz este funcionamento.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nq <- quantile(poa_tracts$income_pc, seq(0.2, 0.8, 0.2), na.rm = TRUE)\nq <- format(round(q), big.mark = \".\", trim = TRUE)\n\nl <- paste(q, q[-1], sep = \"-\")\nl <- c(paste(\"<\", q[1]), l)\nl[length(l)] <- paste(\">\", q[length(q)])\n\nl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"< 531\"       \"531-928\"     \"928-1.526\"   \"1.526-2.372\" \"> 2.372\"    \n```\n\n\n:::\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_legend_discrete <- function(x) {\n  y <- suppressWarnings(format(round(x), big.mark = \".\", trim = TRUE))\n\n  l <- paste(y, y[-1], sep = \"-\")\n  l <- c(paste(\"<\", y[1]), l)\n  l[length(l)] <- paste(\">\", y[length(y)])\n\n  return(l)\n}\n```\n:::\n\n\nO mapa abaixo mostra a renda per capita em decis. Agora usamos a escala de cores `viridis` que costuma funcionar bem com mapas.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndecis <- quantile(poa_tracts$income_pc, seq(0.1, 0.9, 0.1), na.rm = TRUE)\nlabel_decil <- get_legend_discrete(decis)\n\nggplot(poa_tracts) +\n  geom_sf(aes(fill = decil), color = \"white\", lwd = 0.1) +\n  scale_fill_viridis_d(name = \"\", label = label_decil) +\n  ggtitle(\"Mapa de Decis\") +\n  coord_sf(xlim = c(-51.32, -51.1), ylim = c(-30.15, -30)) +\n  ggthemes::theme_map()\n```\n\n::: {.cell-output-display}\n![](12-2-mapas_files/figure-html/unnamed-chunk-25-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n### Algoritmo de Jenks\n\nO [algoritmo de Jenks](https://en.wikipedia.org/wiki/Jenks_natural_breaks_optimization), também conhecido como algoritmo de quebras naturais, serve para classificar dados em grupos. Essencialmente, o algoritmo tenta encontrar $k$ grupos que sejam o mais homogêneos possíveis. Este método foi desenvolvido pelo cartógrafo [George Jenks](https://en.wikipedia.org/wiki/George_F._Jenks) e costuma funcionar muito bem para a construção de mapas. A implementação mais eficiente do algoritmo no `R` é feita via `BAMMtools::getJenksBreaks`.\n\nNote que é preciso escolher manualmente o número de grupos $k$. Em geral, vale experimentar com alguns valores entre 3-9. Para melhor entender o funcionamento do algoritmo, o gráfico abaixo mostra o histograma da variável de renda per capita, onde as linhas retas indicam as quebras entre os grupos.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njenks <- BAMMtools::getJenksBreaks(poa_tracts$income_pc, k = 7)\n\nggplot(poa_tracts, aes(x = income_pc)) +\n  geom_histogram(bins = 50) +\n  geom_vline(xintercept = jenks)\n```\n\n::: {.cell-output-display}\n![](12-2-mapas_files/figure-html/unnamed-chunk-26-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nO mapa final é feito abaixo.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npoa_tracts <- poa_tracts |>\n  mutate(\n    jenks_groups = factor(findInterval(income_pc, jenks))\n  )\n\n#> Construir a legenda\nlabel_jenks <- get_legend_discrete(jenks)\nlabel_jenks[length(label_jenks)] <- NA\n\nggplot(poa_tracts) +\n  geom_sf(aes(fill = jenks_groups), color = NA) +\n  scale_fill_brewer(\n    name = \"\",\n    palette = \"Greens\",\n    labels = label_jenks,\n    na.value = \"gray70\"\n  ) +\n  ggtitle(\"Mapa de Quebras Naturais (Jenks)\") +\n  coord_sf(xlim = c(-51.32, -51.1), ylim = c(-30.15, -30)) +\n  ggthemes::theme_map() +\n  theme(plot.background = element_rect(fill = \"white\"))\n```\n\n::: {.cell-output-display}\n![](12-2-mapas_files/figure-html/unnamed-chunk-27-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n### Mapa de desvio-padrão\n\nTambém é possível construir mapas usando medidas de dispersão estatísticas tradicionais, como a distância interquartílica ou desvio-padrão. Neste exemplo, vamos classificar os dados como desvios-padrão em relação à média. Para melhorar a visualização, vamos primeiro usar uma transformação log nos dados de renda para que a distribuição fique mais próxima de uma normal.\n\nEste tipo de gráfico funciona bem com escalas de cores divergentes. Note como este mapa destaca as regiões de renda muito alta e também as regiões vulneráveis de renda muito baixa.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npoa_tracts <- poa_tracts |>\n  mutate(\n    lincome_pc = log(income_pc),\n    scale_income = as.numeric(scale(lincome_pc)),\n    sd_groups = factor(findInterval(scale_income, c(-2, -1, 0, 1, 2)))\n  )\n\nl <- c(\"< -2\", \"-2 a -1\", \"-1 a 0\", \"0 a 1\", \"1 a 2\", \"> 2\")\nl <- paste(l, \"SD\")\n\nggplot(poa_tracts) +\n  geom_sf(aes(fill = sd_groups), color = NA) +\n  scale_fill_brewer(\n    name = \"\",\n    palette = \"RdBu\",\n    labels = l,\n    na.value = \"gray70\"\n  ) +\n  ggtitle(\"Mapa de Desvio Padrão\") +\n  coord_sf(xlim = c(-51.32, -51.1), ylim = c(-30.15, -30)) +\n  ggthemes::theme_map()\n```\n\n::: {.cell-output-display}\n![](12-2-mapas_files/figure-html/unnamed-chunk-28-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n# Posts relacionados\n\n-   [You need a map - Parte 1](https://restateinsight.com/posts/tutorial-ggplot2/12-1-mapas)\n\n-   [Indo além: mapas de calor](https://restateinsight.com/posts/tutorial-ggplot2/11-grafico-calor)\n\n-   [Estético: Escalas e Cores](https://restateinsight.com/posts/tutorial-ggplot2/6-scales-labels)\n\n-   [Altitude das Ruas nas Cidades do Brasil](https://restateinsight.com/posts/general-posts/2023-10-mapas-altitude/)\n\n-   [Taxa de veículos em São Paulo](https://restateinsight.com/posts/general-posts/2023-11-wz-cars/)\n\n-   [Taxa de envelhecimento nos municípios do Brasil](https://restateinsight.com/posts/general-posts/2023-11-wz-census-ages/)\n\n-   [Taxa de crescimento geométrico nos municípios do Brasil](https://restateinsight.com/posts/general-posts/2023-10-wz-census/)\n",
    "supporting": [
      "12-2-mapas_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}