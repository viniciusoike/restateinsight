{
  "hash": "5677c5b56e8a7392ca311b618ff04030",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'Indo além: empilhando áreas'\ndate: '2023-11-01'\ncategories: ['data-visualization', 'ggplot2', 'tutorial-R']\ndescription: \"Post intermediário que ensina a fazer gráficos de área no R usando o pacote ggplot2.\"\ntitle-block-banner: true\nimage: \"/static/ggplot2_area.png\"\nimage-alt: \"/static/ggplot2_area.png\"\nexecute:\n  message: false\n  warning: false\n  eval: false\nformat:\n  html:\n    code-fold: false\n    code-tools: true\n---\n\n\n\n# Gráfico de Área\n\nGráficos de área ajudam a visualizar a dinâmica de um conjunto de valores ao longo do tempo. Um gráfico de área é, essencialmente, um gráfico de linha, que passa por cima de uma região sombreada. Pode-se empilhar pequenos gráficos de linha uns sobre os outros de tal maneira que a área entre as linhas fica preenchida com cores. Isto permite que se veja a tendência geral dos dados, assim como a contribuição de cada grupo para o resultado total.\n\n\n::: {.cell}\n\n:::\n\n\nEste post ensina como fazer gráficos de área usando o `ggplot2` no `R`. Primeiro, vamos ganhar intuição construindo um gráfico simples a partir de dados simluados. Depois, vamos revisar os principais elementos estéticos de um gráfico de área.\n\nVisto o básico, partiremos para um caso aplicado, analisando as concessões de crédito direcionadas no Brasil. Neste exemplo, vamos usar o conhecimento de escalas e temas para aprimorar o gráfico de área. Por fim, vamos explorar uma base de projeções demográficas do Brasil usando gráficos de área.\n\n## ggplot2\n\nAntes de mais nada, precisamos instalar e carregar alguns pacotes. Assim como em posts anteriores, além do pacote `ggplot2` vamos utilizar alguns pacotes auxiliares para facilitar a manipulação dos dados.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Instala o pacote ggplot2 (se necessário)\ninstall.packages(c(\"dplyr\", \"tidyr\", \"ggplot2\", \"RcppRoll\", \"GetBCBData\"))\n\n#> Carrega os pacotes\nlibrary(\"ggplot2\")\n#> Manipulação de dados\nlibrary(\"dplyr\")\nlibrary(\"tidyr\")\nlibrary(\"RcppRoll\")\n#> Importar dados da API do Banco Central do Brasil\nlibrary(\"GetBCBData\")\n```\n:::\n\n\n### Exemplo simulado\n\nPrimeiro, vamos simular alguns dados para o nosso gráfico de área. No primeiro exemplo vamos montar uma base de dados (`tibble`) com os valores de uma série de vendas anuais de 2000 a 2005.\n\nA coluna `ano` é uma variável contínua de 2000 a 2005. As colunas `venda_a`, `venda_b` e `venda_c` representam números hipotéticos de venda três lojas distintas (\"1\", \"2\" e \"3\").\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl <- tibble(\n  ano = 2000:2005,\n  venda_1 = c(20, 24, 23, 27, 25, 26),\n  venda_2 = c(30, 22, 17, 23, 21, 18),\n  venda_3 = c(18, 19, 17, 17, 18, 19)\n)\n```\n:::\n\n\nA tabela tem a forma abaixo.\n\n\n::: {.cell}\n\n:::\n\n\nUsamos a função `geom_area()` para criar um gráfico de área. Esta função recebe os argumentos `x` e `y`, que mapeiam as variáveis de dados no eixo x e no eixo y do gráfico, respectivamente.\n\nO código abaixo monta um gráfico de área que mostra o número de vendas na loja 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = tbl) +\n  geom_area(aes(x = ano, y = venda_1))\n```\n:::\n\n\nPara adicionar as vendas das outras lojas precisamos remodelar o formato dos nossos dados. Nossos dados estão em formato \"wide\", no qual cada variável (vendas) é uma coluna distinta e cada observação é uma linha. O `ggplot2` segue os princípios de tidy data e funciona melhor com dados em formato \"long\", onde cada linha é uma observação única.\n\nConvertemos os nossos dados para o formato \"long\" utilizando a função `pivot_longer()` da seguinte maneira:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong <- pivot_longer(\n  tbl,\n  venda_1:venda_3,\n  names_to = \"loja\",\n  values_to = \"total\"\n)\n```\n:::\n\n\nAgora cada linha representa o número de vendas em uma loja específica e num ano específico. Além disso, cada coluna é uma variável diferente: a coluna `ano` indica que o ano da observação, a coluna `loja` indica a loja e a coluna `total` indica o total de vendas.\n\n\n::: {.cell}\n\n:::\n\n\nAgora que temos nossos dados preparados, podemos montar nosso gráfico de área. Além dos argumentos `x` e `y`, também vamos especificar o argumento `fill` para indicar qual variável deve ser utilizada para preencher as cores entre as linhas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = long) +\n  geom_area(aes(x = ano, y = total, fill = loja))\n```\n:::\n\n\n### Factors\n\nNo gráfico acima, as áreas são empilhadas umas sobre as outras. Tipicamente, os grupos com os valores mais altos devem estar no topo da pilha e os grupos com valores mais baixos, na parte inferior. Na prática, a ordem é determinada pela ordem da variável `fill`. Neste caso, a ordem é dada pela variável categória `loja`[^1]. Variáveis categóricas no `R` sempre devem ser do tipo `factor`. Já se apresentou factors anteriormente, mas vale a pena revisar esta importante classe.\n\n[^1]: Para uma breve revisão sobre variáveis categóricas ou discretas, consulte o [post](https://restateinsight.com/posts/ggplot2-tutorial/6-scales-labels#variáveis-discretas).\n\nUm `factor` é um tipo especial de string que possui um ordenamento (`levels`) que define a relação hierárquica entre os grupos. Imagine que você tem uma série de avaliações que podem ser \"Bom\", \"Médio\" ou \"Ruim\" armazenadas num vetor chamado `feedback`. Para estruturar esta variável como `factor` é preciso definir qual a ordem destes valores. No exemplo abaixo define-se uma relação crescente: de \"Ruim\" até \"Bom\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfeedback <- c(\"Bom\", \"Bom\", \"Médio\", \"Ruim\", \"Médio\", \"Médio\")\nsatisfacao <- factor(feedback, levels = c(\"Ruim\", \"Médio\", \"Bom\"))\n```\n:::\n\n\nNo caso do gráfico acima, como não definimos a ordem da variável categórica, o `ggplot2` tenta adivinha-la. De maneira geral, o `ggplot` respeita a ordem alfabética e a ordem de grandeza numérica. Por isso, no gráfico acima a ordem foi `venda_1`, `venda_2` e `venda_3`.\n\nPara definir a ordem dos lojass é preciso criar uma variável do tipo `factor` e especificar o argumento `levels`. O exemplo abaixo define uma nova ordem para os grupos o que resulta num gráfico diferente.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong_reordenado <- long |>\n  mutate(\n    loja = factor(loja, levels = c(\"venda_3\", \"venda_1\", \"venda_2\"))\n  )\n\nggplot(data = long_reordenado) +\n  geom_area(aes(x = ano, y = total, fill = loja))\n```\n:::\n\n\n## Elementos estéticos\n\nOs principais elementos estéticos da função `geom_area()` são\n\n-   `fill` - A cor que preenche a área abaixo da linha.\n-   `color` - A cor da linha.\n-   `alpha` - O nível de transparência das cores.\n-   `linetype` - O tipo de linha (tracejado).\n-   `linewidth` - A espessura da linha.\n\nOs elementos estéticos podem receber dois tipos de valores: constantes ou variáveis. Uma constante é simplesmente um valor (número, texto, etc.) enquanto uma variável é o nome de alguma coluna da base de dados. Mapear variáveis em elementos estéticos permite fazer um gráfico de área em que cada cor representa um grupo distinto, como se viu no exemplo anterior.\n\nO gráfico abaixo mostra o volume de inventário de casas à venda em três cidades no Texas, usando a base `txhousing`. Note que o elemento `fill` é variável e definido como `fill = city` dentro da função `aes()`. Quando se mapeia uma coluna/variável para um elemento estético sempre se usa a função `aes()` da mesma maneira como se faz para mapear as variáveis `x` e `y`. Como a variável `city` é mapeada usa-se scale_fill_manual() para definir as suas cores e para controlar a legenda.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsub <- txhousing |>\n  filter(\n    city %in% c(\"Austin\", \"Houston\", \"Dallas\"),\n    year >= 2010\n  )\n\nggplot(data = sub) +\n  geom_area(aes(x = date, y = inventory, fill = city)) +\n  #> Define as cores e controla a legenda\n  scale_fill_manual(\n    #> Título da legenda\n    name = \"Cidades\",\n    #> Cores\n    values = c(\"#0a9396\", \"#ee9b00\", \"#ae2012\")\n  )\n```\n:::\n\n\nPara seguir os exemplos abaixo será útil definir este gráfico como um template padrão. Vamos chamá-lo de `base_plot`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot <- ggplot(sub, aes(x = date, y = inventory, fill = city)) +\n  #> Define as cores e controla a legenda\n  scale_fill_manual(\n    #> Título da legenda\n    name = \"Cidades\",\n    #> Cores\n    values = c(\"#0a9396\", \"#ee9b00\", \"#ae2012\")\n  ) +\n  guides(fill = \"none\")\n```\n:::\n\n\n### alpha\n\nO argumento `alpha` controla o nível de transparência do objeto, isto é, da linha e da área abaixo da linha. O valor escolhido deve variar entre 0 e 1, onde 0 indica transparência máxima. Também é possível mapear uma coluna usando `alpha`, de maneira que cada grupo será representado por um nível de transparência distinto, mas há pouca utilidade prática nisto. O painel de gráficos abaixo mostra alguns valores de `alpha`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot + geom_area(alpha = 0.2)\nbase_plot + geom_area(alpha = 0.4)\nbase_plot + geom_area(alpha = 0.6)\nbase_plot + geom_area(alpha = 0.8)\n```\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n### fill e color\n\nO padrão da função `geom_area` é de sempre manter os argumentos `fill` e `color` iguais. Isto garante uma visualização simples e fluída. Contudo, é possível definir especificamente uma cor para cada elemento. O argumento `color` define a cor da linha no topo da área, enquanto `fill` define a cor que preenche a área. Para mostrar isto, usa-se novamente o exemplo com dados simulados.\n\nNote que para tornar a cor da linha mais aparente uso `linewidth = 3`. Isto torna a linha mais espessa.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Linha e área tem a mesma cor\nggplot(tbl, aes(x = ano, y = venda_1)) +\n  geom_area(fill = \"#0a9396\")\n\n#> Linha amarela e área verde\nggplot(tbl, aes(x = ano, y = venda_1)) +\n  geom_area(fill = \"#0a9396\", color = \"#ee9b00\", linewidth = 3)\n\n#> Linha e área tem a mesma cor\nggplot(long, aes(x = ano, y = total, fill = loja)) +\n  geom_area()\n\n#> Linha amarela e área variando por grupo\nggplot(long, aes(x = ano, y = total, fill = loja)) +\n  geom_area(color = \"#ee9b00\", linewidth = 3)\n```\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n### linetype e linewidth\n\nEstes argumentos se comportam da mesma maneira como no caso de gráficos de linha, com a função `geom_line`. O argumento `linetype` controla o tipo da linha (e.g. sólida, tracejada, etc.) enquanto `linewidth` controla a espessura da linha. Note que os argumento serão aplicados apenas se houver uma diferença entre `color` e `fill`.\n\nO exemplo abaixo mostra como mudar o tipo da linha que fica sobre a área colorida. Para ver os demais tipos de linha consulte o [post inicial sobre gráficos de linha](https://restateinsight.com/posts/ggplot2-tutorial/4-grafico-de-linha#opções-estéticas).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot + geom_area(linetype = 5)\nbase_plot + geom_area(color = \"white\", linetype = 1)\nbase_plot + geom_area(color = \"white\", linetype = 5)\nbase_plot + geom_area(color = \"white\", linetype = 6)\n```\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\nO painel de gráficos abaixo mostra como variar a espessura da linha. Novamente, este argumento será aplicado apenas se o argumento `color` for diferente do argumento `fill`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot + geom_area(color = \"white\", linewidth = 0.5)\nbase_plot + geom_area(color = \"white\", linewidth = 1)\nbase_plot + geom_area(color = \"white\", linewidth = 2)\nbase_plot + geom_area(color = \"white\", linewidth = 5)\n```\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n# Crédito Direcionado\n\nAgora vamos seguir para um exemplo aplicado. Vamos explorar o volume de crédito direcionado para pessoas físicas no Brasil. Para importar os dados vamos usar o pacote `GetBCBData` que interage com a API do Banco Central do Brasil e que traz os dados já no formato \"long\" dentro do `R`.\n\nO código abaixo importa as séries de tempo e identifica elas. A manipulação de dados é feita usando funções do pacote `dplyr`. Cria-se uma coluna chamada `linha_credito` que identifica o nome da linha de crédito a partir do ID da série.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Códigos numéricos das séries de crédito direcionado para Pessoas Físicas\ncodigos <- c(20701, 20704, 20708, 20712, 20713)\n#> Importa as séries a partir de 01/mar/2011\nseries <- gbcbd_get_series(codigos, first.date = as.Date(\"01-03-2011\"))\n\n#> Cria uma coluna chamada linha_credito indicando qual a linha de crédito\nseries <- series |>\n  mutate(\n    linha_credito = case_when(\n      id.num == 20701 ~ \"Rural\",\n      id.num == 20704 ~ \"Imobiliário\",\n      id.num == 20708 ~ \"BNDES\",\n      id.num == 20712 ~ \"Microcrédito\",\n      id.num == 20713 ~ \"Outro\"\n    )\n  )\n```\n:::\n\n\nVamos montar um gráfico de área simples que mostra a composição e a evolução do crédito direcionado.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Plota o gráfico\nggplot(data = series) +\n  geom_area(aes(x = ref.date, y = value, fill = linha_credito))\n```\n:::\n\n\nEste gráfico pode ser melhorado de diversas formas. Vamos explorar algumas opções.\n\n### Reordenando os grupos\n\nPelo gráfico, vemos que o crédito rural e o crédito imobiliário são as linhas de crédito mais expressivas. O código abaixo reordena o nível dos grupos para dar mais destaque ao crédito imobiliário e ao crédito rural.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseries <- series |>\n  mutate(\n    linha_credito = factor(\n      linha_credito,\n      levels = c(\"Imobiliário\", \"Rural\", \"BNDES\", \"Microcrédito\", \"Outro\")\n    )\n  )\n\nggplot(data = series) +\n  geom_area(aes(x = ref.date, y = value, fill = linha_credito))\n```\n:::\n\n\n### Trocando as cores\n\nA escolha automática de cores do `ggplot` raramente é satisfatória. Podemos escolher novas cores manualmente usando a função `scale_fill_manual()`. Além disso, também adicionamos um título mais apropriado para a legenda das cores.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = series) +\n  geom_area(aes(x = ref.date, y = value, fill = linha_credito)) +\n  #> Define a cor dos grupos e adiciona um título na legenda\n  scale_fill_manual(\n    name = \"Linha de Crédito\",\n    values = c(\"#005f73\", \"#94d2bd\", \"#ee9b00\", \"#bb3e03\", \"#9b2226\")\n  )\n```\n:::\n\n\nUma solução mais prática é utilizar uma paleta pré-definida de cores. A função `scale_fill_brewer()`, por exemplo, possui várias paletas importadas do [Color Brewer](https://colorbrewer2.org).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = series) +\n  geom_area(aes(x = ref.date, y = value, fill = linha_credito)) +\n  #> Define a cor dos grupos e adiciona um título na legenda\n  scale_fill_brewer(\n    name = \"Linha de Crédito\",\n    type = \"qual\",\n    palette = 6\n  )\n```\n:::\n\n\n### Ajustando eixos\n\nPara ajustar os eixos utilizamos as funções `scale_`. Primeiro, vamos ajustar o eixo-x usando `scale_x_date`. Nesta função, `date_breaks` indica a frequências das quebras e `date_labels` indica o formato da data a ser impresso no eixo. No caso abaixo temos quebras anuais onde apenas o número (extenso) do ano é plotado.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = series) +\n  geom_area(aes(x = ref.date, y = value, fill = linha_credito)) +\n  scale_fill_brewer(name = \"Linha de Crédito\", type = \"qual\", palette = 6) +\n  scale_x_date(date_breaks = \"1 year\", date_labels = \"%Y\")\n```\n:::\n\n\nNote que há duas pequenas áreas entre o gráfico e os limites do painel. Pode-se suprimir esta área usando `expand = c(0, 0)` dentro da função `scale_`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = series) +\n  geom_area(aes(x = ref.date, y = value, fill = linha_credito)) +\n  scale_fill_brewer(name = \"Linha de Crédito\", type = \"qual\", palette = 6) +\n  scale_x_date(date_breaks = \"1 year\", date_labels = \"%Y\", expand = c(0, 0))\n```\n:::\n\n\nNo código abaixo a função `scale_y_continuous()` altera o eixo-y de três formas: primeiro, o argumento `breaks` define os números que devem ser destacados no eixo; segundo, o argumento `labels` modifica a aparência destes números no gráfico; por fim, `limits` estabelece os limites inferior e superior do eixo-y.\n\nA função `scales::label_number(big.mark = \".\")` pode parecer um pouco confusa, mas ela simplesmente informa que o sinal de ponto \".\" deve ser utilizado como separador de milhar. Assim `10000` é convertido para `10.000`[^2].\n\n[^2]: Na prática ela faz o mesmo que a função base \\`format()\\`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = series) +\n  geom_area(aes(x = ref.date, y = value, fill = linha_credito)) +\n  scale_fill_brewer(name = \"Linha de Crédito\", type = \"qual\", palette = 6) +\n  scale_x_date(date_breaks = \"1 year\", date_labels = \"%Y\", expand = c(0, 0)) +\n  #> Modifica o comportamento do eixo-y\n  scale_y_continuous(\n    breaks = seq(0, 60000, 10000),\n    labels = scales::label_number(big.mark = \".\"),\n    limits = c(0, 60000)\n  )\n```\n:::\n\n\n### Títulos e elementos temáticos\n\nPara adicionar títulos o modificar o nome de cada eixo utilizamos a função `labs()`. Para este gráfico escolhemos um tema neutro com fundo branco `theme_minimal()`. Além disso, adiciono alguns argumentos na função theme para customizar o gráfico. Para mais detalhes consulte [o post sobre elementos temáticos](https://restateinsight.com/posts/ggplot2-tutorial/7-themes-fonts).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = series) +\n  geom_area(aes(x = ref.date, y = value, fill = linha_credito)) +\n  geom_hline(yintercept = 0) +\n  scale_fill_brewer(name = \"Linha de Crédito\", type = \"qual\", palette = 6) +\n  scale_x_date(date_breaks = \"1 year\", date_labels = \"%Y\", expand = c(0, 0)) +\n  scale_y_continuous(\n    breaks = seq(0, 60000, 10000),\n    labels = scales::label_number(big.mark = \".\"),\n    limits = c(0, 60000)\n  ) +\n  #> Define o título e o nome dos eixos\n  labs(\n    title = \"Evolução das concessões de crédito direcionadas\",\n    caption = \"Fonte: Banco Central do Brasil.\",\n    #> Omite o nome do eixo-x\n    x = NULL,\n    y = \"Milhões (R$)\"\n  ) +\n  #> Insere um tema minimalista com fundo branco\n  theme_minimal(base_family = \"Helvetica\") +\n  theme(\n    legend.position = \"top\",\n    axis.text.x = element_text(angle = 90),\n    panel.grid.minor = element_blank(),\n    panel.grid.major.x = element_blank()\n  )\n```\n:::\n\n\n### Suavizando a série\n\nPor fim, pode-se suavizar a série para reduzir o impacto da sazonalidade na visualização. Isto não é uma decisão puramente estética, pois modifica os dados e troca a ênfase do gráfico: enxerga-se, agora, a tendência dos dados.\n\nHá muitas maneiras de se fazer isto. Pode-se, por exemplo, dessazonalizar os dados usando X-13 ARIMA; pode-se extrair a tendência das séries utilizando algum filtro linear como de médias móveis, Holt-Winters, filtro HP, etc.\n\nUma alternativa bastante simples é somar as últimas doze observações e criar uma janela móvel. Assim temos as concessões acumuladas nos últimos doze meses. Para calcular esta soma utilizamos a função `RcppRoll::roll_sumr()`. Como a magnitude dos valores aumenta, dividimos o valor final por mil (agora os valores estão em bilhões de reais).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseries <- series |>\n  group_by(linha_credito) |>\n  mutate(soma_12 = RcppRoll::roll_sumr(value, n = 12) / 1000) |>\n  ungroup()\n\nggplot(data = series) +\n  geom_area(aes(x = ref.date, y = soma_12, fill = linha_credito)) +\n  geom_hline(yintercept = 0) +\n  scale_x_date(date_breaks = \"1 year\", date_labels = \"%Y\", expand = c(0, 0)) +\n  scale_fill_brewer(\n    name = \"Linha de Crédito\",\n    type = \"qual\",\n    palette = 6\n  ) +\n  labs(\n    title = \"Evolução das concessões de crédito direcionadas\",\n    subtitle = \"Concessões de crédito mensais (soma dos últimos 12 meses).\",\n    caption = \"Fonte: Banco Central do Brasil.\",\n    x = NULL,\n    y = \"R$ (bilhões)\"\n  ) +\n  theme_minimal() +\n  theme(\n    legend.position = \"top\"\n  )\n```\n:::\n\n\n### Resumo\n\nEm suma, há duas decisões importantes a se fazer com gráficos de área:\n\n1.  *Reordenar a ordem dos grupos*. A variável que define os grupos deve sempre ser um `factor` e sua ordem deve ser significativa. Em geral, apresentar os grupos em ordem decrescente pode ser a melhor opção, mas há exceções.\n2.  *Suavizar as séries de dados*. Oscilações sazonais ou quebras de nível drásticas não são muito bonitas em gráficos de área. Nestes casos, pode ser interessante suavizar a série ou considerar outro tipo de gráfico, como um gráfico de linha convencional.\n\nAs demais melhorias apresentadas, como ajustar eixos e cores, são majoritariamente estéticas, mas devem ser feitas em qualquer tipo de gráfico. As cores, eixos e tema padrões do ggplot2 não são adequadas para uma visualização bem trabalhada.\n\n# Demografia\n\nVamos explorar algumas tendências demográficas do Brasil. Os dados são do projeto de projeções populacionais da ONU (*World Population Prospects*) e estão disponíves em formato `csv` e `xlsx` no [site](https://population.un.org/wpp/Download/Standard/MostUsed/). Esta base de dados, em particular, inclui tanto valores passados como projeções futuras para a população mundial, por países.\n\nA tabela que vamos usar contém as estimativas passadas e projeções futuras da população em grupos de cinco anos (0-4, 5-9, 10-14, ..., 100+) por sexo. Para ler os dados usamos a função `read_csv()`. Vamos considerar somente a janela entre 2000 e 2050 e a variável `pop_total` que estimativa da população total num determinado ano. Para facilitar a leitura, os dados são agregados em grupos maiores: crianças (0-14), adolescentes (15-24), adultos (25-64) e idosos (65+).\n\nO código abaixo faz a manipulação de dados necessária para montar os gráficos[^3].\n\n[^3]: Para uma revisão sobre manipulação de dados consulte o [post da série sobre o asssunto](https://restateinsight.com/posts/ggplot2-tutorial/apendix-manipular-enxergar#manipulando-dados).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Importa a base de dados\nwpp <- read_csv(\n  \"https://github.com/viniciusoike/restateinsight/raw/main/posts/ggplot2-tutorial/wpp_brazil.csv\"\n)\n\n#> Seleciona apenas dados sobre o Brasil entre os anos de 2000 e 2050.\nbrazil <- wpp |>\n  filter(\n    location == \"Brazil\",\n    year >= 2000,\n    year <= 2050\n  )\n\n#> Soma o total da população a cada ano\npop <- brazil |>\n  group_by(year) |>\n  summarise(population = sum(pop_total)) |>\n  ungroup()\n\n#> Soma o total da população por grupos de idade a cada ano\npop_group <- brazil |>\n  group_by(year, age_group) |>\n  summarise(population = sum(pop_total)) |>\n  ungroup()\n\n#> Seleciona somente o grupo de adultos\npop_adult <- filter(brazil, age_group == \"25-64\")\n```\n:::\n\n\nAlém disso, vamos definir um tema padrão para nossos gráficos.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Define um tema padrão\ntheme_area <- theme_minimal(base_family = \"Helvetica\") +\n  theme(\n    legend.position = \"top\",\n    panel.grid.minor = element_blank(),\n    panel.grid.major.x = element_blank()\n  )\n```\n:::\n\n\nA tabela `pop` apresenta a população total projetada para cada ano e tem o formato abaixo. Os dados de população estão em milhares.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(pop)\n```\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\nVamos combinar a função `geom_area()` com outras duas: uma para fazer pontos e outra para traçar uma linha horizontal no zero do eixo-y. Para desenhar os pontos vamos utilizar a função `geom_point()` e para traçar a linha horizontal, `geom_hline()`. Para manter um padrão de cores vamos escolher uma constante `#2a9d8f` (um tom de verde-azulado).\n\nO código abaixo gera uma espécie de gráfico de linha, com pontos, com uma região sombreada. Note que os elementos estéticos `fill` e `color` são constantes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol = \"#2a9d8f\"\n\nggplot(data = pop, aes(x = year, y = population)) +\n  geom_area(alpha = 0.5, fill = col) +\n  #> Linha horizontal no 0\n  geom_hline(yintercept = 0) +\n  #> Pontos para destacar as observações\n  geom_point(color = col) +\n  theme_area\n```\n:::\n\n\nPodemos combinar o gráfico acima com a função `facet_wrap()` para montar quatro gráficos, mostrando a evolução da população dentro de cada um dos grupos[^4].\n\n[^4]: Para mais detalhes sobre a função `facet_wrap` consulte o post da série sobre o assunto.\n\nO grupo de crianças (0 a 14 anos) cai, enquanto o grupo de idosos (65+) aumenta expressivamente. O grupo de adultos (25-64) aumenta até atingir um máximo ao redor de 2040 e depois passa a cair suavemente. Por fim, o grupo de adolescentes/jovens (15-24) cai suavamente.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = pop_group, aes(x = year, y = population)) +\n  geom_area(alpha = 0.5, fill = col) +\n  geom_hline(yintercept = 0) +\n  geom_point(color = col) +\n  facet_wrap(vars(age_group)) +\n  theme_area\n```\n:::\n\n\nAssim como nos exemplos anteriores, podemos também empilhar os grupos e ter uma noção da representatividade de cada um deles no total da população. Neste gráfico, vê-se como a população total cresce cada vez mais devagar até quase estabilizar por volta de 2045. A composição da população se altera, além de crescer, com maior participação de idosos e menor participação de crianças na população.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = pop_group) +\n  geom_area(aes(x = year, y = population, fill = age_group)) +\n  geom_hline(yintercept = 0) +\n  scale_fill_brewer(name = \"\", type = \"qual\", palette = 6) +\n  theme_area\n```\n:::\n\n\nPode-se acrescentar elementos textuais no gráfico acima[^5]. Similarmente como se faz com gráficos de coluna, basta usar `position_stack(vjust = 0.5)` dentro de `geom_text` ou `geom_label`. Para evitar que os valores de todos os anos sejam plotados, crio uma variável auxiliar, `label`, que contém valores ausentes exceto em 2000 e em 2050. Além disso, para melhorar a visualização, faço um pequeno deslocamento na variável `year` para desclocar a posição horizontal do label[^6].\n\n[^5]: Para mais detalhes sobre como destacar informação com texto consulte o [post da série sobre o assunto](https://restateinsight.com/posts/ggplot2-tutorial/5-grafico-text#usando-texto).\n\n[^6]: Vale notar que o mesmo ajuste poderia ter sido realizado com `nudge_x` dentro de `geom_label`.\n\nNeste gráfico, fica evidente a mudança na composição entre cada grupo da população. Enquanto a população de crianças e adolescentes diminui, a população de idosos mais do que quintuplica no período de 50 anos, subindo de 9,5 milhão para pouco mais de 50 milhão. Os adultos continuam sendo o grupo mais expressivo da população, chegando a 121 milhão em 2050.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npop_group <- pop_group |>\n  mutate(\n    label = ifelse(!year %in% c(2000, 2050), NA, round(population / 1000, 1)),\n    x_pos = case_when(\n      year == 2000 ~ year + 2,\n      year == 2050 ~ year - 2,\n      TRUE ~ NA\n    )\n  )\n\nggplot(pop_group, aes(year, population, fill = age_group, group = age_group)) +\n  geom_area() +\n  geom_hline(yintercept = 0) +\n  #> Acrescenta os valores textuais no gráfico\n  geom_label(\n    aes(x = x_pos, y = population, label = label),\n    #> Define a cor do fundo do 'label'\n    fill = \"white\",\n    #> Alinhamento vertical\n    position = position_stack(vjust = 0.5)\n  ) +\n  scale_fill_brewer(name = \"\", type = \"qual\", palette = 6) +\n  theme_area\n```\n:::\n\n\nGráficos de área não costumam funcionar bem quando há muito grupos e, sobretudo , quando há pouca variação entre eles. O exemplo abaixo mostra a dinâmica da população adulta (25-64), em grupos de idade de cinco anos. Com o olhar atento, pode-se perceber que os grupos acima de 50 anos (50-54, 55-59 e 60-64) crescem em número absoluto e ganham participação. Ainda assim, é difícil distinguir diferenças entre os demais grupos.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(pop_adult, aes(x = year, y = pop_total / 1000, fill = age_subgroup)) +\n  geom_area(color = \"gray80\", linewidth = 0.5) +\n  scale_fill_viridis_d(name = \"\") +\n  geom_hline(yintercept = 0) +\n  theme_area\n```\n:::\n\n\n# Resumindo\n\nUm dos principais benefícios de usar gráficos de área é que eles permitem visualizar facilmente a tendência geral dos dados e a contribuição de cada grupo individual para o total. No geral, gráficos de área são uma ferramenta útil para visualizar a magnitude da mudança ao longo do tempo e comparar diferentes categorias ou grupos de dados uns com os outros. Estes gráficos também podem ser um substituto interessante para gráficos de linha convencionais.\n\nAbaixo seguem algumas recomendações finais na hora de fazer gráficos de área.\n\n1.  Não utilize um gráfico de área para representar mais do que 5 ou 6 grupos.\n2.  Escolha manualmente a ordem dos grupos para facilitar a visualização do gráfico.\n3.  Coloque a legenda de cores acima ou abaixo do gráfico para poupar espaço.\n4.  Use texto para destacar informações importantes.\n5.  Para facilitar a visualização, considere suavizar a série. Lembre-se de indicar que houve uma transformação nos dados.\n\n## Outros posts citados\n\n-   [Fundamentos: gráfico de coluna](https://restateinsight.com/posts/ggplot2-tutorial/2-grafico-coluna)\n-   [Fundamentos: gráfico de linha](https://restateinsight.com/posts/ggplot2-tutorial/4-grafico-de-linha)\n-   [Estético: Destacando informação](https://restateinsight.com/posts/ggplot2-tutorial/5-grafico-text)\n-   [Estético: Escalas e cores](https://restateinsight.com/posts/ggplot2-tutorial/6-scales-labels)\n-   [Estético: Tipografia e temas](https://restateinsight.com/posts/ggplot2-tutorial/7-themes-fonts)\n",
    "supporting": [
      "10-grafico-de-area_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}