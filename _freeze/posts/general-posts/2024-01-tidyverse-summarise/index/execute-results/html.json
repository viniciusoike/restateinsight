{
  "hash": "8354ee7dd49ee87e4ea32acd5a14f243",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"O novo tidyverse: summarise\"\ndate: \"2024-01-12\"\ncategories: ['data-science', 'tutorial-R', 'tidyverse']\ndescription: \"Neste post ensino abordagens diferentes para agregar dados de maneira eficiente. Mostro como aplicar funções sobre diversas colunas de uma base de dados ao mesmo tempo. Apresento também as novidades que o `dplyr` trouxe nos últimos anos como as funções tidyselectors, que ajudam a selecionar colunas com base em padrões lógicos.\"\nimage: \"/static/images/dplyr_logo.png\" \nimage-alt: \"/static/images/dplyr_logo.png\"\nexecute: \n  message: false\n  warning: false\n---\n\n\n\n# Tidyverse\n\nO tidyverse é uma coleção poderosa de pacotes, voltados para a manipulação e limpeza de dados. Num outro post, discuti alguns [aspectos gerais da filosofia](https://restateinsight.com/posts/general-posts/2023-09-tidyverse/) destes pacotes que incluem a sua consistência sintática e o uso de [pipes](https://restateinsight.com/posts/general-posts/2023-09-pipes-in-r/). A filosofia geral do tidyverse toma muito emprestado da gramática. As funções têm nomes de verbos que costumam ser intuitivos e são encadeados via \"pipes\" que funcionam como conectivos numa frase. Em tese, isto torna o código mais legível e até mais didático.\n\nO tidyverse está em constante expansão, novas funcionalidades são criadas para melhorar a performance e capabilidade de suas funções. Assim, é importante atualizar nosso conhecimento destes pacotes periodicamente. Nesta série de posts vou focar nas funções principais dos pacotes `dplyr` e `tidyr`, voltados para a limpeza de dados.\n\n# Alguns verbos\n\nEssencialmente, o `dplyr` gira em torno de quatro grandes funções: `filter`, `select`, `mutate` e `summarise`. Estas funções fazem o grosso do trabalho de limpeza de dados: filtram linhas, selecionam colunas e transformam os dados. A tabela abaixo resume as principais funções do pacote.\n\n| Nome da Função | Tradução | O que faz |\n|------------------------|------------------------|------------------------|\n| `rename` | Renomear | Modifica o nome das colunas. |\n| `select` | Selecionar | Seleciona as colunas. |\n| `filter` | Filtrar | Filtra/seleciona as linhas segundo alguma condição. |\n| `arrange` | Arranjar/ordenar | Ordena as linhas (crescente/decrescente) segundo alguma variável. |\n| `mutate` | Mutar/transformar | Cria uma nova coluna a partir de outras colunas ou dados. |\n| `summarise` | Sumarizar/resumir | Aplica alguma função sobre as linhas. Cria uma tabela \"resumo\". |\n| `group_by` | Agrupar | Agrupa as linhas segundo alguma variável. |\n\n# summarise\n\n## O básico\n\nOs pacotes utilizados neste tutorial são listados abaixo.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(readr)\n```\n:::\n\n\n\nPara praticar as funções vamos utilizar uma tabela que traz informações sobre as cidades do Brasil.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- readr::read_csv(\n  \"https://github.com/viniciusoike/restateinsight/raw/main/static/data/cities_brazil.csv\"\n  )\n```\n:::\n\n\n\nA função `summarise` (ou `summarize`) serve para agregar valores. Tipicamente, ela retorna uma única linha (por grupo) contendo estatísticas descritivas (e.g. média, desvio-padrão) sobre a base de dados.\n\nA sintaxe da função é bastante direta e similar à da função `mutate`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados |>\n  summarise(coluna_nova = f(coluna))\n```\n:::\n\n\n\nonde `f()` designa alguma transformação que é feita sobre os dados. Em geral, esta transformação é uma operação matemática (`sum`, `prod`) ou estatística (`mean`, `sd`, `var`, etc.) que retorna um único valor.\n\nO código abaixo calcula a população total e a população média de todos os municípios do Brasil. A soma da população de todos os municípios é igual à soma da população brasileira.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(dat, total_pop = sum(population), avg_pop = mean(population))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  total_pop avg_pop\n      <dbl>   <dbl>\n1 203062512  36456.\n```\n\n\n:::\n:::\n\n\n\n## Grupos\n\nA função `summarise` sempre é aplicada dentro de grupos. No caso em que não há grupos, a expressão é aplicada para a tabela inteira, como no exemplo acima. Agrupar facilita a interpretação dos dados e, na maioria dos casos, retorna resultados mais úteis.\n\nO código abaixo mostra a população total e a população média em cada uma das grandes regiões brasilieras. Note que, apesar do uso da função `group_by`, a tabela final não é agrupada; assim, não é necessário usar `ungroup()` como, por exemplo, no caso da função `mutate`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat |> \n  group_by(name_region) |> \n  summarise(\n    total_pop = sum(population),\n    avg_pop = mean(population)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  name_region  total_pop avg_pop\n  <chr>            <dbl>   <dbl>\n1 Centro Oeste  16287809  34878.\n2 Nordeste      54644582  30460.\n3 Norte         17349619  38555.\n4 Sudeste       84847187  50868.\n5 Sul           29933315  25133.\n```\n\n\n:::\n:::\n\n\n\nAlternativamente, podemos usar a nova sintaxe (ainda em fase experimental) `.by = \"grupo\"` das seguintes maneiras:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Usando data-masking\ndat |> \n  summarise(\n    total_pop = sum(population),\n    avg_pop = mean(population),\n    .by = name_region\n  )\n\n# Usando o nome do grupo como um vetor de texto\ndat |> \n  summarise(\n    total_pop = sum(population),\n    avg_pop = mean(population),\n    .by = \"name_region\"\n  )\n```\n:::\n\n\n\nA principal vantagem desta sintaxe é permitir o uso de um vetor de texto para determinar o agrupamento dos dados. Isto facilita a **organização do código** e também simplifica o uso da função `summarise` em funções customizadas, como veremos mais adiante.\n\nO código abaixo cria uma variável binária que indica se o município apresentou crescimento populacional no último ano e apresenta a população total e a população média por região.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Vetor com o nome das colunas 'agrupadoras'\ngroup_cols <- c(\"code_region\", \"name_region\", \"is_growing\")\n\ndat |> \n  # Cria um indicador igual a 1 se a população da cidade está crescendo\n  mutate(is_growing = if_else(population_growth_rate > 0, 1L, 0L)) |> \n  summarise(\n    total_pop = sum(population),\n    avg_pop = mean(population),\n    .by = group_cols\n  ) |> \n  arrange(code_region, is_growing)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 5\n   code_region name_region  is_growing total_pop avg_pop\n         <dbl> <chr>             <int>     <dbl>   <dbl>\n 1           1 Norte                 0   3943995  22282.\n 2           1 Norte                 1  13405624  49105.\n 3           2 Nordeste              0  22088024  24707.\n 4           2 Nordeste              1  32556558  36174.\n 5           3 Sudeste               0  20978264  32274.\n 6           3 Sudeste               1  63868923  62740.\n 7           4 Sul                   0   6993784  13122.\n 8           4 Sul                   1  22939531  34863.\n 9           5 Centro Oeste          0   1375791   8389.\n10           5 Centro Oeste          1  14912018  49215.\n```\n\n\n:::\n:::\n\n\n\nOs resultados finais, apresentados pela função `summarise` funcionam melhor quando são ordenados. Pode-se ter um ganho de eficiência ao ordenar as colunas após a agregação. Alternativamente, a base de dados pode ser organizada antes das agregrações, já que a função `summarise` preserva a ordem dos dados.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Menos eficiente\n# Ordena a tabela inteira (5570x22)\ndat |> \n  # Reordena as linhas\n  arrange(code_region, is_growing) |> \n  # Cria um indicador igual a 1 se a população da cidade está crescendo\n  mutate(is_growing = if_else(population_growth_rate > 0, 1L, 0L)) |> \n  summarise(\n    total_pop = sum(population),\n    avg_pop = mean(population),\n    .by = group_cols\n  )\n\n# Mais eficiente\n# Ordena apenas a tabela resumida (10x5)\ndat |> \n  # Cria um indicador igual a 1 se a população da cidade está crescendo\n  mutate(is_growing = if_else(population_growth_rate > 0, 1L, 0L)) |> \n  summarise(\n    total_pop = sum(population),\n    avg_pop = mean(population),\n    .by = group_cols\n  )\n  # Reordena as linhas somente no final\n  arrange(code_region, is_growing)\n```\n:::\n\n\n\n## Tranformando múltiplas colunas\n\nOs `tidyselectors` são uma importante inovação do `tidyverse` que permitem maior facilidade na escrita de códigos repetitivos. Imagine, por exemplo, que precisamos tirar algumas medidas estatísticas básicas, como a média e o desvio-padrão, de diversas colunas segundo algum grupo.\n\nNo nosso exemplo, podemos querer resumir as várias medidas de PIB e valor adicionado por grande região. Olhando para a base de dados, temos 8 colunas ao todo. Como temos 2 métricas (média e desvio-padrão), vamos precisar de, pelo menos, 8x2=16 linhas de código para chegar no resultado desejado.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(dat)[15:22]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"pib\"                \"pib_share_uf\"       \"pib_taxes\"         \n[4] \"pib_added_value\"    \"pib_agriculture\"    \"pib_industrial\"    \n[7] \"pib_services\"       \"pib_govmt_services\"\n```\n\n\n:::\n:::\n\n\n\nO código completo ficaria algo assim:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat |> \n  group_by(name_region) |> \n  summarise(\n    media_pib = mean(pib),\n    dp_pib = sd(pib),\n    media_pib_agriculture = mean(pib_agriculture),\n    dp_pib_agriculture = sd(pib_agriculture),\n    ...\n    media_pib_govmt_services = mean(pib_govmt_services),\n    dp_pib_govmt_services = sd(pib_govmt_services)\n    )\n```\n:::\n\n\n\nPodemos simplificar consideravelmente este processo usando a função `across` junto com a `summarise` de maneira similar como fizemos no caso da função `mutate`. A função `across` aplica uma lista de funções sobre uma seleção de colunas. Pode-se usar os `tidyselectors` (`starts_with()`, `contains()`, etc.) para facilitar a seleção das colunas.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacross(.cols = colunas, .fns = list(\"funcao_1\" = f1(), \"funcao_2\" = f2()))\n```\n:::\n\n\n\nNão é necessário prover nomes para cada uma das funções, mas, em geral, isto facilita a interpretação do output, já que o nome da coluna resultante vai ser a concatenação do seu nome original com o nome da função.\n\nNo caso abaixo, aproveito que as colunas estão em sequência e uso o operador `:`, que seleciona todas as colunas de `pib` até `pib_govmt_services`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Passando os argumentos implicitamente e usando uma lista sem nomes\ndat |> \n  group_by(name_region) |> \n  summarise(across(pib:pib_govmt_services, list(mean, sd)))\n\n# Passando os argumentos implicitamente e usando uma lista com nomes\ndat |> \n  group_by(name_region) |> \n  summarise(across(pib:pib_govmt_services, list(\"media\" = mean, \"dp\" = sd)))\n\n# Passando todos argumentos explicitamente e usando uma lista com nomes\ndat |> \n  group_by(name_region) |> \n  summarise(\n    across(\n      .cols = pib:pib_govmt_services,\n      .fns = list(\"media\" = mean, \"dp\" = sd)\n      )\n    )\n```\n:::\n\n\n\nTambém é possível prover a lista de funções separadamente, o que facilita a padronização do código.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_funs <- list(\n  \"media\" = mean,\n  \"mediana\" = median,\n  \"dp\" = sd,\n  \"maximo\" = max,\n  \"minimo\" = min\n  )\n\ndat |> \n  group_by(name_region) |> \n  summarise(across(pib:pib_govmt_services, my_funs)) |> \n  select(1:6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 6\n  name_region  pib_media pib_mediana    pib_dp pib_maximo pib_minimo\n  <chr>            <dbl>       <dbl>     <dbl>      <dbl>      <dbl>\n1 Centro Oeste  1694327.     329354  12731156.  265847334      22362\n2 Nordeste       601634.     148790.  2982154.   65160893      16741\n3 Norte         1062607.     241006   5225813.   91768773      23767\n4 Sudeste       2369721.     253226. 20833601.  748759007      21055\n5 Sul           1098361.     255999   4290229.   88308728      35773\n```\n\n\n:::\n:::\n\n\n\nComo vimos nos exemplos acima, o nome da coluna, da tabela final, combina o *nome original da coluna* com a *função aplicada*, seguindo a lógica 'nome_coluna_nome_funcao'. Por isto que as colunas acima são \"pib_media\", \"pib_mediana\", etc. O argumento `.names` da função `across` permite maior controle sobre o nome final da coluna.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Modificando os nomes da tabela final\ndat |> \n  group_by(name_region) |> \n  summarise(across(starts_with(\"pib\"), mean, .names = \"media_{.col}\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 9\n  name_region media_pib media_pib_share_uf media_pib_taxes media_pib_added_value\n  <chr>           <dbl>              <dbl>           <dbl>                 <dbl>\n1 Centro Oes…  1694327.              0.857         174584.              1519743.\n2 Nordeste      601634.              0.502          72937.               528697.\n3 Norte        1062607.              1.56          115597.               947009.\n4 Sudeste      2369721.              0.240         340390.              2029331.\n5 Sul          1098361.              0.252         153225.               945135.\n# ℹ 4 more variables: media_pib_agriculture <dbl>, media_pib_industrial <dbl>,\n#   media_pib_services <dbl>, media_pib_govmt_services <dbl>\n```\n\n\n:::\n\n```{.r .cell-code}\n# Comportamento padrão do argumento .names\ndat |> \n  group_by(name_region) |> \n  summarise(across(starts_with(\"pib\"), mean, .names = \"{.col}_{.fn}\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 9\n  name_region     pib_1 pib_share_uf_1 pib_taxes_1 pib_added_value_1\n  <chr>           <dbl>          <dbl>       <dbl>             <dbl>\n1 Centro Oeste 1694327.          0.857     174584.          1519743.\n2 Nordeste      601634.          0.502      72937.           528697.\n3 Norte        1062607.          1.56      115597.           947009.\n4 Sudeste      2369721.          0.240     340390.          2029331.\n5 Sul          1098361.          0.252     153225.           945135.\n# ℹ 4 more variables: pib_agriculture_1 <dbl>, pib_industrial_1 <dbl>,\n#   pib_services_1 <dbl>, pib_govmt_services_1 <dbl>\n```\n\n\n:::\n:::\n\n\n\nUma aplicação bastante útil desta sintaxe é verificar o número de observações ausentes (`NA`) contidas nos dados. O código abaixo mostra duas maneiras alternativas de chegar neste resultado. A primeira usa a sintaxe padrão do R para criar uma função anônima `\\(x)`. A segunda forma é exclusiva do `tidyverse`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat |> \n  summarise(everything(), \\(x) sum(is.na(x)))\n\ndat |> \n  summarise(everything(), ~sum(is.na(.x)))\n```\n:::\n\n\n\n## Flexibilidade e escala\n\nA função `summarise` pode ser usada dentro de uma outra função para retornar certos valores tabelados. No exemplo abaixo, mostro como construir uma função que calcula diversas medidas estatísticas de uma variável segundo algum grupo. Neste caso, temos diversas medidas do PIB por grande região.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresumir_dados <- function(dat, grupo, variavel) {\n  dat |> \n    group_by({{ grupo }}) |> \n    summarise(\n      minimo = min({{ variavel }}),\n      maximo = max({{ variavel }}),\n      media = mean({{ variavel }}),\n      dp = sd({{ variavel }}),\n      q25 = quantile({{ variavel }}, probs = .25),\n      q75 = quantile({{ variavel }}, probs = .75)\n    )\n}\n\nresumir_dados(dat, name_region, pib)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 7\n  name_region  minimo    maximo    media        dp     q25     q75\n  <chr>         <dbl>     <dbl>    <dbl>     <dbl>   <dbl>   <dbl>\n1 Centro Oeste  22362 265847334 1694327. 12731156. 124492  934357 \n2 Nordeste      16741  65160893  601634.  2982154.  75174. 323185 \n3 Norte         23767  91768773 1062607.  5225813. 128958. 530757.\n4 Sudeste       21055 748759007 2369721. 20833601.  98169. 870045.\n5 Sul           35773  88308728 1098361.  4290229. 124756  705609 \n```\n\n\n:::\n:::\n\n\n\nEsta nova função também pode ser aplicada dentro de um pipeline.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat |> \n  filter(name_region == \"Nordeste\") |> \n  resumir_dados(name_state, population)\n```\n:::\n\n\n\nPodemos aproveitar o argumento `.by` para fazer uma versão mais flexível da função acima.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresumir_dados_2 <- function(dat, grupos, variavel) {\n  dat |> \n    summarise(\n      minimo = min({{ variavel }}),\n      maximo = max({{ variavel }}),\n      media = mean({{ variavel }}),\n      dp = sd({{ variavel }}),\n      q25 = quantile({{ variavel }}, probs = .25),\n      q75 = quantile({{ variavel }}, probs = .75),\n      .by = grupos\n    )\n}\n\nresumir_dados_2(dat, c(\"code_region\", \"name_region\"), pib)\n```\n:::\n\n\n\nPor fim, podemos montar uma função ainda mais flexível que aceita o nome das colunas como texto.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nestat_descritivas <- list(\n  \"media\" = mean,\n  \"desvio_padrão\" = sd,\n  \"Q_25\" = \\(z) quantile(z, probs = 0.25)\n)\n\nresumir_dados_3 <- function(dat, grupos, variaveis) {\n  \n  dat |> \n    summarise(across(all_of(variaveis), estat_descritivas), .by = grupos)\n  \n}\n\nresumir_dados_3(dat, c(\"code_region\", \"name_region\"), c(\"pib\", \"population\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 8\n  code_region name_region  pib_media pib_desvio_padrão pib_Q_25 population_media\n        <dbl> <chr>            <dbl>             <dbl>    <dbl>            <dbl>\n1           1 Norte         1062607.          5225813.  128958.           38555.\n2           2 Nordeste       601634.          2982154.   75174.           30460.\n3           3 Sudeste       2369721.         20833601.   98169.           50868.\n4           4 Sul           1098361.          4290229.  124756            25133.\n5           5 Centro Oeste  1694327.         12731156.  124492            34878.\n# ℹ 2 more variables: population_desvio_padrão <dbl>, population_Q_25 <dbl>\n```\n\n\n:::\n:::\n\n\n\n## Funções úteis\n\nAbaixo segue uma lista de funções úteis.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl |> \n  summarise(\n    # Medidas de centro\n    # Média aritmética\n    media = mean(pib),\n    # Mediana\n    med = median(pib),\n    # Média geométrica\n    gmean = mean(log(exp(pib))),\n    # Média artimética ponderada\n    wmean = weighted.mean(pib, pop),\n    \n    # Medidas de dispersão\n    # Desvio-padrão\n    dp = sd(pib),\n    # Variância\n    var_pib = var(pib),\n    # IQR - intervalo interquartílico\n    iqr_pib = IQR(pib),\n    # Quantil/percentil\n    q25 = quantile(pib, .25),\n    # MAD - desvio absoluto mediano\n    mad_pib = mad(pib),\n    \n    # Extremos\n    \n    # Mínimo\n    min_pib = min(pib),\n    # Máximo\n    max_pib = max(pib),\n    \n    # Contagem de frequência/observações\n    # Número de observações\n    count_obs = n(),\n    # Número de observações únicas\n    unique_obs = n_distinct(),\n    \n    # Agregados\n    # Colapse vetores de textos em um único\n    states = paste(abbrev_state, collapse = \", \"),\n    # Colapsa \n    states = paste(unique(abbrev_state), collapse = \", \"),\n    # Soma simples\n    total = sum(pib),\n    # Produtório\n    total_prod = prod(1 + pib / 100)\n  )\n\n# Conta o número de observações ausentes (NAs) em todas as colunas\ntbl |> \n  summarise(across(everything(), \\(x) sum(is.na(x))))\n\n# Calcula o percentual de observações ausentes (NAs) em todas as colunas\ntbl |> \n  summarise(across(everything(), \\(x) sum(is.na(x)) / length(x) * 100))\n```\n:::\n\n\n\n## Resumindo\n\nEm resumo, a função `summarise` serve para agregar valores. Ela retorna uma única linha (por grupo) contendo estatísticas descritivas (e.g. média, desvio-padrão) sobre a base de dados. Ela é uma função útil para chegar em resultados finais, mostrar totais, médias, etc.\n\nNeste post vimos como:\n\n1.  Usar a função `summarise` em casos simples.\n\n2.  Usar a função `summarise` para aplicar funções sobre múltiplas colunas ao mesmo tempo, de maneira sistemática.\n\n3.  Como montar funções customizadas para aplicar diversas funções pré-selecionadas sobre bases de dados.\n\n# Outros posts da série\n\n-   [mutate](https://restateinsight.com/posts/general-posts/2024-01-tidyverse-mutate/)\n\n-   [filter](https://restateinsight.com/posts/general-posts/2024-01-tidyverse-filter/)\n\n-   [rename](https://restateinsight.com/posts/general-posts/2024-01-tidyverse-rename/)\n\n-   [select](https://restateinsight.com/posts/general-posts/2024-01-tidyverse-select/)\n\n## Veja também\n\n-   [Tidyselect](https://dplyr.tidyverse.org/reference/dplyr_tidy_select.html)\n\n-   [Tidyselect help](https://tidyselect.r-lib.org/reference/language.html)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}