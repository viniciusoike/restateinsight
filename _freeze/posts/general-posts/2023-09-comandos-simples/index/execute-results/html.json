{
  "hash": "b17e4c6783c2c0a9f433946fbfe98736",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'Importando arquivos, visualizando linhas'\ndate: '2023-10-19'\ncategories: ['tutorial-R', 'data-science']\ndescription: \"Toda análise de dados passa por tarefas de rotina: importar dados, trocar nomes de colunas, remover observações vazias, etc. Por que não facilitar a sua vida e tornar essas tarefas simples?\"\n---\n\n\n::: {.cell}\n\n:::\n\n\n# O problema\n\nUma das minhas maiores dificuldades quando comecei a mexer com `R` era conseguir importar a minha base de dados. Em geral, eu tinha um ou vários arquivos `.csv` ou planilhas `.xlsx` que precisavam ser importador para o `R`. Eu tinha três dificuldades\n\n1.  Saber qual a função que eu precisava usar.\n2.  Escrever o caminho até o arquivo específico (qualquer errinho e já não funcionava!).\n3.  Calibrar os argumentos na hora de importar.\n\nDepois de muito esforço eu conseguia importar os dados, mas logo surgia ourto problema: o nome das variáveis vinha num formato muito ruim para trabalhar. No `R`, idealmente as variáveis são todas:\n\n1.  Minúsculas\n2.  Não tem acento nem caracteres especiais como `$`, `%`, etc.\n3.  Não tem espaços\n4.  Não começa com números\n\nIsso evita inúmeros problemas e facilita muito na hora de escrever o código.\n\nPor fim, eu tinha bastante dificuldade de \"enxergar os dados\" mesmo depois de ter importado eles. No caso de uma planilha de Excel eu poderia simplesmente abrir ela e explorar um pouco. Já se a base de dados fosse em formato `dta` ou `sav` isso já não era tão simples, pois eu não tinha Stata e nem SPSS no meu computador.\n\nTudo isso me desanimava quando comecei a mexer com `R` e vejo que isso é um daqueles obstáculos idiotas que acabam segurando muita gente de fazer a transição para o `R`. É o tipo de problema (que parece) simples, mas que na verdade é difícil de resolver e que faz com que você se sinta burro e fique frustrado.\n\nNeste post vou te dar algumas dicas de como lidar com todos estes passos. É o post que eu gostaria de poder enviar para mim mesmo no passado.\n\n# A solução simples\n\nO roteiro de como melhorar a sua vida no `R`:\n\n1.  Importar usando `rio::import()`\n2.  Escrever paths relativos usando `here::here()`\n3.  Corrigir os nomes das colunas usando `janitor::clean_names()`\n4.  Visualizar usando `View()`, `dplyr::glimpse()`, `skimr::skim()` ou `show_in_excel()` (ver abaixo)\n5.  Exportar usando `rio::export()`\n\nAgora, vamos aos detalhes.\n\n# Importando arquivos\n\nLembrando os problemas de importar arquivos:\n\n1.  Saber qual a função usar.\n2.  Escrever o caminho até o arquivo específico (qualquer errinho dá erro!).\n3.  Calibrar os argumentos na hora de importar.\n4.  Às vezes é preciso importar vários arquivos de uma mesma pasta e juntá-los todos num único objeto.\n\nEste problema era tão chato de se resolver que eu acabava dependendo de uma facilidade do RStudio, que ajuda a importar uma base de dados, o botão Import Dataset. Eu fazia os comandos clicando e depois copiava o comando que aparecia no console no meu código.\n\nIsto não era uma solução prática e eu queria a solução \"correta\": queria escrever o código certo para importar os dados.\n\nA solução para os problemas acima:\n\n1.  Aprender todas as funções para importar arquivos (leva tempo...)\n2.  Escrever *paths* relativos e usar a tecla `tab` dentro do RStudio (funciona com autocomplete!)\n3.  Aprender todas os argumentos das funções para importar arquivos (mais tempo ainda...).\n4.  Ver abaixo\n\nAinda que no longo prazo acho que seja importante saber todas as funções, o propósito aqui é te ajudar um pouco então vamos com duas soluções.\n\n## A solução correta\n\nA tabela abaixo resume as principais funções que você provavelmente vai ter que usar.\n\n|  Formato   |            Extensao            |             Importar             |             Exportar              |\n|:--------------:|:---------------------:|:---------------:|:---------------:|\n|   Excel    |         `xls`, `xlsx`          |      `readxl::read_excel()`      |       `xlsx::write.xlsx()`        |\n| Separados  |  `csv`, `tsv`, `psv`, `csvy`   | `data.table::fread()` ou `readr` | `data.table::fwrite()` ou `readr` |\n|   Stata    |             `dta`              |       `haven::read_dta()`        |       `haven::write_dta()`        |\n|    SPSS    |             `sav`              |       `haven::read_sav()`        |       `haven::write_sav()`        |\n| Shapefiles | `shp`, `geosjon`, `gpkg`, etc. |         `sf::st_read()`          |         `sf::st_write()`          |\n\nOBS: Caso não esteja familiarizado com esta sintaxe, aqui `readxl` é o nome do pacote, `read_excel()` é a funcão e o `::` indica que eu quero a função `read_excel` do pacote `readxl`. Em geral, é comum omitir a parte do `nomepacote::` porque acaba sendo desnecessário (exceto no caso de conflitos de funções que têm o mesmo nome).\n\n### Sobre csvs\n\nVale uma nota: existem várias alternativas para importar arquivos `csv`, várias alternativas mesmo. Eu recomendo evitar as funções base e usar as funções equivalentes do `readr`. Então, por exemplo, ao invés de usar `read.csv` use `readr::read_csv`. Esta é uma boa decisão por três motivos:\n\n1.  As funções do `readr` são consideravelmente mais rápidas e versáteis do que as funções base equivalentes.\n2.  As funções `read_*` compartilham uma sintaxe padronizada e costumam ter argumentos muito similares. Assim as funções do `readr` são muito parecidas com as funções do pacote `readxl` e `haven`. O combo `readr` + `readxl` + `haven` resolve o problema em 95% dos casos.\n3.  Todos estes pacotes e funções já estão bem integrados ao universo tidyverse[^1].\n\n[^1]: Para saber mais sobre o tidyverse consulte o meu [post sobre A Filosofia do Tidyverse](https://restateinsight.com/posts/general-posts/2023-09-tidyverse/).\n\nSe velocidade começar a ser um problema, pode-se experimentar também com o pacote `vroom` que permite importar arquivos `csv` mais rapidamente. A função `vroom::vroom` também compartilha da sintaxe das funções `read_*`.\n\nUm típico problema com arquivos `csv` é que os delimitadores e separadores variam de país para país. Arquivos `csv` de fontes brasileiras costumam ser separadas por `;` e usam a `,` como quebra de decimal, ao contrário dos `csv` de fontes dos EUA que usam a `,` como separador e `.` como quebra de decimal. Os arquivos no padrão EUA devem ser lidos com `read_csv` enquanto os arquivos no padrão brasileiro devem ser lidos com `read_csv2`[^2].\n\n[^2]: Alternativamente, pode-se usar a função `read_delim`, que é mais geral e permite especificar quais símbolos são usados como delimitador e separador de números.\n\nApesar de todas as vantagens listadas acima, ainda vale recomendar o `data.table::fread()`[^3] na hora de importar qualquer arquivo \"separado\" (`csv`, `tsv`, `psv`, etc.). Esta função é extremamente rápida, aloca os dados na memória de maneira eficiente e simplesmente funciona. Mesmo sem nenhum argumento adicional ela é muito boa na hora de adivinhar o tipo de separador utilizado e o tipo de dado em cada coluna.\n\n[^3]: Disclaimer importante: depois de revisar este texto eu já não recomendo tão fortemente o `data.table::fread` por um movito bobo e simples. Atualmente, o `data.table` tem uma classe própria para datas chamada `IDate`. Esta classe é útil se você pretende fazer todas as suas análises usando as funções do `data.table` como `shift`, `hour`, etc. Contudo, se você pretende usar outros pacotes comuns de séries de tempo será necessário converter para `Date` todas as vezes. Além disso, como eu já estou bastante habituado a usar o pacote `lubridate` para manipular datas, não vejo muita vantagem em utilizar as funções do `data.table`.\n\nPor fim, apesar de ter recomendado o `data.table::fwrite` na tabela acima, vale notar que funções como `readr::write_excel_csv2()` podem ser muito úteis caso seu objetivo seja exportar um csv que vai ser consumido por um usuário brasileiro numa planilha de Excel.\n\n### Mais controle\n\nA prática faz a perfeição na hora de importar arquivos problemáticos. Como comentei acima, uma das vantagens de se ater ao combo `readr` + `readxl` + `haven` é que os argumentos adicionais destas funções seguem o mesmo padrão.\n\n-   `skip = k`: Pula as primeiras k linhas.\n\n-   `na`: Define quais valores devem ser interpretados como valores ausentes.\n\n-   `col_types`: Permite que se declare explicitamente qual o tipo de dado (numérico, data, texto) que está armazenado em cada coluna.\n\n-   `col_names` ou `name_repair`: O primeiro permite que se declare explicitamente o nome que cada coluna vai ter dentro do `R` enquanto o segundo permite que se use uma função que renomeia as colunas.\n\n-   `locale`: Permite selecionar diferentes tipos de padrão de local. Em geral, usa-se `locale = locale(\"pt\")`.\n\n-   `range`: Este argumento só vale no caso de planilhas de Excel e permite que se importe uma seleção específica da planilha (e.g. \"D4:H115\")\n\nO código abaixo mostra como importar um csv bastante sujo. Veremos detalhes sobre a função `janitor::clean_names` mais adiante.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Input de um csv sujo\ndados <-\n  'Data; Valor (R$/m2)\n\"01-maio-2020\";22,3\n\"01-junho-2020\";21,5\n\"06-julho-2021\";X\n\"07-novembro-2022\";22'\n\n#> Lendo o arquivo\ndf <- read_delim(\n  #> Substitua esta linha pelo 'path' até o csv\n  I(dados),\n  delim = \";\",\n  #> Usa , como separador decimal; lê meses em português (e.g. maio, junho, etc.)\n  locale = locale(\n    decimal_mark = \",\",\n    date_names = \"pt\",\n    date_format = \"%d-%B-%Y\"\n  ),\n  #> Interpreta X como valores ausentes (NA)\n  na = \"X\",\n  #> Renomeia as colunas\n  name_repair = janitor::clean_names\n)\n```\n:::\n\n\n## Importando arquivos: o atalho\n\nUma função muito prática que inicialmente contorna todos estes problemas é a `rio::import()`.\n\nA função `rio::import()` simplesmente importa seus dados e funciona com boa parte das extensões mais populares. Na prática, ela é uma função \"facilitadora\". Por baixo dos panos, ela está chamando a função correta para o caso específico.\n\n[Este site](https://cran.r-project.org/web/packages/rio/vignettes/rio.html) mostra exatamente qual função de qual pacote ele utiliza para importar os dados. A lista é bem completa e inclui bases do Minitab, Matlab, EViews, etc. Spoiler: `data.table::fread()` é utilizada para importar arquivos `csv`, `psv` e `tsv`.\n\nO par da função `rio::import` é a `rio::export` e serve justamente para exportar bases de dados do `R` para o formato desejado.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- rio::import(\"data/meus_dados.dta\")\n\nrio::export(mtcars, \"data/mtcars.csv\")\n```\n:::\n\n\nO único problema desta função é quando seus arquivos não estão num formato muito bacana e argumentos adicionais são necessários. É possível fornecer estes argumentos à função, mas é difícil saber quais são os argumentos, já que não se sabe qual função está sendo chamada. Assim, é preciso consultar a documentação (`?rio::import)` para verificar qual função está sendo utilizada e aí consultar a documentação desta função.\n\n## Escrevendo paths relativos com here\n\nUm problema bem sério que eu enfrentava nos meus códigos era escrever o path até os arquivos externos. Primeiro, eu achava muito trabalhoso escrever ele inteiro. Depois, quando eu mandava meu código para outra pessoa, ou quando eu mesmo ia executar o meu código em outro computador, nada funcionava!\n\nO primeiro passo para lidar com isso é trabalhar com projetos do RStudio[^4]. O melhor workflow é sempre começar seu trabalho num projeto novo e deixar todos os arquivos necessários neste mesmo diretório em pastas com nomes simples como `data`, `report`, `graphics`, etc.\n\n[^4]: Evidentemente, projetos não são exclusivos ao RStudio; também é possível trabalhar com um workflow de projeto com VSCode, por exemplo. Para usuários que usam majoritariamente o R, contudo, o RStudio facilita muito a vida.\n\nO segundo passo é utilizar *paths relativos*. Paths relativos, ao contrário de paths absolutos, começam no seu diretório da seguinte forma: `\"data/subpasta/meus_dados.xlsx\"`. A pasta `data` está dentro da pasta do projeto: isto é indicado implicitamente.\n\nÉ bem diferente de um path absoluto: `/Users/nome_do_usuario/Documentos/meus_projetos/Projeto 1/data/subpasta/meus_dados.xlsx`.\n\nUsar paths absolutos no seu código é garantir que a **única pessoa que conseguirá reproduzir ele com sucesso será você**, e unicamente no computador em que você escreveu ele (isso se você não formatar ele!).\n\nAqui entra o pacote `here`, um pacotinho muito simples, centrado em uma única função homônima. A função `here` funciona de duas maneiras bastante simples\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(here)\nlibrary(haven)\n\nmeus_dados <- read_dta(here(\"data/subpasta/minha_base.dta\"))\nmeus_dados <- read_dta(here(\"data\", \"subpasta\", \"minha_base.dta\"))\n```\n:::\n\n\nA segunda forma de sintaxe é muito útil na hora de criar paths. Isto será muito conveniente depois, quando formos importar vários arquivos de uma mesma pasta.\n\nA seguinte ilustração que serve de capa do projeto do `here` resume muito bem a sua utilidade.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](../../../static/images/here.png){width=1386}\n:::\n:::\n\n\nExiste um mal hábito dissemeniado de incluir uma linha com `setwd(\"insira_seu_diretorio\")` no início de todo código. Eu garanto que todo tipo de problema imaginável e inimaginável acontece com pessoas que fazem isso.\n\nO `here` simplesmente funciona e funciona com tudo. Ele é especialmente útil na hora de escrever scripts em RMarkdown e Quarto. O pacote `here` é talvez o único que esteja presente em todos os meus projetos e em todos os meus códigos.\n\nOutra dica boa para manter seus projetos organizados é de evitar colocar espaços ou caracteres especiais no nome das suas pastas. Em geral, o `R` consegue lidar bem com isso, mas volta e meia este mau hábito pode gerar problemas desnecessários e inesperados.\n\n## Importando todos os arquivos de uma pasta\n\nEste é um problema bastante recorrente e que é fácil de resolver usando `here` e funções base.\n\nImagine que você tem vários arquivos `.csv` numa pasta e os arquivos estão na seguinte estrutura: `Dados/inflacao/2012/` e aí cada `csv` individual é um arquivo mensal (com nomes potencialmente fora de padrão) com os dados de inflação mensal por produto. Algo como `2012_jan.csv`, `2012fevereiro.csv`, etc.\n\nA estrutura do código para importar tudo isso no `R` é bastante simples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(here)\n# Define o diretório\ndir <- here(\"Dados/inflacao/2012\")\n# Encontra o nome de todos os arquivos com extensão csv nesta pasta\nfilenames <- list.files(dir, pattern = \"\\\\.csv$\")\n# Define o path até cada um dos arquivos\npathfiles <- here(dir, filenames)\n# Importa todos os csv usando fread\ndata <- lapply(pathfiles, data.table::fread)\n\n# Opcionalmente, empilha todos os resultados e cria uma coluna que identifica\n# de qual o arquivo a observação pertence\nnames(data) <- basename(pathfiles)\nempilhado <- data.table::rbindlist(data, idcol = \"nome_arquivo\")\n```\n:::\n\n\nUma maneira ainda mais sucinta de escrever o código seria omitindo os objetos intermediários e simplesmente empilhando o resultado final. Note que, para que as bases de dados sejam empilhadas é necessário que o nome e o tipo das colunas seja compatível. Isto pode ser melhor controlado declarando o tipo das colunas na função `fread`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define o path até cada um dos arquivos\npathfiles <- list.files(\n  here(\"Dados/inflacao/2012\"),\n  pattern = \"\\\\.csv$\",\n  full.names = TRUE\n)\n# Importa todos os csv usando fread\nfiles <- lapply(pathfiles, data.table::fread)\n# Empilha todos os resultados\ndat <- data.table::rbindlist(files)\n```\n:::\n\n\n# Corrigindo nomes de variáveis\n\nO nome das colunas da nossa base de dados é muito importante, pois no `R` acabamos usando elas com muita frequência. Tanto para quem usa `data.table` como para os adeptos do `tidyverse`, o nome das colunas, na prática, acaba sendo usando como um objeto dentro das funções, então é importante que esse nome seja fácil de digitar.\n\nLembrando que, idealmente, os nomes das colunas e também dos objetos que criamos devem ser:\n\n1.  Minúsculos\n2.  Sem acento e nem caracteres especiais como `$`, `%`, etc.\n3.  Sem espaços\n4.  Sem números no começo\n\nOutro ponto, um pouco óbvio, é que há nomes que devemos evitar na hora de nomear nossas colunas como: `FALSE`, `if`, `TRUE`, `for`, `Inf`, etc[^5].\n\n[^5]: Estas palavras são \"nomes reservados\" dentro do `R` e jamais devem ser utilizados na hora de definir um objeto ou o nome de uma coluna. Para consultar a lista de nomes reservados, veja `help(\"Reserved\")`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Bons nomes\nnm <- c(\"inflacao\", \"pib\", \"cambio\")\nnm <- c(\"inflacao_percentual\", \"pib_reais_correntes\", \"cambio_mensal\")\n\n# Nomes ruins\nnmRuIm <- c(\"Inflação (%)\", \"Produto Interno Bruto (R$)\", \"Câmbio (Mensal)\")\nnmRuIm <- c(\"INFLAÇÃO\", \"PIB\", \"CÂMBIO (MÊS)\")\n```\n:::\n\n\nA função `janitor::clean_names()` segue os princípios elencados acima e pode ser aplicada diretamente num `data.frame`. O resultado é uma base com nomes \"limpos\". Considere o exemplo abaixo de um arquivo csv com nomes muito ruins.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncsv <- \"\nAnoMesDia;Inflação (%);Produto Interno Bruto;DESEMPREGO\n2023-01-01;0.055;0.75;0.1132\n2023-04-01;0.045;0.50;0.1051\n2023-07-01;0.065;0.68;0.1000\n2023-10-01;0.050;1.12;0.9512\n\"\n\ndata <- data.table::fread(I(csv))\nhead(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    AnoMesDia Inflação (%) Produto Interno Bruto DESEMPREGO\n       <IDat>        <num>                 <num>      <num>\n1: 2023-01-01        0.055                  0.75     0.1132\n2: 2023-04-01        0.045                  0.50     0.1051\n3: 2023-07-01        0.065                  0.68     0.1000\n4: 2023-10-01        0.050                  1.12     0.9512\n```\n\n\n:::\n:::\n\n\nNote que selecionar uma coluna se torna bem inconveniente e somos forçados a cercar o nome com esse *apostrophe*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata$`Inflação (%)`\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.055 0.045 0.065 0.050\n```\n\n\n:::\n:::\n\n\nNormalmente, seria necessário usar uma série de funções para, primeiro remover os acentos, depois tirar os parêntesis, depois converter os caracteres para minúsculos e aí substituir os espaços por subscrito.\n\nA função `janitor::clean_names` faz tudo isso numa única linha de código. Além disso, como o argumento da função é um `data.frame`, ela pode ser usada diretamente no início do seu pipe\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclean_data <- janitor::clean_names(data)\nhead(clean_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   ano_mes_dia inflacao_percent produto_interno_bruto desemprego\n        <IDat>            <num>                 <num>      <num>\n1:  2023-01-01            0.055                  0.75     0.1132\n2:  2023-04-01            0.045                  0.50     0.1051\n3:  2023-07-01            0.065                  0.68     0.1000\n4:  2023-10-01            0.050                  1.12     0.9512\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\ndata |>\n  janitor::clean_names() |>\n  filter(inflacao_percent < 0.06)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   ano_mes_dia inflacao_percent produto_interno_bruto desemprego\n        <IDat>            <num>                 <num>      <num>\n1:  2023-01-01            0.055                  0.75     0.1132\n2:  2023-04-01            0.045                  0.50     0.1051\n3:  2023-10-01            0.050                  1.12     0.9512\n```\n\n\n:::\n:::\n\n\n# Enxergando os dados\n\nPor fim, vamos discutir rapidamente algumas formas de rapidamente olhar seus dados. Aqui, temos várias opções. A maneira mais simples seria usar a função `head()` que mostra as primeiras dez linhas da base de dados. Se a base não for muito grande, podemos usar a função `View()`. Quando usada dentro do RStudio funciona quase como um Excel, permite enxergar todas as linhas, ordenar por colunas, etc.\n\nHá pacotes que oferecem soluções simples para enxergar rapidamente uma base de dados. Da mais simples para a mais complexa, temos: `dplyr::glimpse()`, `summarytools::descr()` e `skmir::skim()`\n\nAbaixo mostro a saída dessas três funções na base de dados `iris`. A primeira saída é bastante simples, mostra a dimensão da base (número de linhas e colunas), o nome e o tipo das colunas, e as primeiras linhas de cada coluna.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::glimpse(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 150\nColumns: 5\n$ Sepal.Length <dbl> 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.…\n$ Sepal.Width  <dbl> 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.…\n$ Petal.Length <dbl> 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.…\n$ Petal.Width  <dbl> 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.…\n$ Species      <fct> setosa, setosa, setosa, setosa, setosa, setosa, setosa, s…\n```\n\n\n:::\n:::\n\n\nA função `summarytools::descr` traz várias estatísticas descritivas (ignorando colunas não-numéricas). Cada um destes valores traz bastante informação, mas sua interpretação depende também de conhecimento técnico. Essencialmente, a saída traz algumas medidas de \"tendência central\" (média, mediana), dispersão (desvio padrão, MAD, IQR), assimetria e curtose. As últimas duas linhas também informam sobre a presença de observações ausentes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarytools::descr(iris)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNon-numerical variable(s) ignored: Species\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDescriptive Statistics  \niris  \nN: 150  \n\n                    Petal.Length   Petal.Width   Sepal.Length   Sepal.Width\n----------------- -------------- ------------- -------------- -------------\n             Mean           3.76          1.20           5.84          3.06\n          Std.Dev           1.77          0.76           0.83          0.44\n              Min           1.00          0.10           4.30          2.00\n               Q1           1.60          0.30           5.10          2.80\n           Median           4.35          1.30           5.80          3.00\n               Q3           5.10          1.80           6.40          3.30\n              Max           6.90          2.50           7.90          4.40\n              MAD           1.85          1.04           1.04          0.44\n              IQR           3.50          1.50           1.30          0.50\n               CV           0.47          0.64           0.14          0.14\n         Skewness          -0.27         -0.10           0.31          0.31\n      SE.Skewness           0.20          0.20           0.20          0.20\n         Kurtosis          -1.42         -1.36          -0.61          0.14\n          N.Valid         150.00        150.00         150.00        150.00\n                N         150.00        150.00         150.00        150.00\n        Pct.Valid         100.00        100.00         100.00        100.00\n```\n\n\n:::\n:::\n\n\nPor fim, a saída da função `skimr::skim` é a mais completa e inclui até mini gráficos de histogramas das variáveis numéricas. Vale notar que, diferentemente da `descr` acima, esta função traz informações também sobre as colunas não numéricas\n\n\n::: {.cell}\n\n```{.r .cell-code}\nskimr::skim(iris)\n```\n\n::: {.cell-output-display}\n\nTable: Data summary\n\n|                         |     |\n|:------------------------|:----|\n|Name                     |iris |\n|Number of rows           |150  |\n|Number of columns        |5    |\n|_______________________  |     |\n|Column type frequency:   |     |\n|factor                   |1    |\n|numeric                  |4    |\n|________________________ |     |\n|Group variables          |None |\n\n\n**Variable type: factor**\n\n|skim_variable | n_missing| complete_rate|ordered | n_unique|top_counts                |\n|:-------------|---------:|-------------:|:-------|--------:|:-------------------------|\n|Species       |         0|             1|FALSE   |        3|set: 50, ver: 50, vir: 50 |\n\n\n**Variable type: numeric**\n\n|skim_variable | n_missing| complete_rate| mean|   sd|  p0| p25|  p50| p75| p100|hist  |\n|:-------------|---------:|-------------:|----:|----:|---:|---:|----:|---:|----:|:-----|\n|Sepal.Length  |         0|             1| 5.84| 0.83| 4.3| 5.1| 5.80| 6.4|  7.9|▆▇▇▅▂ |\n|Sepal.Width   |         0|             1| 3.06| 0.44| 2.0| 2.8| 3.00| 3.3|  4.4|▁▆▇▂▁ |\n|Petal.Length  |         0|             1| 3.76| 1.77| 1.0| 1.6| 4.35| 5.1|  6.9|▇▁▆▇▂ |\n|Petal.Width   |         0|             1| 1.20| 0.76| 0.1| 0.3| 1.30| 1.8|  2.5|▇▁▇▅▃ |\n\n\n:::\n:::\n\n\n## Olhando seus dados no Excel\n\nPor fim, vou deixar uma função customizada bem divertida, que permite você rapidamente dar uma espiada nos seus dados no bom e velho Excel. A função abaixo cria um arquivo temporário a partir da sua base de dados no `R` e abre isso no Excel.\n\nEvidentemente, é preciso ter o Excel instalado para que o código funcione.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshow_in_excel <- function(.data) {\n  if (interactive()) {\n    tmp <- paste0(tempfile(), \".xlsx\")\n    writexl::write_xlsx(.data, tmp)\n    browseURL(tmp)\n  }\n  .data\n}\n\nshow_in_excel(mtcars)\n```\n:::\n\n\nA figura abaixo mostra o resultado do código\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](../../../static/images/excel.png){fig-align='center' width=402}\n:::\n:::\n\n\nNovamente, como a função aceita um `data.frame` como argumento é bem fácil de colocá-la no final de um pipe. Esta função é bastante útil quando você precisa rapidamente compartilhar algum resultado ou tabela com alguém.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |>\n  filter(cyl > 2) |>\n  group_by(cyl) |>\n  summarise(peso_medio = mean(wt)) |>\n  show_in_excel()\n```\n:::\n\n\n# Resumo\n\nConcluindo, toda boa análise de dados passa por tarefas de rotina: importar dados, trocar nomes de colunas, remover observações vazias, etc. Por que não facilitar a sua vida e tornar essas tarefas simples?\n\nPessoalmente, quase todo código que escrevo utiliza `here` e `janitor::clean_names()`. Depois de muito sofirmento, aprendi quase todas as funções de importar e exportar, e só depois disso descobri o `rio::import` que teria me poupado muito estresse. Como comentei acima o `rio::import` é um atalho simples, mas no longo prazo vale a pena aprender com calma todas as funções `read_*`.\n\nUso com frequência o `View()` no final de um pipe para checar se as coisas estão indo da maneira esperada. E também comecei a criar o hábito de começar a minha exploração de dados com o `skim()`.\n\nNo fim, este post mostra como organizar seus arquivos, como importar seus dados e como \"dar uma checada\" para ver se está tudo certo: nomes e tipos de colunas; e também como fazer ajustes rápidos nos dados.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}