{
  "hash": "c85cfa517f1cb1ca81d22622c55d9572",
  "result": {
    "markdown": "---\ntitle: \"Replicating the Github Contributions plot in R using ggplot2\"\ndate: \"2024-12-03\"\ncategories: ['data-science', 'tutorial-R', 'data-visualization']\ndescription: \"In this post I'll show how to replicate the infamous GitHub contributions graphic using ggplot2\"\nexecute: \n  warning: false\n---\n\n\nIn this post I'll show how to replicate the infamous GitHub contributions graphic. This visualization shows all the days of the year and highlights the most \"productive\" days in darker colors. It's similar to a heat map and also known as a cluster map. You can check other examples of this plot in my [tutorial post](https://restateinsight.com/posts/ggplot2-tutorial/11-grafico-calor#gr√°fico-de-calor) (in Portuguese). In a way, it's also fairly similar to a \"punchcard\" plot.\n\n![](/static/images/github_contributions.png){fig-align=\"center\"}\n\n# Replicating the plot\n\n## Libraries\n\nI use basic tidyverse libraries to replicate the plot. The `import::from` is a neat way to get only some functions from a large package. This is not strictly necessary but is a good coding practice. Since I use many functions from the `ggplot2` and `lubridate` packages, I import them fully.\n\nFor this tutorial I'm using `ggplot2_3.5.1`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(lubridate)\n\nimport::from(dplyr, mutate, if_else, summarise)\nimport::from(tidyr, expand_grid)\nimport::from(forcats, fct_rev)\nimport::from(RQuantLib, isBusinessDay)\n```\n:::\n\n\nAn important feature of the original plot is that each square has round borders. Unfortunately, drawing these type of squares isn't very straightforward with `ggplot2`. To solve this, I draw from a solution posted on [StackOverflow](https://stackoverflow.com/questions/64355877/round-corners-in-ggplots-geom-tile-possible), which copies part of the code from the [`statebins`](https://github.com/hrbrmstr/statebins) package to make a `geom_rtile` function.\n\nWhile the code may seem daunting, using it is very simple.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n`%||%` <- function(a, b) {\n  if(is.null(a)) b else a\n}\n\nGeomRtile <- ggplot2::ggproto(\n  \"GeomRtile\", \n  statebins:::GeomRrect, # 1) only change compared to ggplot2:::GeomTile\n                     \n  extra_params = c(\"na.rm\"),\n  setup_data = function(data, params) {\n    data$width <- data$width %||% params$width %||% resolution(data$x, FALSE)\n    data$height <- data$height %||% params$height %||% resolution(data$y, FALSE)\n\n    transform(data,\n      xmin = x - width / 2,  xmax = x + width / 2,  width = NULL,\n      ymin = y - height / 2, ymax = y + height / 2, height = NULL\n    )\n  },\n  default_aes = ggplot2::aes(\n    fill = \"grey20\", colour = NA, size = 0.1, linetype = 1,\n    alpha = NA, width = NA, height = NA\n  ),\n  required_aes = c(\"x\", \"y\"),\n\n  # These aes columns are created by setup_data(). They need to be listed here so\n  # that GeomRect$handle_na() properly removes any bars that fall outside the defined\n  # limits, not just those for which x and y are outside the limits\n  non_missing_aes = c(\"xmin\", \"xmax\", \"ymin\", \"ymax\"),\n  draw_key = draw_key_polygon\n)\n\ngeom_rtile <- function(mapping = NULL, data = NULL,\n                       stat = \"identity\", position = \"identity\",\n                       radius = grid::unit(6, \"pt\"), # 2) add radius argument\n                       ...,\n                       na.rm = FALSE,\n                       show.legend = NA,\n                       inherit.aes = TRUE) {\n  ggplot2::layer(\n    data = data,\n    mapping = mapping,\n    stat = stat,\n    geom = GeomRtile,\n    position = position,\n    show.legend = show.legend,\n    inherit.aes = inherit.aes,\n    params = rlang::list2(\n      radius = radius,\n      na.rm = na.rm,\n      ...\n    )\n  )\n}\n```\n:::\n\n\n## Data\n\nFor the visualization, we need 365 observations indicating how many contributions were submitted each day of the year. To make the simulated data more realistic I'll account for holidays and weekends using the `RQuantLib` package.\n\nOn an average workday I assume the number of contributions follows a Poisson distribution with $\\lambda = 6.5$[^1]. This returns an average of around 4-8 contributions per day and guarantees that the number of contributions will be integer and non-negative. For weekdays or holidays I assumed a small chance (10%) that our worker will have to do some light work.\n\n[^1]: This number was a guess roughly based on my own history of contributions. The actual distribution might be more right-skewed than a Poisson, but for the purposes of this post it works fine.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tibble that contains all days of the year\ncontributions <- expand_grid(\n  date = seq(as.Date(\"2024-01-01\"), as.Date(\"2024-12-31\"), by = \"1 day\")\n)\n\n# Function to simulate number of contributions conditional on workday\nsample_contribution <- Vectorize(function(x) {\n  if (x == 1) {\n    # Normal day of work\n    rpois(1, 6.5)\n  } else {\n    # Small chance of working overtime on weekends or holidays\n    sample(c(0, 1, 2), 1, prob = c(0.9, 0.05, 0.05))\n  }}\n)\n\ncontributions <- contributions |> \n  mutate(\n    # Gets the number of the week in the year\n    n_week = week(date),\n    # Gets weekday number - Starts the week at sunday\n    n_day = wday(date, week_start = 7),\n    # Weekday labels for the plot\n    weekday_label = wday(date, week_start = 7, label = TRUE, abbr = TRUE),\n    weekday_label = fct_rev(weekday_label),\n    # Month labels for the plot\n    month = month(date, label = TRUE, abbr = TRUE),\n    is_workday = as.numeric(RQuantLib::isBusinessDay(\"Brazil\", date)),\n    # is_weekday = if_else(n_day == 7 | n_day == 1, 0L, 1L),\n    n = sample_contribution(is_workday)\n  )\n\ncontributions <- contributions |> \n  mutate(\n    n = if_else(n == 0, NA, n),\n    n_week = if_else(n_day == 1, n_week + 1, n_week)\n  )\n```\n:::\n\n\n## Plotting\n\n### Base plot\n\nThe basic version of this plot is essentially a cluster map. On the horizontal axis, the weeks of the year are plotted; on the vertical axis, the days of each year are plotted. The intensity of the color highlights the amount of GitHub contributions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(contributions, aes(n_week, n_day)) +\n  geom_rtile(\n    aes(fill = n),\n    color = \"white\",\n    radius = unit(2, \"pt\"),\n    width = 0.9,\n    height = 0.9\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n### Final plot\n\nTo arrive at a more polished version of this visualization I adjusted the scales and tweaked some minor thematic elements. To my surprise this was easier than I had anticipated.\n\n\n::: {.cell fig.asp='0.1775'}\n\n```{.r .cell-code}\n# Find the positions of the month labels\ntab <- contributions |> \n  summarise(nmin = min(n_week), .by = \"month\")\n\nggplot(contributions, aes(n_week, weekday_label)) +\n  geom_rtile(\n    aes(fill = n),\n    color = \"white\",\n    radius = unit(2, \"pt\"),\n    width = 0.9,\n    height = 0.9\n    ) +\n  # Highlight the months on the horizontal axis\n  scale_x_continuous(\n    breaks = tab$nmin,\n    labels = as.character(tab$month),\n    position = \"top\",\n    expand = c(0, 0)\n  ) +\n  # Highlight days of the week on the vertical axis\n  scale_y_discrete(breaks = c(\"Mon\", \"Wed\", \"Fri\")) +\n  # Adjust color palette\n  scale_fill_distiller(\n    palette = \"Greens\",\n    direction = 1,\n    na.value = \"gray90\") +\n  # Removes x and y labels\n  labs(x = NULL, y = NULL) +\n  # Removes the color legend\n  guides(fill = \"none\") +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    text = element_text(color = \"gray10\")\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=100%}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}