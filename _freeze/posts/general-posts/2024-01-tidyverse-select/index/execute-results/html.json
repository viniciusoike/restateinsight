{
  "hash": "445d6cc43fe9621f5d6510041c4043bf",
  "result": {
    "markdown": "---\ntitle: \"O novo tidyverse: select\"\ndate: \"2024-01-06\"\ncategories: ['data-science', 'tutorial-R', 'tidyverse']\ndescription: \"Neste post ensino abordagens diferentes para selecionar colunas de maneira eficiente. Apresento também as novidades que o `dplyr` trouxe nos últimos anos como as funções tidyselectors, que ajudam a selecionar colunas com base em padrões lógicos.\"\nimage: \"/static/images/dplyr_logo.png\" \nimage-alt: \"/static/images/dplyr_logo.png\"\nexecute: \n  eval: false\n  message: false\n  warning: false\n---\n\n\n\n\n# Tidyverse\n\nO tidyverse é uma coleção poderosa de pacotes, voltados para a manipulação e limpeza de dados. Num outro post, discuti alguns [aspectos gerais da filosofia](https://restateinsight.com/posts/general-posts/2023-09-tidyverse/) destes pacotes que incluem a sua consistência sintática e o uso de [pipes](https://restateinsight.com/posts/general-posts/2023-09-pipes-in-r/). A filosofia geral do tidyverse toma muito emprestado da gramática. As funções têm nomes de verbos que costumam ser intuitivos e são encadeados via \"pipes\" que funcionam como conectivos numa frase. Em tese, isto torna o código mais legível e até mais didático.\n\nO tidyverse está em constante expansão, novas funcionalidades são criadas para melhorar a performance e capabilidade de suas funções. Assim, é importante atualizar nosso conhecimento destes pacotes periodicamente. Nesta série de posts vou focar nas funções principais dos pacotes `dplyr` e `tidyr`, voltados para a limpeza de dados.\n\n# Alguns verbos\n\nEssencialmente, o `dplyr` gira em torno de quatro grandes funções: `filter`, `select`, `mutate` e `summarise`. Estas funções fazem o grosso do trabalho de limpeza de dados: filtram linhas, selecionam colunas e transformam os dados. A tabela abaixo resume as principais funções do pacote.\n\n| Nome da Função | Tradução          | O que faz                                                         |\n|---------------|---------------|-------------------------------------------|\n| `rename`       | Renomear          | Modifica o nome das colunas.                                      |\n| `select`       | Selecionar        | Seleciona as colunas.                                             |\n| `filter`       | Filtrar           | Filtra/seleciona as linhas segundo alguma condição.               |\n| `arrange`      | Arranjar/ordenar  | Ordena as linhas (crescente/decrescente) segundo alguma variável. |\n| `mutate`       | Mutar/transformar | Cria uma nova coluna a partir de outras colunas ou dados.         |\n| `summarise`    | Sumarizar/resumir | Aplica alguma função sobre as linhas. Cria uma tabela \"resumo\".   |\n| `group_by`     | Agrupar           | Agrupa as linhas segundo alguma variável.                         |\n\n# select\n\nA função `select` serve para selecionar colunas e reduzir a complexidade de uma tabela. Esta função mudou consideravelmente nos últimos anos após a criação de algumas funções auxiliares conhecidas como `tidyselectors`. Estas funções poderosas\n\n## O básico\n\nOs pacotes utilizados neste tutorial são listados abaixo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(readr)\n```\n:::\n\n\nPara praticar as funções vamos utilizar uma tabela que traz informações sobre as cidades do Brasil.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl <- readr::read_csv(\n  \"https://github.com/viniciusoike/restateinsight/raw/main/static/data/cities_brazil.csv\"\n  )\n```\n:::\n\n\nA função `select` serve para selecionar colunas. Adicionalmente, ela também pode renomear as colunas selecionadas. A sintaxe da função é a seguinte\n\n``` r\nselect(dados, coluna1, coluna2, nome_coluna = coluna3)\n```\n\nO código abaixo seleciona três colunas: `name_muni`, `population`, `pib`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(tbl, name_muni, population, pib)\n```\n:::\n\n\nPode-se selecionar colunas de três maneiras gerais: (1) como expressões (escrevendo o nome delas como se elas fossem objetos); (2) strings; (3) índices (que indicam a sua posição na tabela).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Selecionando colunas de modo geral\nselect(tbl, name_muni, population, pib)\n\n# Selecionando columnas usando strings\nselect(tbl, \"name_muni\", \"population\", \"pib\")\n# Selecionando colunas usando vetor de texto\nsel_cols = c(\"name_muni\", \"population\", \"pib\")\nselect(tbl, sel_cols)\n\n# Selecionando colunas usando índices\n\n# Usando índices explicitamente\nselect(tbl, 2, 8, 15)\n# Usando um vetor numérico\n\n# Encontra a posição de todas as colunas que começam com 'pib'\ninds <- grep(\"^pib_\", names(tbl))\nselect(tbl, inds)\n```\n:::\n\n\nPara remover uma coluna usa-se o sinal de menos (`-`) ou o operador lógico de negação (`!`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(tbl, !name_muni)\nselect(tbl, -name_muni)\n```\n:::\n\n\nPara facilitar a seleção de colunas, pode-se usar os operadores lógicos convencionais (`&`, `|`, `!`). Por fim, existe também o operador `:` que serve para selecionar colunas contíguas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(tbl, code_muni:name_region)\n```\n:::\n\n\n## Tidyselectors\n\nExiste um conjunto de funções auxiliares que facilita a seleção de colunas. Estas funções retornam índices a partir de alguma regra. Isto é, elas permitem selecionar colunas com base em algum padrão. O caso mais geral é da função `matches`, que seleciona colunas com base em um regex.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Seleciona as colunas que começam com 'pib_'\nselect(tbl, matches(\"^pib_\"))\n# Seleciona as colunas que terminam com 'muni'\nselect(tbl, matches(\"muni$\"))\n# Seleciona as colunas que contém o termo '_share'\nselect(tbl, matches(\"_share\"))\n```\n:::\n\n\nA função `matches` retorna colunas a partir de algum padrão de texto no nome da coluna. Na linha da [filosofia do tidyverse, de transformar tarefas rotineiras em funções específicas](https://restateinsight.com/posts/general-posts/2023-09-tidyverse/#funções) e com nomes \"intuitivos\" há uma série de funções auxiliares que imitam a função `matches`:\n\n-   `starts_with()` - seleciona colunas que começam com algum string\n\n-   `ends_with()` - seleciona colunas que terminam com algum string\n\n-   `contains()` - seleciona colunas que contêm algum string\n\nIsto é, podemos reescrever os códigos acima da seguinte maneira\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Seleciona as colunas que começam com 'pib_'\nselect(tbl, starts_with(\"pib_\"))\n# Seleciona as colunas que terminam com 'muni'\nselect(tbl, ends_with(\"muni\"))\n# Seleciona as colunas que contém o termo '_share'\nselect(tbl, contains(\"_share\"))\n```\n:::\n\n\nComo visto acima, pode-se selecionar colunas com base em um vetor de texto. Nos casos em que é necessário maior controle sobre a seleção, há duas funções auxiliares: `any_of` e `all_of`. A primeira função faz o match entre o vetor de texto e o nome das colunas e retorna todos os casos positivos; já a segunda função faz o match entre o vetor de texto e o nome das colunas e retorna um resultado somente no caso de todos os matches terem sucesso.\n\nA diferença entre as funções fica mais evidente num exemplo. Considere o caso em que colocamos uma coluna adicional `pib_per_capita` que não existe na base de dados. Quando se usa a função `all_of` retorna-se todas as colunas onde o match teve sucesso.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsel_cols <- c(\"code_muni\", \"name_muni\", \"population\", \"pib\", \"pib_per_capita\")\n\nselect(tbl, any_of(sel_cols))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5,570 × 4\n   code_muni name_muni             population     pib\n       <dbl> <chr>                      <dbl>   <dbl>\n 1   1100015 Alta Floresta D'Oeste      21495  570272\n 2   1100023 Ariquemes                  96833 2818049\n 3   1100031 Cabixi                      5363  167190\n 4   1100049 Cacoal                     86895 2519353\n 5   1100056 Cerejeiras                 15890  600670\n 6   1100064 Colorado do Oeste          15663  366931\n 7   1100072 Corumbiara                  7519  268381\n 8   1100080 Costa Marques              12627  261978\n 9   1100098 Espigão D'Oeste            29397  666331\n10   1100106 Guajará-Mirim              39386  984586\n# ℹ 5,560 more rows\n```\n:::\n:::\n\n\nA função `all_of` é mais exigente e retorna um erro neste caso.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(tbl, all_of(sel_cols))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `all_of()`:\n! Can't subset columns that don't exist.\n✖ Column `pib_per_capita` doesn't exist.\n```\n:::\n:::\n\n\nNote que, neste caso, isto é equivalente a:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(tbl, sel_cols)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `select()`:\n! Can't subset columns that don't exist.\n✖ Column `pib_per_capita` doesn't exist.\n```\n:::\n:::\n\n\nHá também algumas funções auxilares mais gerais:\n\n-   `everything()` - seleciona todas as colunas\n\n-   `last_col()` - seleciona a última coluna\n\n-   `group_cols()` - seleciona todas as colunas que compõem o `group`.\n\nA função `everything()` tem um comportamento particular quando combinada com outras colunas. A função seleciona todas as colunas, exceto as que foram explicitamente chamadas. Isto facilita bastante o trabalho de rearranjar as colunas dentro de uma mesma base de dados.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Coloca as colunas pib e pib_industrial na frente das demais colunas\nselect(tbl, pib, pib_industrial, everything())\n# Dropa todas as variáveis\nselect(tbl, -everything())\n```\n:::\n\n\nPor fim, pode-se selecionar as colunas pela sua classe. Vale lembrar que num `data.frame` cada coluna tem uma classe específica. Os exemplos abaixo mostram os casos de aplicação mais simples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Seleciona todas as colunas numéricas\nselect(tbl, where(is.numeric))\n# Seleciona todas as colunas tipo character\nselect(tbl, where(is.character))\n# Seleciona todas as colunas tipo factor\nselect(tbl, where(is.factor))\n# Selciona todas as colunas lógicas (i.e. TRUE, FALSE, NA)\nselect(tbl, where(is.logical))\n# Seleciona todas as colunas\nselect(tbl, where(is.Date))\n```\n:::\n\n\nEssencialmente, o que o código acima faz é aplicar a função selecionada em cada uma das colunas e retornar os casos positivos. É possível criar condições lógicas mais complexas com auxílio do operador `~` (tilde). Os exemplos abaixo mostram como dropar todas as colunas que contém somente `NA` e selecionar as colunas com datas (`Date`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# eval: true\ndat <- tibble(\n  lgl = NA,\n  missing = NA,\n  lglT = sample(c(TRUE, FALSE), size = 10, replace = TRUE),\n  dia_mes = seq(as.Date(\"2000-01-01\"), by = \"month\", length.out = 10),\n  val = rnorm(10)\n)\n\n# \"Remove\" as colunas que contêm somente NA\nselect(dat, !where(~all(is.na(.x))))\n# Seleciona apenas as colunas de data\nselect(dat, where(~all(inherits(.x, \"Date\"))))\n```\n:::\n\n\n## Resumindo\n\nEm resumo, temos quatro grupos gerais de `tidyselectors`.\n\n1.  Seleção com base num padrão de texto. (`matches`, `starts_with`, `ends_with`, `contains`)\n2.  Seleção com base num vetor de texto. (`all_of`, `any_of`)\n3.  Seleção com base na \"posição\". (`last_col`, `everything`, `group_cols`)\n4.  Seleção com base numa função que retorna um valor lógico. (`where`)\n\nEstas funções auxiliares são muito importantes pois elas funcionam não somente com o `select` mas também com outras funções do pacote `dplyr` como `mutate`, `rename`, `summarise` e outras. Estas funções são relativamente recentes e marcam uma [mudança considerável em relação às versões \\<1 do `dplyr`](https://www.tidyverse.org/blog/2020/04/dplyr-1-0-0-colwise/), que utilizam sufixos (`all`, `if`, `at`) para diferenciar as funções como `select_if`, ou `mutate_at`.\n\n# Outros posts da série\n\n-   [mutate](https://restateinsight.com/posts/general-posts/2024-01-tidyverse-mutate/)\n\n-   [filter](https://restateinsight.com/posts/general-posts/2024-01-tidyverse-filter/)\n\n-   [rename](https://restateinsight.com/posts/general-posts/2024-01-tidyverse-rename/)\n\n## Veja também\n\n-   [Tidyselect](https://dplyr.tidyverse.org/reference/dplyr_tidy_select.html)\n\n-   [Tidyselect help](https://tidyselect.r-lib.org/reference/language.html)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}