{
  "hash": "7b9c02e38ab0c429c0778da60f4d0efb",
  "result": {
    "markdown": "---\ntitle: \"Cidades Brasil\"\ncategories: ['tutorial-R', 'mapas', 'ggplot2']\ndate: '2023-10-15'\ndescription: \"Este tutorial ensina como fazer um mapa da altitude de ruas de uma cidade usando programação funcional. O princípio da programação funcional é de decompor uma tarefa complexa em funções modulares, que tornam o código mais eficiente e estável. Ao final do tutorial, será possível reproduzir o mapa de altitude usando somente uma linha de código.\"\nimage: \"/static/maps/elevation_xx_fortaleza.svg\"\nimage-alt: \"/static/maps/elevation_xx_fortaleza.svg\"\n---\n\n\n\n\n# O objetivo\n\nO objetivo deste post é conseguir gerar o gráfico abaixo com uma única linha de código. Isto será possível, pois todo o processamento dos dados será feito por funções auxiliares. A inspiração do mapa vem diretamente de [BlakeRMills](https://www.blakerobertmills.com/my-work/visualizations), criador do pacote [{MetBrewer}](https://github.com/BlakeRMills/MetBrewer).\n\nAbaixo segue a lista de todos os pacotes utilizados neste post. Não é necessário chamar todos eles com `library` mas é preciso ter todos eles instalados[^1]. Com exceção dos três primeiros, usaremos somente uma ou duas funções de cada um dos pacotes.\n\n[^1]: Chamar muitos pacotes numa mesma sessão pode levar a muitos conflitos entre funções com o mesmo nome. Isto não é um problema muito sério já que sempre é possível especificar `nome_pacote::nome_funcao`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Principais pacotes\nlibrary(dplyr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(osmdata)\nlibrary(elevatr)\nlibrary(raster)\nlibrary(geobr)\n#> Pacotes auxiliares\nlibrary(purrr)\nlibrary(furrr)\nlibrary(rvest)\nlibrary(xml2)\nlibrary(BAMMtools)\nlibrary(stringr)\nlibrary(janitor)\nlibrary(ggthemes)\nlibrary(viridis)\nlibrary(showtext)\n```\n:::\n\n\n# Recife\n\nPara ganhar intuição sobre o processo vamos fazer o passo a passo de Recife. Escolho a cidade de Recife, pois ela é uma cidade relativamente pequena em termos de área física.\n\n## Baixando os dados\n\nO objetivo é gerar o mapa de altitude das principais cidades do Brasil. Ao invés de ranquear as cidades por área, eu prefiro ordená-las por tamanho de população. Uma maneira fácil de conseguir esta informação é buscando ela diretamente na Wikipedia. No link temos uma tabela com código do IBGE, nome do município, nome do estado e população total em 2022.\n\nÉ bastante simples importar esta tabela no R. O código abaixo, interpreta a página com base na url, encontra todas as tabelas[^2] e escolhe especificamente a tabela principal.\n\n[^2]: Na verdade, o código encontra todos os elementos com a classe `table` na página.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nurl = \"https://pt.wikipedia.org/wiki/Lista_de_municípios_do_Brasil_por_população\"\n\ntab = xml2::read_html(url) |> \n  rvest::html_table() |> \n  purrr::pluck(2)\n\nhead(tab)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  Posição `Código IBGE` Município      `Unidade federativa` População \n  <chr>   <chr>         <chr>          <chr>                <chr>     \n1 1º      3550308       São Paulo      São Paulo            11 451 245\n2 2º      3304557       Rio de Janeiro Rio de Janeiro       6 211 423 \n3 3º      5300108       Brasília       Distrito Federal     2 817 068 \n4 4º      2304400       Fortaleza      Ceará                2 428 678 \n5 5º      2927408       Salvador       Bahia                2 418 005 \n6 6º      3106200       Belo Horizonte Minas Gerais         2 315 560 \n```\n:::\n:::\n\n\nEste dado está um pouco sujo então eu limpo a tabela para facilitar nosso trabalho. Após limpar os dados, eu seleciono as 200 cidades mais populosas.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nas_numeric_char = Vectorize(function(x) {\n  ls = stringr::str_extract_all(x, \"[[:digit:]]\")\n  y = paste(ls[[1]], collapse = \"\")\n  as.numeric(y)\n})\n\nclean_tab = tab |> \n  janitor::clean_names() |> \n  rename(\n    code_muni = codigo_ibge,\n    name_muni = municipio,\n    rank = posicao,\n    name_state = unidade_federativa,\n    pop = populacao\n  ) |> \n  filter(name_muni != \"Brasil\") |> \n  mutate(\n    code_muni = as.numeric(code_muni),\n    pop = as_numeric_char(pop),\n    rank = rank(-pop),\n    name_muni = stringr::str_to_title(name_muni)\n  )\n\ntop200 = slice_max(clean_tab, pop, n = 200)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n```{=html}\n<div class=\"datatables html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-6d7c505fe54f473ec607\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-6d7c505fe54f473ec607\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"29\",\"30\",\"31\",\"32\",\"33\",\"34\",\"35\",\"36\",\"37\",\"38\",\"39\",\"40\",\"41\",\"42\",\"43\",\"44\",\"45\",\"46\",\"47\",\"48\",\"49\",\"50\",\"51\",\"52\",\"53\",\"54\",\"55\",\"56\",\"57\",\"58\",\"59\",\"60\",\"61\",\"62\",\"63\",\"64\",\"65\",\"66\",\"67\",\"68\",\"69\",\"70\",\"71\",\"72\",\"73\",\"74\",\"75\",\"76\",\"77\",\"78\",\"79\",\"80\",\"81\",\"82\",\"83\",\"84\",\"85\",\"86\",\"87\",\"88\",\"89\",\"90\",\"91\",\"92\",\"93\",\"94\",\"95\",\"96\",\"97\",\"98\",\"99\",\"100\",\"101\",\"102\",\"103\",\"104\",\"105\",\"106\",\"107\",\"108\",\"109\",\"110\",\"111\",\"112\",\"113\",\"114\",\"115\",\"116\",\"117\",\"118\",\"119\",\"120\",\"121\",\"122\",\"123\",\"124\",\"125\",\"126\",\"127\",\"128\",\"129\",\"130\",\"131\",\"132\",\"133\",\"134\",\"135\",\"136\",\"137\",\"138\",\"139\",\"140\",\"141\",\"142\",\"143\",\"144\",\"145\",\"146\",\"147\",\"148\",\"149\",\"150\",\"151\",\"152\",\"153\",\"154\",\"155\",\"156\",\"157\",\"158\",\"159\",\"160\",\"161\",\"162\",\"163\",\"164\",\"165\",\"166\",\"167\",\"168\",\"169\",\"170\",\"171\",\"172\",\"173\",\"174\",\"175\",\"176\",\"177\",\"178\",\"179\",\"180\",\"181\",\"182\",\"183\",\"184\",\"185\",\"186\",\"187\",\"188\",\"189\",\"190\",\"191\",\"192\",\"193\",\"194\",\"195\",\"196\",\"197\",\"198\",\"199\",\"200\"],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200],[3550308,3304557,5300108,2304400,2927408,3106200,1302603,4106902,2611606,5208707,4314902,1501402,3518800,3509502,2111300,2704302,5002704,3304904,2211001,2507507,3548708,3301702,3303500,2408102,3547809,3534401,3552205,3170206,3543402,3549904,5103403,2607901,3118601,4209102,2910800,2800308,4113700,3136702,4205407,5201405,3205002,3301009,3300456,3303302,3549805,1500800,3205200,4305108,1100205,3530607,3525904,1600303,3305109,3538709,2504009,3548500,3529401,3143302,1400100,3106705,4115200,5201108,3513801,3510609,2611101,3506003,2604106,2933307,3523107,1200401,4202404,4119905,2303709,3201308,3516200,2609600,3541000,4104808,4304606,2610707,3170107,1506807,3551009,3154606,4125506,4314407,3205309,3505708,3554102,3552502,1721000,2905701,5108402,3526902,3518701,2307304,4108304,3552403,3303906,4316907,3513009,3552809,2105302,4216602,1504208,1505536,4309209,2408003,4208203,3306305,3127701,3520509,3548906,4204202,2403251,3515004,3302403,5107602,2111201,5003702,3503208,3524402,3529005,3501608,3519071,2918407,2700300,2307650,3522505,4105805,3122306,3302502,4313409,3131307,3167202,3541406,5218805,5200258,3301900,4323002,4211900,3300704,3157807,4318705,4204608,5212501,4314100,2919207,2602902,2312908,3543907,3502804,5221858,3302700,5107909,2804805,1502400,4315602,3303401,4300604,2914802,3201209,3545803,4208906,4109401,3515707,2913606,3507605,2112209,1702109,3129806,3300407,3523909,2925303,3300100,3302858,3203205,3548807,3538006,3516309,3305802,4209300,3151800,2207702,2903201,3148004,2918001,3504107,3522208,1500107,3522307,2103000,3304524,5220454,3547304,3530706,3152501,4101804,2900702,4127700],[\"São Paulo\",\"Rio De Janeiro\",\"Brasília\",\"Fortaleza\",\"Salvador\",\"Belo Horizonte\",\"Manaus\",\"Curitiba\",\"Recife\",\"Goiânia\",\"Porto Alegre\",\"Belém\",\"Guarulhos\",\"Campinas\",\"São Luís\",\"Maceió\",\"Campo Grande\",\"São Gonçalo\",\"Teresina\",\"João Pessoa\",\"São Bernardo Do Campo\",\"Duque De Caxias\",\"Nova Iguaçu\",\"Natal\",\"Santo André\",\"Osasco\",\"Sorocaba\",\"Uberlândia\",\"Ribeirão Preto\",\"São José Dos Campos\",\"Cuiabá\",\"Jaboatão Dos Guararapes\",\"Contagem\",\"Joinville\",\"Feira De Santana\",\"Aracaju\",\"Londrina\",\"Juiz De Fora\",\"Florianópolis\",\"Aparecida De Goiânia\",\"Serra\",\"Campos Dos Goytacazes\",\"Belford Roxo\",\"Niterói\",\"São José Do Rio Preto\",\"Ananindeua\",\"Vila Velha\",\"Caxias Do Sul\",\"Porto Velho\",\"Mogi Das Cruzes\",\"Jundiaí\",\"Macapá\",\"São João De Meriti\",\"Piracicaba\",\"Campina Grande\",\"Santos\",\"Mauá\",\"Montes Claros\",\"Boa Vista\",\"Betim\",\"Maringá\",\"Anápolis\",\"Diadema\",\"Carapicuíba\",\"Petrolina\",\"Bauru\",\"Caruaru\",\"Vitória Da Conquista\",\"Itaquaquecetuba\",\"Rio Branco\",\"Blumenau\",\"Ponta Grossa\",\"Caucaia\",\"Cariacica\",\"Franca\",\"Olinda\",\"Praia Grande\",\"Cascavel\",\"Canoas\",\"Paulista\",\"Uberaba\",\"Santarém\",\"São Vicente\",\"Ribeirão Das Neves\",\"São José Dos Pinhais\",\"Pelotas\",\"Vitória\",\"Barueri\",\"Taubaté\",\"Suzano\",\"Palmas\",\"Camaçari\",\"Várzea Grande\",\"Limeira\",\"Guarujá\",\"Juazeiro Do Norte\",\"Foz Do Iguaçu\",\"Sumaré\",\"Petrópolis\",\"Santa Maria\",\"Cotia\",\"Taboão Da Serra\",\"Imperatriz\",\"São José\",\"Marabá\",\"Parauapebas\",\"Gravataí\",\"Mossoró\",\"Itajaí\",\"Volta Redonda\",\"Governador Valadares\",\"Indaiatuba\",\"São Carlos\",\"Chapecó\",\"Parnamirim\",\"Embu Das Artes\",\"Macaé\",\"Rondonópolis\",\"São José De Ribamar\",\"Dourados\",\"Araraquara\",\"Jacareí\",\"Marília\",\"Americana\",\"Hortolândia\",\"Juazeiro\",\"Arapiraca\",\"Maracanaú\",\"Itapevi\",\"Colombo\",\"Divinópolis\",\"Magé\",\"Novo Hamburgo\",\"Ipatinga\",\"Sete Lagoas\",\"Presidente Prudente\",\"Rio Verde\",\"Águas Lindas De Goiás\",\"Itaboraí\",\"Viamão\",\"Palhoça\",\"Cabo Frio\",\"Santa Luzia\",\"São Leopoldo\",\"Criciúma\",\"Luziânia\",\"Passo Fundo\",\"Lauro De Freitas\",\"Cabo De Santo Agostinho\",\"Sobral\",\"Rio Claro\",\"Araçatuba\",\"Valparaíso De Goiás\",\"Maricá\",\"Sinop\",\"Nossa Senhora Do Socorro\",\"Castanhal\",\"Rio Grande\",\"Nova Friburgo\",\"Alvorada\",\"Itabuna\",\"Cachoeiro De Itapemirim\",\"Santa Bárbara D'oeste\",\"Jaraguá Do Sul\",\"Guarapuava\",\"Ferraz De Vasconcelos\",\"Ilhéus\",\"Bragança Paulista\",\"Timon\",\"Araguaína\",\"Ibirité\",\"Barra Mansa\",\"Itu\",\"Porto Seguro\",\"Angra Dos Reis\",\"Mesquita\",\"Linhares\",\"São Caetano Do Sul\",\"Pindamonhangaba\",\"Francisco Morato\",\"Teresópolis\",\"Lages\",\"Poços De Caldas\",\"Parnaíba\",\"Barreiras\",\"Patos De Minas\",\"Jequié\",\"Atibaia\",\"Itapecerica Da Serra\",\"Abaetetuba\",\"Itapetininga\",\"Caxias\",\"Rio Das Ostras\",\"Senador Canedo\",\"Santana De Parnaíba\",\"Mogi Guaçu\",\"Pouso Alegre\",\"Araucária\",\"Alagoinhas\",\"Toledo\"],[\"São Paulo\",\"Rio de Janeiro\",\"Distrito Federal\",\"Ceará\",\"Bahia\",\"Minas Gerais\",\"Amazonas\",\"Paraná\",\"Pernambuco\",\"Goiás\",\"Rio Grande do Sul\",\"Pará\",\"São Paulo\",\"São Paulo\",\"Maranhão\",\"Alagoas\",\"Mato Grosso do Sul\",\"Rio de Janeiro\",\"Piauí\",\"Paraíba\",\"São Paulo\",\"Rio de Janeiro\",\"Rio de Janeiro\",\"Rio Grande do Norte\",\"São Paulo\",\"São Paulo\",\"São Paulo\",\"Minas Gerais\",\"São Paulo\",\"São Paulo\",\"Mato Grosso\",\"Pernambuco\",\"Minas Gerais\",\"Santa Catarina\",\"Bahia\",\"Sergipe\",\"Paraná\",\"Minas Gerais\",\"Santa Catarina\",\"Goiás\",\"Espírito Santo\",\"Rio de Janeiro\",\"Rio de Janeiro\",\"Rio de Janeiro\",\"São Paulo\",\"Pará\",\"Espírito Santo\",\"Rio Grande do Sul\",\"Rondônia\",\"São Paulo\",\"São Paulo\",\"Amapá\",\"Rio de Janeiro\",\"São Paulo\",\"Paraíba\",\"São Paulo\",\"São Paulo\",\"Minas Gerais\",\"Roraima\",\"Minas Gerais\",\"Paraná\",\"Goiás\",\"São Paulo\",\"São Paulo\",\"Pernambuco\",\"São Paulo\",\"Pernambuco\",\"Bahia\",\"São Paulo\",\"Acre\",\"Santa Catarina\",\"Paraná\",\"Ceará\",\"Espírito Santo\",\"São Paulo\",\"Pernambuco\",\"São Paulo\",\"Paraná\",\"Rio Grande do Sul\",\"Pernambuco\",\"Minas Gerais\",\"Pará\",\"São Paulo\",\"Minas Gerais\",\"Paraná\",\"Rio Grande do Sul\",\"Espírito Santo\",\"São Paulo\",\"São Paulo\",\"São Paulo\",\"Tocantins\",\"Bahia\",\"Mato Grosso\",\"São Paulo\",\"São Paulo\",\"Ceará\",\"Paraná\",\"São Paulo\",\"Rio de Janeiro\",\"Rio Grande do Sul\",\"São Paulo\",\"São Paulo\",\"Maranhão\",\"Santa Catarina\",\"Pará\",\"Pará\",\"Rio Grande do Sul\",\"Rio Grande do Norte\",\"Santa Catarina\",\"Rio de Janeiro\",\"Minas Gerais\",\"São Paulo\",\"São Paulo\",\"Santa Catarina\",\"Rio Grande do Norte\",\"São Paulo\",\"Rio de Janeiro\",\"Mato Grosso\",\"Maranhão\",\"Mato Grosso do Sul\",\"São Paulo\",\"São Paulo\",\"São Paulo\",\"São Paulo\",\"São Paulo\",\"Bahia\",\"Alagoas\",\"Ceará\",\"São Paulo\",\"Paraná\",\"Minas Gerais\",\"Rio de Janeiro\",\"Rio Grande do Sul\",\"Minas Gerais\",\"Minas Gerais\",\"São Paulo\",\"Goiás\",\"Goiás\",\"Rio de Janeiro\",\"Rio Grande do Sul\",\"Santa Catarina\",\"Rio de Janeiro\",\"Minas Gerais\",\"Rio Grande do Sul\",\"Santa Catarina\",\"Goiás\",\"Rio Grande do Sul\",\"Bahia\",\"Pernambuco\",\"Ceará\",\"São Paulo\",\"São Paulo\",\"Goiás\",\"Rio de Janeiro\",\"Mato Grosso\",\"Sergipe\",\"Pará\",\"Rio Grande do Sul\",\"Rio de Janeiro\",\"Rio Grande do Sul\",\"Bahia\",\"Espírito Santo\",\"São Paulo\",\"Santa Catarina\",\"Paraná\",\"São Paulo\",\"Bahia\",\"São Paulo\",\"Maranhão\",\"Tocantins\",\"Minas Gerais\",\"Rio de Janeiro\",\"São Paulo\",\"Bahia\",\"Rio de Janeiro\",\"Rio de Janeiro\",\"Espírito Santo\",\"São Paulo\",\"São Paulo\",\"São Paulo\",\"Rio de Janeiro\",\"Santa Catarina\",\"Minas Gerais\",\"Piauí\",\"Bahia\",\"Minas Gerais\",\"Bahia\",\"São Paulo\",\"São Paulo\",\"Pará\",\"São Paulo\",\"Maranhão\",\"Rio de Janeiro\",\"Goiás\",\"São Paulo\",\"São Paulo\",\"Minas Gerais\",\"Paraná\",\"Bahia\",\"Paraná\"],[11451245,6211423,2817068,2428678,2418005,2315560,2063547,1773733,1488920,1437237,1332570,1303309,1291784,1138309,1037775,957916,897938,896744,866300,833932,810729,808252,785882,751300,748919,743432,723574,713232,698259,697428,650912,643759,621865,616323,616279,602757,555937,540756,537213,527550,520649,483551,483087,481758,480439,478778,467722,463338,460413,449955,443116,442933,440962,423323,419379,418608,418261,414240,413486,411859,409657,398817,393237,387121,386786,379146,378052,370868,369275,364756,361261,358367,355679,353510,352537,349976,349935,348051,347657,342167,337846,331937,329844,329794,329222,325689,322869,316473,310739,307364,302692,299579,299472,291869,287634,286120,285415,279546,278881,277205,273640,273542,273110,270295,266536,266424,265070,264577,264054,261584,257172,255739,254822,254781,252716,250720,246391,244897,244579,243368,242228,240275,237629,237247,236641,235816,234696,234392,232513,232056,231091,228127,227732,227731,227360,225868,225696,225671,224267,224116,222598,221987,218805,217410,214493,208725,206224,203334,203216,203023,201418,200124,198861,197300,196067,192330,192262,191900,189937,187315,186708,185784,183347,182660,182093,179205,178703,176811,174465,171301,170387,169899,168240,167955,167418,167128,166786,165655,165428,165139,165123,164981,163742,162159,159743,159235,158812,158640,158522,158188,157790,156970,156491,155635,154105,153661,152212,151166,151065,150470]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th> <\\/th>\\n      <th>rank<\\/th>\\n      <th>code_muni<\\/th>\\n      <th>name_muni<\\/th>\\n      <th>name_state<\\/th>\\n      <th>pop<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"columnDefs\":[{\"className\":\"dt-right\",\"targets\":[1,2,5]},{\"orderable\":false,\"targets\":0}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\n## Shape da cidade\n\nAgora que temos uma lista de cidades podemos importar o shapefile com os limites territoriais do município do Recife. Graças ao pacote `{geobr}` isto é muito simples. A função `read_municipality` faz justamente isto e precisa apenas do código de 7 dígitos do IBGE.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Encontra o código do IBGE de Recife\ncode_muni = top200 |> \n  filter(name_muni == \"Recife\") |> \n  pull(code_muni)\n\n#> Importa o shape dos limites do município\nborder = geobr::read_municipality(code_muni, showProgress = FALSE)\n\n#> Um mapa simples para checar o resultado\nggplot(border) +\n  geom_sf() +\n  ggtitle(\"Limites do município\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Principais vias\n\nO segundo passo é importar o shape das principais vias da cidade. Aqui, uso o pacote `{osmdata}`. O código abaixo importa as vias como \"linhas\" e depois usa os limites do município para remover os segmentos de linhas que estão fora da cidade.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Define os \"limites\" da busca. Monta um bounding box em torno do Recife\nrec = opq(bbox = getbb(\"Recife, Pernambuco, Brazil\"))\n\n#> Pega as principais vias\nstreets = add_osm_feature(\n  rec,\n  key = \"highway\",\n  value = c(\"primary\", \"secondary\", \"tertiary\", \"residential\")\n  )\n\n#> Converte o objeto para sf (LINESTRING)\nstreets = osmdata_sf(streets)\nstreets = streets$osm_lines\nstreets = select(streets, osm_id, name)\nstreets = st_transform(streets, crs = 4674)\n#> Encontra a intersecção entre as vias e os limites do município\nstreets_border = st_intersection(streets, border)\n```\n:::\n\n\nPara tornar mais evidente o que está acontecendo mostro primeiro o resultado geral, com todas as vias.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(streets) + \n  geom_sf(linewidth = 0.15) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nE agora o resultado após a intersecção entre as vias e os limites do município.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = border, fill = NA) +\n  geom_sf(data = streets_border, linewidth = 0.15, color = \"gray20\") +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Altitude\n\nO terceiro passo é importar os dados de altitude da cidade. Isto é feito com o pacote `{elevatr}`. Como os dados de altitude são armazenados como raster preciso convertê-los para dados em formato de vetor[^3]. Novamente eu faço a intersecção destes dados com os limites do município para ficar somente com os valores que nos interessam.\n\n[^3]: Para uma introdução aos tipos de objetos espaciais (*raster* e *vector*) veja [Lovelace (2023)](https://r.geocompx.org/spatial-class).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Importa os dados de altitude\naltitude = elevatr::get_elev_raster(border, z = 9, clip = \"bbox\")\n#> Converte para 'vector'\nrec_alti = raster::rasterToPolygons(altitude)\nrec_alti = sf::st_as_sf(rec_alti)\nnames(rec_alti)[1] = \"elevation\"\n\n#> Converte o CRS e intersecta com os limites do município\nrec_alti = rec_alti %>%\n  st_transform(crs = 4674) %>%\n  st_intersection(border) %>%\n  #> Remove geometrias inválidas\n  filter(st_is_valid(.))\n```\n:::\n\n\nO gráfico abaixo mostra o resultado final.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Mapa\nggplot(rec_alti) +\n  geom_sf(aes(fill = elevation)) +\n  scale_fill_viridis_c(name = \"Altitude\", option = \"inferno\") +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### Classificando a altitude\n\nPara facilitar a visualização dos dados, classifica-se eles em grupos. Eu uso o [algoritmo de Jenks](https://en.wikipedia.org/wiki/Jenks_natural_breaks_optimization) para classificar os dados de elevação em 7 grupos distintos. O algoritmo de Jenks, também conhecido como \"quebras naturais\", é bastante utilizado com dados espaciais.\n\nComo todo algoritmo de clustering, o algoritmo de Jenks busca minimizar a distância intraclasse enquanto tenta maximizar a distância entre as classes; isto é, ele busca observações parecidas e juntas elas em um grupo e busca separar os grupos o máximo possível.\n\nA medida de distância/dissemelhança que o algoritmo usa é a soma do quadrado dos desvios (em relação à média do grupo). O algortimo busca minimizar esta \"variância\" em cada um dos grupos para encontrar os grupos mais \"parecidos\" possíveis. O número de grupos é arbitrário e precisa ser selecionado manualmente[^4]. Eu costumo escolher algum número entre 3 e 9.\n\n[^4]: Existem alguns métodos que ajudam a escolher um número \"ótimo\" de clusters, como o \"elbow method\" mas vale lembrar que clustering é muito mais arte do que ciência. Clustering envolve agrupar dados semelhantes em um número finito de grupos, mas há inúmeras maneiras de definir \"semelhante\"; além disso, o algoritmo de clustering sempre chega num agrupamento, qualquer que seja a escolha do número de grupos. Assim, é importante frisar que estes resultados são mais explortatórios, por assim dizer.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njbreaks = BAMMtools::getJenksBreaks(rec_alti$elevation, k = 7)\njbreaks = round(jbreaks, -1)\n\nrec_alti = rec_alti %>%\n  mutate(\n    jenks_group = cut(elevation, jbreaks)\n  )\n```\n:::\n\n\nO resultado do agrupamento pode ser visto no histograma abaixo, onde as linhas verticais representam as quebras entre os grupos.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot(rec_alti, aes(x = elevation)) +\n  geom_histogram(bins = 40, color = \"white\") +\n  geom_hline(yintercept = 0) +\n  geom_vline(xintercept = jbreaks) +\n  scale_x_continuous(limits = c(-1, NA)) +\n  labs(\n    title = \"Distribuição da altitude em Recife\",\n    subtitle = \"Linhas verticais mostram o agrupamento do algoritmo de Jenks\"\n    ) +\n  theme_light()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nO mapa abaixo mostra o formato dos dados de altitude. Temos um grid retangular que mostram a altura, em metros, da cidade do Recife.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Mapa\nggplot(rec_alti) +\n  geom_sf(aes(fill = jenks_group)) +\n  scale_fill_viridis_d(option = \"inferno\") +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Juntando as partes\n\nA próxima etapa é um pouco mais complexa então vamos proceder em passos curtos. Os dados de altitude estão agrupados em grupos, definidos pelo algoritmo de jenks. Nosso objetivo é encontrar todas as ruas que pertencem a cada um destes grupos de altitude.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlevels(rec_alti$jenks_group)\n#> [1] \"(-40,20]\" \"(20,30]\"  \"(30,50]\"  \"(50,70]\"  \"(70,90]\"  \"(90,120]\"\n\njgroups = levels(rec_alti$jenks_group)\n```\n:::\n\n\nO mapa abaixo mostra todos as áreas com altitude dentro do grupo 6 (90, 120\\].\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njgroups = levels(rec_alti$jenks_group)\n\n\nsub = rec_alti %>%\n  filter(jenks_group == jgroups[6]) %>%\n  st_union(.) %>%\n  st_as_sf()\n\nggplot(sub) + geom_sf()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nFazendo a intereseção entre este subconjunto do grid de altitude com o shape das ruas, encontra-se somente as vias que estão neste grupo de altitude.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsubstreet = streets %>%\n  st_intersection(sub) %>%\n  filter(st_is_valid(.))\n\nggplot() +\n  geom_sf(data = substreet, linewidth = 0.5) +\n  geom_sf(data = sub, fill = NA)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nJuntando as duas etapas num mesmo bloco de código temos as linhas abaixo. Primeiro, encontra-se o subconjunto do grid de altitude dentro de um grupo. Depois, faz-se a interseção deste grupo com as vias da cidade.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npoly = rec_alti %>%\n  filter(jenks_group == jgroups[6]) %>%\n  st_union(.) %>%\n  st_as_sf()\n\njoined = streets %>%\n  st_intersection(poly) %>%\n  filter(st_is_valid(.))\n\nggplot(joined) + geom_sf()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nPara repetir o código acima em todos os grupos, faz-se um loop simples. Os resultados são gravados numa lista chamada `streets_altitude`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Cria uma lista para gravar os resultados\nstreets_altitude = list()\n\n#> For-loop em todos os elementos de jgroups\nfor (i in seq_along(jgroups)) {\n\n  #> Seleciona um nível do grupo em particular  \n  group = levels(rec_alti$jenks_group)[[i]]\n  \n  #> Encontra o subconjunto de do grid de altitude que corresponde a este grupo\n  poly = rec_alti %>%\n    filter(jenks_group == group) %>%\n    st_union(.) %>%\n    st_as_sf()\n  #> Faz a interseção deste subconjunto com as vias da cidade\n  joined = streets %>%\n    st_intersection(poly) %>%\n    filter(st_is_valid(.)) %>%\n    mutate(level = factor(i))\n  #> Grava o resultado como elemento da lista streets_altitude\n  streets_altitude[[i]] <- joined\n  \n}\n```\n:::\n\n\nFeito isto, pode-se verificar visualmente o resultado.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrec_streets_altitude <- bind_rows(streets_altitude)\n\nggplot(rec_streets_altitude) +\n  geom_sf(aes(fill = level, color = level), linewidth = 0.2) +\n  scale_fill_viridis_d(name = \"Altitude\", option = \"inferno\") +\n  scale_color_viridis_d(name = \"Altitude\", option = \"inferno\") +\n  theme_void() +\n  theme(\n    legend.position = \"none\",\n    panel.background = element_rect(color = NA, fill = \"gray75\")\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Mapa final\n\nPara montar a versão finalizada do mapa, adiciona-se alguns elementos temáticos. Para saber mais sobre elementos temáticos e a função theme, consulte meu [post](https://restateinsight.com/posts/ggplot2-tutorial/7-themes-fonts).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncores = c(\n  \"#0D0887FF\", \"#5402A3FF\", \"#8B0AA5FF\", \"#B93289FF\", \"#DB5C68FF\", \n  \"#F48849FF\", \"#FEBC2AFF\"\n  )\n\njlabels = paste(jbreaks, jbreaks[-1], sep = \"–\")\njlabels[1] = paste(\"<\", min(jbreaks[-1]))\njlabels[length(jlabels)] = paste(\">\", max(jbreaks))\n\nggplot(data = rec_streets_altitude) +\n  geom_sf(aes(color = level, fill = level), linewidth = 0.2) +\n  scale_color_manual(name = \"Altitude\", values = cores, labels = jlabels) +\n  scale_fill_manual(name = \"Altitude\", values = cores, labels = jlabels) +\n  guides(fill = guide_legend(nrow = 1), color = guide_legend(nrow = 1)) +\n  ggtitle(\"Recife\") +\n  ggthemes::theme_map() +\n  coord_sf() +\n  theme(\n    plot.title = element_text(size = 16, hjust = 0.5),\n    legend.position = \"top\",\n    legend.direction = \"horizontal\",\n    legend.text = element_text(size = 8),\n    panel.background = element_rect(color = NA, fill = \"#f6eee3\"),\n    plot.background = element_rect(color = NA, fill = \"#f6eee3\"),\n    legend.background = element_rect(color = NA, fill = \"#f6eee3\")\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n# Programação funcional\n\nA ideia geral da programação funcional é de transformar um código em funções. Todo o código acima é feito de comandos: encontre a tabela com a população dos municípios neste link e importe os dados; aplique o algoritmo de Jenks neste vetor numérico e guarde o resultado no objeto chamado `jgroups` e assim por diante.\n\nNosso objetivo agora é transformar o passo-a-passo acima em funções distintas, cada uma executando uma tarefa específica. Por fim, vamos criar uma função que chama todas estas funções individuais e que vai criar o mesmo mapa acima em uma única linha.\n\nAntes de seguir no tutorial, vale revisar um pouco sobre como funcionam funções no R.\n\n## O básico de funções\n\nUma função transforma um *input* num *output* seguindo uma série de comandos. Uma função no R é composta de três elementos: (1) *formals*; (2) *body*; e (3) *environment*. O primeiro elemento corresponde aos *argumentos* da função e o segundo elemento corresponde à função, propriamente dita. Tomando um exemplo da matemática considere a função abaixo\n\n$$\nf(x) = x^2 + 1\n$$\n\nNeste caso, o *formals* seria simplesmente $x$ e o *body* seria $x^2 + 1$ . Podemos ver como isto ocorre dentro do R.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nf <- function(x) {\n  x^2 + 1\n}\n\nformals(f)\n#> $x\nbody(f)\n#> {\n#>    x^2 + 1\n#> }\nenvironment(f)\n#> <environment: R_GlobalEnv>\n```\n:::\n\n\nO *environment* é o ambiente onde a função existe; geralmente, o environment é simplesmente `R_GlobalEnv`, o ambiente \"global\" onde habitam todos os objetos que você cria como, por exemplo, `x <- 1:5`. Este aspecto é um pouco mais técnico, mas é o que permite que funções habitem dentro de funções.\n\nO exemplo abaixo é adaptado do livro [Advanced R](http://adv-r.had.co.nz/Functions.html) e ilustra como funcionam diferentes environments quando se tem funções dentro de funções.\n\nFunções compartimentalizam o seu ambiente de trabalho. **O que acontece dentro da função, fica dentro da função**. Assim, a linha `y <- 2` abaixo \"existe\" apenas dentro do contexto da função `j`. Os objetos definidos dentro de funções não interferem com objetos criados fora da função.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprint(environment())\n#> <environment: R_GlobalEnv>\nj <- function(x) {\n  y <- 2\n  print(environment())\n  #> <environment: 0x16eaa2320>\n  function() {\n    print(environment())\n    #> <environment: 0x16e9f8d40>\n    c(x, y)\n  }\n}\nk <- j(1)\nk()\n#> [1] 1 2\nprint(y)\n#> Error in print(y) : object 'y' not found\n```\n:::\n\n\nUma função executa um conjunto de ações sobre seus *inputs* dentro de um \"ambiente controlado\" e devolve apenas o resultado final, *output*, para a sessão ativa do R. Assim, funções permitem *isolar partes do código* e dispensar resultados intermediários.\n\nO próximo exemplo mostra como filtrar linhas de um `data.frame`. No fundo, esta função simplesmente chama `dplyr::filter` e fornece argumentos numa determinada maneira. Note que declaro o nome do pacote `dplyr` o que evita a necessidade de chamar `library(dplyr)` e torna a função `filtrar_linhas` portátil[^5].\n\n[^5]: Declarar explicitamente o pacote utilizado é a melhor maneira de escrever novas funções. Isto garante que a função vai funcionar em qualquer contexto onde o pacote estiver instalado. A longo prazo, isto também permite que se use a mesma função em outro projeto ou até mesmo dentro de um novo pacote. Vale notar que algumas funções base como `mean`, `round`, `findInterval`, etc. não precisam ser declaradas pois elas fazem parte do base-R.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndados = data.frame(\n  grupo = c(\"A\", \"A\", \"A\", \"B\", \"C\"),\n  y = c(1, 3, 7, 4, 1)\n)\n\n\nfiltrar_linhas = function(df, filter_val) {\n  dplyr::filter(df, grupo == filter_val)\n}\n\nfiltrar_linhas(dados, \"B\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  grupo y\n1     B 4\n```\n:::\n:::\n\n\nEste é um ponto importante: em geral, nossas funções simplesmente chamam outras funções prontas numa ordem específica e com argumentos específicos.\n\nO próximo é exemplo é um pouco mais sofisticado. Agora temos uma função que calcula a média geométrica de um vetor numérico. Neste caso há uma estrutura de `if`/`else` dentro do corpo da função que verifica o input antes de executar os cálculos. Especificamente, como a média geométrica é definida apenas para números positivos faz-se um teste para verificar se o *input* contém apenas números positivos.\n\nNote que as funções `exp`, `mean` e `log` são utilizadas sem o sinal `::` pois estas funções do base-R. Isto é, são funções básicas, que permitem que o R funcione enquanto linguagem de programação, e estão sempre disponíveis.\n\nAlém disso, desta vez uso `return` para explicitamente declarar qual objeto a função deve retornar. Vale reforçar que o objeto `z <- exp(mean(log(x)))` passa a existir somente dentro da função. Ou seja, ele não interfere com algum objeto `z` que exista ou que possa vir a existir no ambiente global.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngeometric_mean <- function(x) {\n  #> Verifica o input\n  if (is.numeric(x) && all(x > 0)) {\n    #> Calcula a média geométrica\n    z <- exp(mean(log(x)))\n    #> Retorna o vetor z\n    return(z)\n    \n  } else {\n    #> Retorna um erro\n    stop(\"Non-positive values found in x.\")\n    \n  }\n  \n}\n\ny <- c(1, 4, 5, 10, 15, 6)\ngeometric_mean(y)\n#> [1] 5.119318\nz <- c(-1, 4, 5, 10, 15, 6)\ngeometric_mean(z)\n#> Error in geometric_mean(z) : Non-positive values found in x.\n```\n:::\n\n\nNa sua essência, a programação funcional enfatiza modularidade e previsibilidade. Quebra-se uma tarefa complexa em partes menores. Cada uma destas partes menores vira uma função individual com input e output bem estabelecidos. Códigos escritos desta maneira também funcionam melhor com processamento paralelo, ou seja, há também um ganho de eficiência.\n\nVamos reconstruir todos os passos acima usando funções.\n\n# O mapa em funções\n\n## Shape da cidade\n\nPor conveniência, eu repito abaixo o código que se usou para chegar no shape dos limites territoriais do Recife. Note o que acontece: (1) o primeiro passo filtra um `data.frame` para encontrar o código do IBGE do respectivo município; (2) usando o código, a função `geobr::read_municipality()` importa o shape.\n\nHá dois objetos importantes nesta função: a tabela que contém as informações de 'nome da cidade' e 'código do ibge'; e o string com o 'nome da cidade'.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncode_muni = top200 |> \n  filter(name_muni == \"Recife\") |> \n  pull(code_muni)\n\nborder = geobr::read_municipality(code_muni)\n```\n:::\n\n\nPara transformar o código acima numa função, basta incluir estes objetos como argumentos. Como a tabela usada é sempre a mesma coloca-se o objeto `top200` dentro da função[^6].\n\n[^6]: Note que isto torna a função limitada, pois temos dados somente das 200 cidades mais populosas do Brasil. Outro fator importante é que estamos usando o nome da cidade como input. Se a tabela fosse expandida para incluir todas as cidades do Brasil seria necessário alterar o argumento pois há cidades com nome duplicado.\\\n    Este tipo de generalização está fora do escopo deste post.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_border = function(city) {\n  #> Filtra a tabela top200 e encontra o código do município\n  code_muni = top200 |> \n    dplyr::filter(name_muni == city) |> \n    dplyr::pull(code_muni)\n  #> Importa o shape do município\n  border = geobr::read_municipality(code_muni, showProgress = FALSE)\n  \n  return(border)\n  \n}\n```\n:::\n\n\nA função `get_border`, definida acima, possui um único argumento `city`, o nome da cidade, e retorna um único objeto, `border`, um spatial `data.frame` que contém o shapefile com os limites territoriais do município.\n\n## Principais vias\n\nO processo de transformar o código numa função consiste em entender quais são os elementos essenciais e circustanciais. No código abaixo o nome da cidade `\"Recife, Pernambuco, Brazil\"` é um elemento mutável enquanto `opq(bbox = getbb(…))` é a parte essencial. Similarmente, todos os comandos abaixo de `streets` são essenciais, mas o nome do objeto `rec` é inteiramente acidental.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Define os \"limites\" da busca. Monta um bounding box em torno do Recife\nrec = opq(bbox = getbb(\"Recife, Pernambuco, Brazil\"))\n\n#> Pega as principais vias\nstreets = add_osm_feature(\n  rec,\n  key = \"highway\",\n  value = c(\"primary\", \"secondary\", \"tertiary\", \"residential\")\n  )\n\n#> Converte o objeto para sf (LINESTRING)\nstreets = osmdata_sf(streets)\nstreets = streets$osm_lines\nstreets = select(streets, osm_id, name)\nstreets = st_transform(streets, crs = 4674)\n#> Encontra a intersecção entre as vias e os limites do município\nstreets_border = st_intersection(streets, border)\n```\n:::\n\n\nVamos dividir o código acima em duas etapas. Na primeira, vamos usar o nome da cidade para encontrar o nome do estado do município. Na segunda, vamos encontrar todas as ruas da cidade selecionada.\n\nA função `get_state` é bastante simples: ela filtra a tabela que contém as informações das cidades e encontra o nome do estado do município selecionado.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_state = function(city) {\n  top200 |> \n    dplyr::filter(name_muni == city) |> \n    dplyr::pull(name_state)\n}\n\nget_state(\"Recife\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Pernambuco\"\n```\n:::\n:::\n\n\nA função `get_streets` usa o nome da cidade e o shape dos limites territoriais (gerado pela função `get_border()`) para encontrar todas as vias contidas dentro da cidade. Note como a função `get_streets` chama a função `get_state`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_streets = function(city, border) {\n  \n  #> Encontra o nome da Unidade Federativa\n  nome_uf = get_state(city)\n  #> Monta o nome do local\n  name_place = stringr::str_glue(\"{city}, {nome_uf}, Brazil\")\n  #> Monta a query\n  place = osmdata::opq(bbox = osmdata::getbb(name_place))\n  \n  #> Importa todas as principais vias da cidade\n  streets = osmdata::add_osm_feature(\n    place,\n    key = \"highway\",\n    value = c(\"primary\", \"secondary\", \"tertiary\", \"residential\")\n    )\n  \n  #> Converte o dado\n  streets = streets %>%\n    osmdata::osmdata_sf() %>%\n    .$osm_lines %>%\n    dplyr::select(osm_id, name) %>%\n    sf::st_transform(crs = 4674)\n  \n  #> Enconrtra a intersecção entre as estradas e o limites do município\n  streets_border = sf::st_intersection(streets, border)\n  #> Retorna o objeto streets_border\n  return(streets_border)\n  \n}\n```\n:::\n\n\n## Altitude\n\nO código que encontra a altitude da cidade é muito similar ao código que encontra as principais vias. Neste caso, contudo, pode ser interessante manter controle sobre o argumento `z` da função `get_elev_raster`. Este argumento controla o nível de resolução da imagem de altitude que se importa.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\n#> Importa os dados de altitude\naltitude = elevatr::get_elev_raster(border, z = 9, clip = \"bbox\")\n#> Converte para 'vector'\nrec_alti = raster::rasterToPolygons(altitude)\nrec_alti = sf::st_as_sf(rec_alti)\nnames(rec_alti)[1] = \"elevation\"\n\n#> Converte o CRS e intersecta com os limites do município\nrec_alti = rec_alti %>%\n  st_transform(crs = 4674) %>%\n  st_intersection(border) %>%\n  #> Remove geometrias inválidas\n  filter(st_is_valid(.))\n```\n:::\n\n\nA função `get_elevation` utiliza o shape dos limites do município e retorna um spatial `data.frame` com o grid retangular que contém os dados de altitude do município. O argumento `z` controla o nível de resolução e varia de 1 a 14. Quanto maior, maior será a resolução (o \"zoom\" da imagem), ou seja, mais detalhado (e mais pesado) será o resultado.\n\nNa definição da função, deixa-se o valor padrão pré-definido em `z = 9`. Isto significa que o argumento pode ser omitido pelo usuário.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_elevation = function(border, z = 9) {\n  #> Importa os dados de altitude\n  altitude = elevatr::get_elev_raster(border, z = z, clip = \"bbox\")\n  #> Converte para 'vector'\n  altitude = raster::rasterToPolygons(altitude)\n  altitude = sf::st_as_sf(altitude)\n  names(altitude)[1] = \"elevation\"\n  \n  #> Converte o CRS e intersecta com os limites do município\n  altitude = sf::st_transform(altitude, crs = 4674)\n  altitude = suppressWarnings(sf::st_intersection(altitude, border))\n  altitude = dplyr::filter(altitude, sf::st_is_valid(altitude))\n  \n  return(altitude)\n  \n}\n```\n:::\n\n\n### Classificando\n\nPara classificar os dados utiliza-se o algoritmo de Jenks. As duas funções abaixo retornam esse agrupamento tomando um spatial `data.frame` como argumento principal. Eu adicionei alguns argumento adicionais que facilitam a escolha do número dos grupos e (opcionalmente) permite os limites dos grupos sejam arredondados para gerar número mais bonitos.\n\nA função `add_jenks_breaks` retorna uma lista com dois elementos: o primeiro elemento é o spatial `data.frame`, acrescido de uma coluna com o argupamento; o segundo elemento é um vetor `character` com a \"legenda\" do grupo, i.e., `\">50\", \"50-100\", …`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nadd_jenks_breaks = function(shp, k = 7, round = FALSE) {\n  #> Classifica os dados de altitude em k grupos segundo o algo. de Jenks\n  jbreaks = BAMMtools::getJenksBreaks(shp$elevation, k = k)\n  #> Arredonda os números para chegar numa legenda menos quebrada\n  if (round) {\n    jbreaks[1] = floor(jbreaks[1])\n    jbreaks[length(jbreaks)] = ceiling(jbreaks)\n    jbreaks[2:(length(jbreaks) - 1)] = round(jbreaks)\n  }\n  #> Cria a coluna 'jenks_group' que classifica cada valor num grupo\n  shp = shp |> \n    dplyr::mutate(\n      jenks_group = findInterval(elevation, jbreaks, rightmost.closed = TRUE),\n      jenks_group = factor(jenks_group, labels = get_jenks_labels(jbreaks))\n    )\n  \n  #> Verifica se todas as observações tem um grupo\n  check = any(is.na(shp$jenks_group))\n  if (check) {\n    warning(\"Some observations have failed to be grouped\")\n  }\n  \n  #> Transforma os groups em legendas\n  labels = get_jenks_labels(jbreaks)\n  \n  #> Retorna o output numa lista\n  out = list(shp = shp, labels = labels)\n  return(out)\n  \n}\n\nget_jenks_labels = function(x) {\n  labels = paste(x, x[-1], sep = \"–\")\n  labels[1] = paste(\"<\", x[2])\n  labels = labels[1:(length(labels) - 1)]\n  return(labels)\n}\n```\n:::\n\n\n## Juntando as partes\n\nO código que junta o grid de altitude com as ruas usava um `for-loop` em cada um dos grupos. Costuma ser relativamente simples substituir loops por funções. Transforma-se a essência do loop numa função e aplica-se a esta função no objeto usando alguma função `map_*` ou `lapply`. No exemplo abaixo, a parte essencial é o código que filtra o grid de alitutude e faz a sua intersecção com o shape das ruas.\n\nFunções têm algumas vantanges sobre loops. Para rodar um loop quase sempre é necessário criar objetos temporários, que vão armazenar os resultados parciais do loop. Além disso, loops costumam ser mais lentos do que funções rodando em paralelo[^7]. Loops mal construídos, em particular, podem ser bastante ineficientes.\n\n[^7]: Em geral, desde que o loop seja bem feito ele não será muito lento. Para consultar boas práticas de como fazer bons loops consulte [Best Coding Practices for R](https://bookdown.org/content/d1e53ac9-28ce-472f-bc2c-f499f18264a3/loops.html). Uma comparação recente da velocidade de loops no R está disponível em [On the performance of for loops in R](https://jmsallan.netlify.app/blog/2021-03-05-on-the-performance-of-for-loops-in-r/).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\n#> Cria uma lista para gravar os resultados\nstreets_altitude <- list()\n\n#> For-loop em todos os elementos de jgroups\nfor (i in seq_along(jgroups)) {\n\n  #> Seleciona um nível do grupo em particular  \n  group = levels(rec_alti$jenks_group)[[i]]\n  \n  #> Encontra o subconjunto de do grid de altitude que corresponde a este grupo\n  poly = rec_alti %>%\n    filter(jenks_group == group) %>%\n    st_union(.) %>%\n    st_as_sf()\n  #> Faz a interseção deste subconjunto com as vias da cidade\n  joined = streets %>%\n    st_intersection(poly) %>%\n    filter(st_is_valid(.)) %>%\n    mutate(level = factor(i))\n  #> Grava o resultado como elemento da lista streets_altitude\n  streets_altitude[[i]] <- joined\n  \n}\n\nrec_streets_altitude <- bind_rows(streets_altitude)\n```\n:::\n\n\nA função `get_street_altitude` abaixo pega o grid de altitude da cidade e o shape das principais vias e retorna um spatial `data.frame` único que contém as ruas da cidade agrupadas pela sua altura.\n\nNesta função, define-se uma função \"auxiliar\" `join_streets` que existe somente dentro do contexto da função `get_streets_altitude`. Aplica-se esta função em paralelo usando `furrr::future_map`[^8].\n\n[^8]: Alternativamente, pode-se usar `parallel::mclapply`, mas esta função, infelizmente só funciona em sistemas MacOs e Linux.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_streets_altitude = function(altitude, streets) {\n  \n  stopifnot(any(colnames(altitude) %in% \"jenks_group\"))\n  \n  #> Encontra todos os grupos\n  groups = levels(altitude$jenks_group)\n  \n  #> Define uma função auxiliar\n\n  #> Esta função filtra o grid de altitude e faz a sua interseção\n  #> com o shape das princiapis vias\n  join_streets = function(group) {\n    \n    poly = altitude %>%\n      dplyr::filter(jenks_group == group) %>%\n      sf::st_union(.) %>%\n      sf::st_as_sf() %>%\n      sf::st_make_valid()\n    \n    joined = suppressWarnings(sf::st_intersection(streets, poly))\n    \n    return(joined)\n    \n  }\n  #> Aplica a função acima em todos os grupos em paralelo\n  street_levels = furrr::future_map(groups, join_streets)\n  #> \"Empilha\" o objeto num único spatial data.frame\n  out = dplyr::bind_rows(street_levels, .id = \"level\")\n  \n  return(out)\n  \n}\n```\n:::\n\n\n## Mapa\n\nTransformar o mapa final numa função é bastante simples já que quase todos os argumentos das funções vão continuar exatamente iguais. A única diferença importante a se notar é na escolha da paleta de cores. Como o número de grupos de altitude pode mudar, faz sentido que a paleta de cores também se altere. Além disso, adiciono também uma opção de usar a fonte Roboto Condensed com o pacote showtext.\n\nNote que suprimo o uso de `ggplot2::` para deixar o código menos carregado.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap_plot = function(shp, labels, title, showtext = TRUE) {\n  \n  cores = viridis::plasma(n = length(labels) + 1)\n  cores = cores[-length(cores)]\n  \n  font = ifelse(showtext == TRUE, \"Roboto Condensed\", \"sans\")\n  \n  plot =\n    ggplot(data = shp) +\n    geom_sf(aes(color = level, fill = level), linewidth = 0.2) +\n    scale_color_manual(\n      name = \"Altitude\",\n      labels = labels,\n      values = cores\n      ) +\n    scale_fill_manual(\n      name = \"Altitude\",\n      labels = labels,\n      values = cores\n      ) +\n    guides(fill = guide_legend(nrow = 1), color = guide_legend(nrow = 1)) +\n    ggtitle(title) +\n    ggthemes::theme_map() +\n    coord_sf() +\n    theme(\n      plot.title = element_text(\n        size = 30,\n        hjust = 0.5,\n        family = font\n        ),\n      legend.title = element_text(\n        size = 20,\n        family = font,\n        color = \"gray10\"\n      ),\n      legend.text = element_text(\n        size = 14,\n        family = font,\n        color = \"gray10\"\n        ),\n      legend.position = \"top\",\n      legend.direction = \"horizontal\",\n      plot.background = element_rect(color = NA, fill = \"#f6eee3\"),\n      panel.background = element_rect(color = NA, fill = \"#f6eee3\"),\n      legend.background = element_rect(color = NA, fill = \"#f6eee3\")\n    )\n  \n  return(plot)\n  \n}\n\n#> Para adicionar a fonte\n# sysfonts::font_add_google(\"Roboto Condensed\", \"Roboto Condensed\")\n# showtext::showtext_auto()\n```\n:::\n\n\n## Uma função final\n\nAgora que temos funções para cada uma das principais tarefas, podemos criar uma última função que vai executar estas funções na ordem apropriada.\n\nA função `map_altitude` utiliza apenas o nome da cidade para gerar o mapa de altitude. Opcionalmente, pode-se alterar os argumentos `k`, que altera o número de grupos e `z` que aumenta/diminui a resolução do mapa de altura.\n\nComo esta função executa vários passos intermediários, e alguns destes podem ser bastante demorados, eu incluo algumas mensagens que informam sobre o andamento da função. O resultado final é armazenado numa lista, que retorna alguns dos objetos intermediários como o shape de altitude.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap_altitude = function(city, k = 6, z = 7) {\n  \n  #> Importa o shape do limite do município\n  message(\"Importando os limites do município: \", city)\n  city_border = get_border(city)\n  #> Importa as principais vias da cidade e junta com o limite do muni\n  message(\"Importando as vias.\")\n  city_street = get_streets(city, city_border)\n  #> Importa a altitude da cidade\n  message(\"Importando a altitude.\")\n  city_elevation = suppressMessages(get_elevation(city_border, z = z))\n  #> Classifica a altitude em grupos\n  message(\"Classificando e juntando os shapefiles.\")\n  jenks = add_jenks_breaks(city_elevation, k = k)\n  city_elevation = jenks[[\"shp\"]]\n  labels = jenks[[\"labels\"]]\n  #> Junta a altitude (agrupada) com as vias\n  city_street_elevation = get_streets_altitude(city_elevation, city_street)\n  \n  #> Monta o mapa final\n  message(\"Gerando o mapa final.\")\n  plot = map_plot(city_street_elevation, labels = labels, title = city)\n  message(\"Feito.\")\n  #> Retorna o output numa lista\n  out = list(\n    shp = city_street_elevation,\n    streets = city_street,\n    elevation = city_elevation,\n    plot = plot\n    )\n  \n  return(out)\n  \n}\n```\n:::\n\n\n## Testando a função\n\nFeito tudo isto. Agora podemos testar a função com outras cidades.\n\n### São Caetano do Sul\n\nSão Caetano do Sul é uma boa cidade teste, porque ela é bem pequena então os resultados não demoram tanto para carregar.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nscs = map_altitude(\"São Caetano Do Sul\", k = 4, z = 8)\nscs$plot\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-38-1.png){fig-align='center' width=100% height=100%}\n:::\n:::\n\n\nOs demais mapas gerados foram feitos em resolução bastante elevada, então os códigos podem demorar várias horas para executar. Recomendo começar testando com valores menores de `z`. Mesmo em alta resolução, há melhorias possíveis nos gráficos como mudanças no \"enquadramento\" do mapa e também na escolha das quebras da legenda. Ainda assim, o resultado é muito bom.\n\n### Fortaleza\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfortaleza = map_altitude(\"Fortaleza\", z = 13)\nfortaleza$plot\n```\n:::\n\n\n![](/static/maps/elevation_xx_fortaleza.svg){fig-align=\"center\"}\n\n### Osasco\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nosa <- map_altitude(\"Osasco\", k = 7, z = 12)\nosa$plot\n```\n:::\n\n\n![](/static/maps/elevation_xx_osasco.svg){fig-align=\"center\"}\n\n### Belo Horizonte\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap_altitude(\"Belo Horizonte\", k = 7, z = 13)$plot\n```\n:::\n\n\n![](/static/maps/elevation_xx_belo_horizonte.svg){fig-align=\"center\"}\n\n### Porto Alegre\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap_altitude(\"Porto Alegre\", k = 6, z = 13)\n```\n:::\n\n\n![](/static/maps/elevation_xx_porto_alegre.svg){fig-align=\"center\"}\n\n### Curitiba\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap_altitude(\"Curitiba\", k = 8, z = 11)\n```\n:::\n\n\n![](/static/maps/elevation_xx_curitiba.svg){fig-align=\"center\"}\n\n### Brasília\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap_altitude(\"Brasília\", k = 7, z = 11)\n```\n:::\n\n\n![](/posts/general-posts/2023-09-brasilia/images/elevation_brasilia.svg){fig-align=\"center\"}\n\n# Concluindo\n\nFunções são elementos fundamentais na linguagem `R`. De fato, *pacotes* nada mais são do que *famílias de funções*, que dividem algum objetivo em comum. E o `R`, grosso modo, é um grande repositório de pacotes, que são chamados para executar alguma tarefa. Pode levar algum tempo para se acostumar a pensar e a escrever código desta maneira, mas os ganhos são tremendos.\n\nFunções permitem **escalar e automatizar o seu trabalho**, diminuem a quantidade de erros no seu código e facilitam a sua vida no longo prazo. Não se enfatizou muito os ganhos de eficiência de usar processamento paralelo neste post; contudo, depois que se cria funções é relativamente simples implementar elas com **processamento paralelo**.\n\nBoas funções são modulares: pode-se **reutilizar elas em outros projetos ou mesmo em novos pacotes**. A reutilização destas funções, naturalmente, vai expondo as suas fragilidades e fomenta um *mindset* de melhorias incrementais. No post, criamos uma função que gera um mapa com a altitude das vias numa cidade. Esta função pode ser melhorada de diversas maneiras:\n\n1.  Permitir que se crie o mapa de qualquer cidade do Brasil.\n2.  Permitir que se troque a paleta de cores.\n3.  Permitir que se defina as quebras dos grupos manualmente.\n4.  Permitir que se faça um \"zoom\" de certa área numa cidade.\n\nVale notar, por fim, que **funções costumam ser abstrações de um código previamente construído**. Não é fácil simplesmente começar a escrever uma função que importa e limpa uma base de dados, sem antes explorar esta base, por tentativa e erro. É importante ganhar intuição, da mesma maneira como fizemos neste post, mapeando somente uma cidade em particular. Assim, é melhor começar resolvendo um, dois ou até três casos particulares antes de tentar generalizar o processo numa função.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../../site_libs/htmlwidgets-1.6.2/htmlwidgets.js\"></script>\n<link href=\"../../../site_libs/datatables-css-0.0.0/datatables-crosstalk.css\" rel=\"stylesheet\" />\n<script src=\"../../../site_libs/datatables-binding-0.28/datatables.js\"></script>\n<script src=\"../../../site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"../../../site_libs/dt-core-1.13.4/css/jquery.dataTables.min.css\" rel=\"stylesheet\" />\n<link href=\"../../../site_libs/dt-core-1.13.4/css/jquery.dataTables.extra.css\" rel=\"stylesheet\" />\n<script src=\"../../../site_libs/dt-core-1.13.4/js/jquery.dataTables.min.js\"></script>\n<link href=\"../../../site_libs/crosstalk-1.2.0/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"../../../site_libs/crosstalk-1.2.0/js/crosstalk.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}