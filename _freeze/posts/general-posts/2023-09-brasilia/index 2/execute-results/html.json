{
  "hash": "2d125208dc15bfc9012b3808e591039d",
  "result": {
    "markdown": "---\ntitle: \"Mapa de altitude de ruas de Brasília\"\ncategories: ['data-visualization', 'mapas']\ndate: \"2023-09-03\"\n---\n\n\nInspirado num antigo post de [BlakeRMills](https://www.blakerobertmills.com/my-work/visualizations), criador do pacote [{MetBrewer}](https://github.com/BlakeRMills/MetBrewer), criei um mapa com a altitude das ruas em Brasília.\n\nEm breve farei um post com tutorial detalhado e também pretendo replicar este tipo de mapa para outras cidades interessantes. O código para replicar o gráfico está abaixo.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(dplyr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(osmdata)\nlibrary(purrr)\nsf::sf_use_s2(FALSE)\nsysfonts::font_add_google(\"Roboto Condensed\", \"Roboto Condensed\")\nshowtext::showtext_auto()\n\nurl = \"https://pt.wikipedia.org/wiki/Lista_de_municípios_do_Brasil_por_população\"\n\ntab = xml2::read_html(url) |> \n  rvest::html_table() |> \n  purrr::pluck(2)\n\nas_numeric_char = Vectorize(function(x) {\n  ls = stringr::str_extract_all(x, \"[[:digit:]]\")\n  y = paste(ls[[1]], collapse = \"\")\n  as.numeric(y)\n})\n\nclean_tab = tab |> \n  janitor::clean_names() |> \n  rename(\n    code_muni = codigo_ibge,\n    name_muni = municipio,\n    rank = posicao,\n    name_state = unidade_federativa,\n    pop = populacao\n  ) |> \n  filter(name_muni != \"Brasil\") |> \n  mutate(\n    code_muni = as.numeric(code_muni),\n    pop = as_numeric_char(pop),\n    rank = rank(-pop)\n  )\n\ntop20 = slice_max(clean_tab, pop, n = 20)\n\nget_border = function(city) {\n  \n  #> Encontra o código do município\n  code_muni = top20 |> \n    filter(name_muni == city) |> \n    pull(code_muni) |> \n    unique()\n  \n  stopifnot(length(code_muni) == 1)\n  \n  #> Baixa o shapefile do município\n  border = geobr::read_municipality(code_muni, showProgress = FALSE)\n  \n  return(border)\n}\n\nget_streets = function(city, border) {\n  \n  #> Encontra o nome da Unidade Federativa\n  nome_uf = top20 |> \n    filter(name_muni == city) |> \n    pull(name_state)\n  #> Monta o nome do local\n  name_place = stringr::str_glue(\"{city}, {nome_uf}, Brazil\")\n  #> Monta a query\n  place = opq(bbox = getbb(name_place))\n  \n  #> Importa todas as principais vias da cidade\n  # streets = add_osm_feature(\n  #   place,\n  #   key = \"highway\",\n  #   value = c(\n  #     \"motorway\", \"primary\", \"motorway_link\", \"primary_link\",\n  #     \"secondary\", \"tertiary\", \"secondary_link\", \"tertiary_link\",\n  #     \"residential\"\n  #     )\n  # )\n  \n  streets = add_osm_feature(place, key = \"highway\")\n  \n  #> Converte o dado\n  streets = streets %>%\n    osmdata_sf() %>%\n    .$osm_lines %>%\n    select(osm_id, name) %>%\n    st_transform(crs = 4674)\n  \n  #> Enconrtra a intersecção entre as estradas e o limites do município\n  streets_border = st_intersection(streets, border)\n  \n  # out = list(streets = streets, streets_border = streets_border)\n  \n  return(streets_border)\n  \n}\n\nget_elevation = function(border, z = 8) {\n  \n  altitude = elevatr::get_elev_raster(border, z = z, clip = \"bbox\")\n  altitude = raster::rasterToPolygons(altitude)\n  altitude = st_as_sf(altitude)\n  names(altitude)[1] = \"elevation\"\n  \n  altitude = st_transform(altitude, crs = 4674)\n  altitude = suppressWarnings(st_intersection(altitude, border))\n  altitude = filter(altitude, st_is_valid(altitude))\n  \n  return(altitude)\n  \n}\n\nadd_jenks_breaks = function(shp, k = 7, round = TRUE, r = 0) {\n  #> Classifica os dados de altitude em k grupos segundo o algo. de Jenks\n  jbreaks = BAMMtools::getJenksBreaks(shp$elevation, k = k)\n  #> Arredonda os números para chegar numa legenda menos quebrada\n  if (round) {\n    jbreaks = round(jbreaks, r)\n  }\n  #> Cria a coluna 'jenks_group' que classifica cada valor num grupo\n  shp = mutate(shp, jenks_group = cut(elevation, jbreaks))\n  \n  #> Verifica se todas as observações tem um grupo\n  check = any(is.na(shp$jenks_group))\n  if (check) {\n    warning(\"Some observations have failed to be grouped\")\n  }\n  \n  #> Transforma os groups em legendas\n  labels = get_jenks_labels(jbreaks)\n  \n  #> Retorna o output numa lista\n  out = list(shp = shp, labels = labels)\n  return(out)\n  \n}\n\nget_jenks_labels = function(x) {\n  labels = paste(x, x[-1], sep = \"–\")\n  labels[1] = paste(\"<\", x[2])\n  labels[length(labels)] = paste(\">\", max(x))\n  return(labels)\n}\n\nget_streets_altitude = function(altitude, streets) {\n  \n  stopifnot(any(colnames(altitude) %in% \"jenks_group\"))\n  \n  #> Get all groups\n  groups = levels(altitude$jenks_group)\n  \n  #> For each group get the full polygon and join with streets\n  join_streets = function(group) {\n    \n    poly = altitude %>%\n      filter(jenks_group == group) %>%\n      st_union(.) %>%\n      st_as_sf() %>%\n      st_make_valid()\n    \n    joined = suppressWarnings(st_intersection(streets, poly))\n    \n    return(joined)\n    \n  }\n  #> Apply the function to all groups\n  street_levels = purrr::map(groups, join_streets)\n  #> Bind all results together\n  out = bind_rows(street_levels, .id = \"level\")\n  \n  return(out)\n  \n}\n\nmap_plot = function(shp, labels, title, showtext = TRUE) {\n  \n  colors = viridis::plasma(n = length(labels) + 1)\n  colors = colors[-length(colors)]\n  \n  font = ifelse(showtext == TRUE, \"Roboto Condensed\", \"sans\")\n  \n  plot =\n    ggplot(data = shp) +\n    geom_sf(aes(color = level, fill = level), linewidth = 0.2) +\n    scale_color_manual(\n      name = \"Altitude\",\n      labels = labels,\n      values = colors) +\n    scale_fill_manual(\n      name = \"Altitude\",\n      labels = labels,\n      values = colors) +\n    guides(fill = guide_legend(nrow = 1), color = guide_legend(nrow = 1)) +\n    ggtitle(title) +\n    ggthemes::theme_map() +\n    coord_sf() +\n    theme(\n      plot.title = element_text(\n        size = 30,\n        hjust = 0.5,\n        family = font\n      ),\n      legend.title = element_text(\n        size = 20,\n        family = font,\n        color = \"gray10\"\n      ),\n      legend.text = element_text(\n        size = 14,\n        family = font,\n        color = \"gray10\"\n      ),\n      legend.position = \"top\",\n      legend.direction = \"horizontal\",\n      plot.background = element_rect(color = NA, fill = \"#f6eee3\"),\n      panel.background = element_rect(color = NA, fill = \"#f6eee3\"),\n      legend.background = element_rect(color = NA, fill = \"#f6eee3\")\n    )\n  \n  return(plot)\n  \n}\n\nmap_altitude = function(city, k, z) {\n  \n  #> Importa o shape do limite do município\n  message(\"Importando os limites do município: \", city)\n  city_border = get_border(city)\n  #> Importa as principais vias da cidade e junta com o limite do muni\n  message(\"Importando as vias.\")\n  city_street = get_streets(city, city_border)\n  #> Importa a altitude da cidade\n  message(\"Importando a altitude.\")\n  city_elevation = suppressMessages(get_elevation(city_border, z = z))\n  #> Classifica a altitude em grupos\n  message(\"Classificando e juntando os shapefiles.\")\n  jenks = add_jenks_breaks(city_elevation, k = k)\n  city_elevation = jenks[[\"shp\"]]\n  labels = jenks[[\"labels\"]]\n  #> Junta a altitude (agrupada) com as vias\n  city_street_elevation = get_streets_altitude(city_elevation, city_street)\n  \n  #> Monta o mapa final\n  message(\"Gerando o mapa final.\")\n  plot = map_plot(city_street_elevation, labels = labels, title = city)\n  message(\"Feito.\")\n  #> Retorna o output numa lista\n  out = list(\n    shp = city_street_elevation,\n    streets = city_street,\n    elevation = city_elevation,\n    plot = plot\n  )\n  \n  return(out)\n  \n}\n\nexport_citymap = function(city, w = 14, h = 16, ...) {\n  \n  plot = map_altitude(city, ...)$plot\n  \n  if (is.numeric(city)) {\n    name_city = cities_brasil |> \n      filter(code_muni == city) |> \n      pull(name_muni)\n  } else if (is.character(city)) {\n    name_city = city\n  }\n  \n  name_file = glue::glue(\n    \"elevation_{janitor::make_clean_names(name_city)}.svg\"\n  )\n  \n  ggsave(\n    here::here(\"graphics/altitude\", name_file),\n    plot,\n    width = w,\n    height = h\n  )\n  \n  name_file = glue::glue(\n    \"elevation_{janitor::make_clean_names(name_city)}.png\"\n  )\n  \n  ggsave(\n    here::here(\"graphics/altitude\", name_file),\n    plot,\n    width = w,\n    height = h\n  )\n}\n\nsafe_export = purrr::safely(export_citymap)\n\nparams = tribble(\n  ~city,       ~z, ~k,\n  #----------------#---#---#\n  \"São Paulo\",       8,  7,\n  \"Rio de Janeiro\",  9,  7,\n  \"Brasília\",        8,  7,\n  \"Fortaleza\",      11,  7,\n  \"Salvador\",       10,  7,\n  \"Belo Horizonte\", 10,  7,\n  \"Manaus\",          6,  7,\n  \"Curitiba\",       10,  7,\n  \"Recife\",         10,  7,\n  \"Goiânia\",         8,  7,\n  \"Porto Alegre\",    8,  7,\n  \"Belém\",           9,  7,\n  \"Guarulhos\",       9,  7,\n  \"Campinas\",        9,  7,\n  \"São Luís\",        9,  7,\n  \"Maceió\",         11,  8,\n  \"Campo Grande\",    7,  7,\n  \"São Gonçalo\",     8,  7,\n  \"Teresina\",        10,  7,\n  \"João Pessoa\",     9,  7,\n  \"Joinville\",       9,  7\n  )\n\n#> Exportar todas as cidades listadas acima\n#pmap(params, safe_export)\n#> Exportar uma cidade em particular\n#safe_export(\"Brasília\", z = 8, k = 7)\n```\n:::\n\n\n![](images/elevation_brasilia.svg){fig-align=\"center\"}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}