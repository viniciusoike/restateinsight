{
  "hash": "0e555670c69ba7875ee2115f3d242c80",
  "result": {
    "markdown": "---\ntitle: \"O novo tidyverse: mutate\"\ndate: \"2024-01-21\"\ncategories: ['data-science', 'tutorial-R', 'tidyverse']\ndescription: \"Neste post ensino abordagens diferentes para criar colunas de maneira eficiente. Apresento também as novidades que o `dplyr` trouxe nos últimos anos como a função `across` e novo argumento `.by`.\"\nimage: \"/static/images/dplyr_logo.png\" \nimage-alt: \"/static/images/dplyr_logo.png\"\nexecute: \n  eval: false\n  message: false\n  warning: false\n---\n\n\n\n\n# Tidyverse\n\nO tidyverse é uma coleção poderosa de pacotes, voltados para a manipulação e limpeza de dados. Num outro post, discuti alguns [aspectos gerais da filosofia](https://restateinsight.com/posts/general-posts/2023-09-tidyverse/) destes pacotes que incluem a sua consistência sintática e o uso de [pipes](https://restateinsight.com/posts/general-posts/2023-09-pipes-in-r/). A filosofia geral do tidyverse toma muito emprestado da gramática. As funções têm nomes de verbos que costumam ser intuitivos e são encadeados via \"pipes\" que funcionam como conectivos numa frase. Em tese, isto torna o código mais legível e até mais didático.\n\nO tidyverse está em constante expansão, novas funcionalidades são criadas para melhorar a performance e capabilidade de suas funções. Assim, é importante atualizar nosso conhecimento destes pacotes periodicamente. Nesta série de posts vou focar nas funções principais dos pacotes `dplyr` e `tidyr`, voltados para a limpeza de dados.\n\n# Alguns verbos\n\nEssencialmente, o `dplyr` gira em torno de quatro grandes funções: `filter`, `select`, `mutate` e `summarise`. Estas funções fazem o grosso do trabalho de limpeza de dados: filtram linhas, selecionam colunas e transformam os dados. A tabela abaixo resume as principais funções do pacote.\n\n| Nome da Função | Tradução          | O que faz                                                         |\n|----------------|----------------|----------------------------------------|\n| `rename`       | Renomear          | Modifica o nome das colunas.                                      |\n| `select`       | Selecionar        | Seleciona as colunas.                                             |\n| `filter`       | Filtrar           | Filtra/seleciona as linhas segundo alguma condição.               |\n| `arrange`      | Arranjar/ordenar  | Ordena as linhas (crescente/decrescente) segundo alguma variável. |\n| `mutate`       | Mutar/transformar | Cria uma nova coluna a partir de outras colunas ou dados.         |\n| `summarise`    | Sumarizar/resumir | Aplica alguma função sobre as linhas. Cria uma tabela \"resumo\".   |\n| `group_by`     | Agrupar           | Agrupa as linhas segundo alguma variável.                         |\n\n# mutate\n\n## O básico\n\nOs pacotes utilizados neste tutorial são listados abaixo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(readr)\n```\n:::\n\n\nPara praticar as funções vamos utilizar uma tabela que traz informações sobre as cidades do Brasil.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl <- readr::read_csv(\n  \"https://github.com/viniciusoike/restateinsight/raw/main/static/data/cities_brazil.csv\"\n  )\n```\n:::\n\n\nA função mutate serve para criar novas colunas a partir de colunas pré-existentes. Ela segue a seguinte sintaxe:\n\n``` r\nmutate(coluna_nova = f(coluna_velha))\n```\n\nonde `f()` designa algum transformação que é feita sobre os dados antigos. Em geral, esta transformação é alguma operação matemática (`+`, `-`, `log`, etc.), transformação de classe (e.g. `as.numeric`), ou função em geral. Abaixo mostra-se alguns exemplos de transformações simples. Como as saídas ocupam muito espaço, vou omiti-las.\n\nA primeira linha cria uma coluna onde todas as entradas são iguais a 1. O segundo exemplo aplica a função `log` sobre a variável `pib`. O terceiro exemplo divide a coluna `household` por um milhão. Por fim, o quarto exemplo mostra como dropar uma coluna usando a função `mutate`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Cria uma coluna onde todas as entradas são iguais a 1\nmutate(tbl, id = 1)\n#> Cria a coluna 'lpib' igual ao logaritmo natural do 'pib'\nmutate(tbl, lpib = log(pib))\n#> Cria a coluna hh igual a 'household' dividido por 1 milhão\nmutate(tbl, hh = household / 1e6)\n#> Dropa a coluna pib\nmutate(tbl, pib = NULL)\n```\n:::\n\n\nVale notar que, assim como a função `filter` é mais eficiente juntar todas as operações dentro de um único `mutate`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl |> \n  mutate(\n    id = 1,\n    lpib = log(pib),\n    hh = household / 1e6,\n    pib = NULL\n  )\n```\n:::\n\n\nUm fato conveniente da função `mutate` é que ela vai criando as colunas sequencialmente, assim é possível fazer diversas transformações numa mesma chamada à função. No caso abaixo, pode-se criar a variável `lpibpc` a partir das colunas `lpib` e `lpop`; similarmente, pode-se criar a coluna `lpibs` a partir de `pibserv`, que é a soma de `pib_services` e `pib_govmt_services`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl |> \n  mutate(\n    lpib = log(pib),\n    lpop = log(population),\n    #> Criando uma variável a partir de duas colunas criadas anteriormente\n    lpibpc = lpib - lpop,\n    pibserv = pib_services + pib_govmt_services,\n    #> Criando uma variável a partir de duas colunas criadas anteriormente\n    lpibs = log(pibserv)\n  )\n```\n:::\n\n\n## Grupos\n\nA expressão `mutate` sempre é aplicada dentro de grupos. No caso em que não existe um grupo, a expressão é aplicada para todos os dados disponíveis. O código abaixo, por exemplo, encontra a participação percentual do PIB de cada município no PIB brasileiro.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl |> \n  select(name_muni, abbrev_state, pib) |> \n  mutate(pib_share = pib / sum(pib) * 100) |> \n  arrange(desc(pib_share))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5,570 × 4\n   name_muni      abbrev_state       pib pib_share\n   <chr>          <chr>            <dbl>     <dbl>\n 1 São Paulo      SP           748759007     9.84 \n 2 Rio de Janeiro RJ           331279902     4.35 \n 3 Brasília       DF           265847334     3.49 \n 4 Belo Horizonte MG            97509893     1.28 \n 5 Manaus         AM            91768773     1.21 \n 6 Curitiba       PR            88308728     1.16 \n 7 Osasco         SP            76311814     1.00 \n 8 Porto Alegre   RS            76074563     1.00 \n 9 Guarulhos      SP            65849311     0.865\n10 Campinas       SP            65419717     0.860\n# ℹ 5,560 more rows\n```\n:::\n:::\n\n\nJá este segundo código encontra a participação percentual do PIB de cada município dentro do seu respectivo estado.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl |> \n  select(name_muni, abbrev_state, pib) |> \n  mutate(pib_share = pib / sum(pib) * 100, .by = \"abbrev_state\") |> \n  arrange(desc(pib_share))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5,570 × 4\n   name_muni      abbrev_state       pib pib_share\n   <chr>          <chr>            <dbl>     <dbl>\n 1 Brasília       DF           265847334     100  \n 2 Manaus         AM            91768773      79.1\n 3 Boa Vista      RR            11826207      73.8\n 4 Macapá         AP            11735557      63.5\n 5 Rio Branco     AC             9579592      58.1\n 6 Rio de Janeiro RJ           331279902      43.9\n 7 Fortaleza      CE            65160893      39.0\n 8 Teresina       PI            21578875      38.3\n 9 Porto Velho    RO            19448762      37.7\n10 Aracaju        SE            16447105      36.2\n# ℹ 5,560 more rows\n```\n:::\n:::\n\n\nVale notar que a sintaxe `.by = \"coluna\"` é nova e ainda está em fase experimental. Ela substitui a sintaxe mais antiga do `group_by`. O código acima é equivalente ao código abaixo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl |> \n  select(name_muni, abbrev_state, pib) |> \n  group_by(abbre_state) |> \n  mutate(pib_share = pib / sum(pib) * 100) |> \n  ungroup()\n```\n:::\n\n\nUma das vantagens de usar `.by` é que não é necessário usar `ungroup` já que os dados são desagrupados automaticamente.\n\n## Transformando múltiplas colunas\n\nA função `mutate` tem um par importante na função `across`, que permite aplicar uma mesma função a múltiplas colunas com facilidade. Imagine o seguinte caso, onde quer-se aplicar a função `scale`, que serve para \"normalizar\" vetores numéricos, em todas as colunas de uma base. Tipicamente, seria necessário escrever e nomear cada coluna\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl |> \n  mutate(\n    scaled_pib = scale(pib),\n    scaled_pop = scale(population),\n    scaled_agriculture = scale(pib_agriculture),\n    scaled_industrial = scale(pib_industrial),\n    ...\n  )\n```\n:::\n\n\nEm linhas gerais, o resultado do código acima pode ser replicado simplesmente com:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl |> \n  mutate(\n    across(where(is.numeric), scale)\n  )\n```\n:::\n\n\nA função `across` serve para aplicar uma função sobre um subconjunto de colunas seguindo: `across(colunas, funcao)`. Ela funciona com os `tidyselectors`, facilitando a seleção de colunas a ser transformadas. Funções mais complexas podem ser utilizadas via função anônima usando o operador `~`.\n\nO primeiro exemplo abaixo mostra como aplicar a função `log` em todas as colunas cujo nome começa com `pib`. Já o segundo exemplo mostra como converter todas as colunas do tipo `character` para `factor`. O terceiro exemplo mostra como converter as colunas de `factor` para `numeric` utilizando o operador `~`. Os últimos dois exemplos mostram outras aplicações do mesmo operador.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Aplica uma transformação log em todas as colunas que começam com pib\nmutate(tbl, across(starts_with(\"pib\"), log))\n#> Converte todas as colunas de strings para factors\nmutate(tbl, across(where(is.character), as.factor))\n#> Converte as colunas de factors para numeric\nmutate(tbl, across(where(is.factor), ~ as.numeric(as.character(.x))))\n#> Divide por pib e multiplica por 100 todas as colunas entre pib_taxes e\n#> pib_govmt_services\nmutate(tbl, across(pib_taxes:pib_govmt_services, ~.x / pib * 100))\n#> Normaliza todas as colunas numéricas\nmutate(tbl, across(where(is.numeric), ~ as.numeric(scale(.x))))\n```\n:::\n\n\nPor fim, existe um argumento opcional `.names` que permite renomear as novas colunas usando uma sintaxe estilo `glue`[^1]. Esta sintaxe tem dois tipos especiais importantes: `{.col}`, que faz referência ao nome original da coluna, e `{.fn}`, que faz referência ao nome da função utilizada. O exemplo abaixo refina o primeiro caso que vimos acima. Agora aplica-se a função `as.numeric(scale(x))` sobre cada uma das colunas numéricas. As novas colunas têm o nome `\"scaled_NomeOriginalDaColuna\"`.\n\n[^1]: Do pacote `glue`. [Veja mais aqui](https://glue.tidyverse.org).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl |> \n  mutate(\n    across(\n      where(is.numeric),\n      ~ as.numeric(scale(.x)),\n      .names = \"scaled_{.col}\"\n      )\n  )\n```\n:::\n\n\nO tipo especial `{.fn}` é bastante útil com a função `summarise`, que permite aplicar uma lista de múltiplas funções simultaneamente. Ainda assim, é possível utilizá-lo com a função `mutate`. A sintaxe tem de ser adaptada, pois `{.fn}` espera que a função tenha sido passada como uma lista com nomes. No exemplo abaixo, aplica-se a função `log` sobre todas as colunas númericas e as colunas resultantes são renomeadas. Vale notar que, na maioria dos casos, não vale a pena utilizar `{.fn}` no contexto do `mutate`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl |> \n  mutate(\n    across(\n      where(is.numeric),\n      list(\"ln\" = log),\n      .names = \"{.fn}_{.col}\"\n      )\n  )\n```\n:::\n\n\n## Outros argumentos\n\nA função `mutate` tem alguns outros argumentos, de uso diverso. Os argumentos `.before` e `.after` permitem selecionar a posição das novas colunas. O padrão da função é de sempre adicionar as novas colunas ao final do `data.frame`. Estes argumentos aceitam o nome de alguma das colunas ou mesmo funções tidyselect. No caso abaixo, cria-se a coluna `lpib` que é posta no início do `data.frame`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl |> \n  mutate(\n    lpib = log(pib),\n    .before = everything()\n  ) |> \n  select(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5,570 × 5\n    lpib code_muni name_muni             code_state name_state\n   <dbl>     <dbl> <chr>                      <dbl> <chr>     \n 1  13.3   1100015 Alta Floresta D'Oeste         11 Rondônia  \n 2  14.9   1100023 Ariquemes                     11 Rondônia  \n 3  12.0   1100031 Cabixi                        11 Rondônia  \n 4  14.7   1100049 Cacoal                        11 Rondônia  \n 5  13.3   1100056 Cerejeiras                    11 Rondônia  \n 6  12.8   1100064 Colorado do Oeste             11 Rondônia  \n 7  12.5   1100072 Corumbiara                    11 Rondônia  \n 8  12.5   1100080 Costa Marques                 11 Rondônia  \n 9  13.4   1100098 Espigão D'Oeste               11 Rondônia  \n10  13.8   1100106 Guajará-Mirim                 11 Rondônia  \n# ℹ 5,560 more rows\n```\n:::\n:::\n\n\nO outro argumento opcional é o `.keep` que permite controlar quais colunas devem ser preservadas após a aplicação da função `mutate`. O padrão da função, naturalmente, é de preservar todas as colunas, isto é, `.keep = \"all\"`. Contudo, pode-se usar `.keep = \"used\"` para manter somente as colunas que foram utilizadas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl |> \n  mutate(\n    code_muni = as.character(code_muni),\n    lpib = log(pib),\n    .keep = \"used\"\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5,570 × 3\n   code_muni     pib  lpib\n   <chr>       <dbl> <dbl>\n 1 1100015    570272  13.3\n 2 1100023   2818049  14.9\n 3 1100031    167190  12.0\n 4 1100049   2519353  14.7\n 5 1100056    600670  13.3\n 6 1100064    366931  12.8\n 7 1100072    268381  12.5\n 8 1100080    261978  12.5\n 9 1100098    666331  13.4\n10 1100106    984586  13.8\n# ℹ 5,560 more rows\n```\n:::\n:::\n\n\nVale notar que `.keep = \"used\"` sempre preserva as colunas \"agrupadoras\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl |> \n  mutate(\n    code_muni = as.character(code_muni),\n    lpib = log(pib),\n    .by = \"code_state\",\n    .keep = \"used\"\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5,570 × 4\n   code_muni code_state     pib  lpib\n   <chr>          <dbl>   <dbl> <dbl>\n 1 1100015           11  570272  13.3\n 2 1100023           11 2818049  14.9\n 3 1100031           11  167190  12.0\n 4 1100049           11 2519353  14.7\n 5 1100056           11  600670  13.3\n 6 1100064           11  366931  12.8\n 7 1100072           11  268381  12.5\n 8 1100080           11  261978  12.5\n 9 1100098           11  666331  13.4\n10 1100106           11  984586  13.8\n# ℹ 5,560 more rows\n```\n:::\n:::\n\n\n## Funções úteis\n\nAbaixo segue uma lista de funções úteis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl |> \n  mutate(\n    #> Cria um ranking da variável\n    rank_pib = rank(pib),\n    #> Cria um rakning (em percentil) da variável\n    rank_perc_pib = percent_rank(pib),\n    #> Agrupa em decis \n    group_decile_pib = ntile(pib, 10),\n    #> Cria um id\n    id = row_number(),\n    #> Aplica uma transformação condicional a uma condição lógica\n    lpib = ifelse(pib > 0, log(pib), 1),\n    #> Aplica uma transformação condicional a múltiplas condições lógicas\n    type = case_when(\n      code_state %in% c(11, 12, 13) ~ \"grupo_1\",\n      code_state %in% c(14, 15, 16) ~ \"grupo_2\",\n      TRUE ~ \"outros\"\n    ),\n    #> Soma cumulativa\n    spib = cumsum(pib),\n    #> Diferença percentual usando o valor imediatamente anterior\n    diff_pib = pib / lag(pib) - 1,\n    #> Participação relativa da variável\n    share_pib = pib / sum(pib, na.rm = TRUE) * 100,\n    #> Normalizar variável\n    scaled_pib = as.numeric(scale(pib))\n  )\n```\n:::\n\n\n# Outros posts da série\n\n-   select\n\n-   filter\n\n-   [rename](https://restateinsight.com/posts/general-posts/2024-01-tidyverse-rename/)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}