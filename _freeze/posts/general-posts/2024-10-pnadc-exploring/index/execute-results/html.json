{
  "hash": "00df1296afff23783c2a1f898226bdda",
  "result": {
    "markdown": "---\ntitle: \"Working with PNADC Microdata in R\"\ndate: \"2024-10-15\"\ndescription: \"When dealing with survey and census data we usually also encounter microdata. Since this microdata is not randomly collected, conventional statistical measures will be biased. Even simple statistics like the mean or the median must be properly weighted to accurately reflect population totals. In this post I show how to work with PNADc microdata in R\"\ncategories: ['data-science', 'web-scrapping', 'finding-all', 'tutorial-r', 'brasil']\nexecute: \n  eval: false\ndraft: true\n---\n\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-1_e1c5a25c23dae883cb7575db7836784c'}\n\n```{.r .cell-code}\nlibrary(PNADcIBGE)\nlibrary(dplyr)\nlibrary(srvyr)\nlibrary(survey)\nlibrary(kableExtra)\n\nformat_number <- function(x, digits = 0) {\n  x <- round(x, digits = digits)\n  x <- format(x, big.mark = \".\", decimal.mark = \",\")\n  return(x)\n}\n\nprint_table <- function(data, col_names = NA) {\n  knitr::kable(data, digits = 2, align = \"c\", col.names = col_names) |> \n    kableExtra::kable_styling(\n      full_width = FALSE,\n      bootstrap_options = c(\"striped\", \"hover\", \"condensed\")\n    )\n}\n\npnad19 <- PNADcIBGE::get_pnadc(year = 2019, interview = 1)\n```\n:::\n\n\n# Introduction\n\nWhen dealing with survey and census data we usually also encounter microdata. Microdata is simply the disaggregated data that is collected in these surveys usually at the individual, household, or establishment level. A \"special\" kind of microdata comes from complex surveys (sometimes refered simply as surveys). Complex surveys differ from conventional surveys in their methodology: most importantly, complex surveys are not random! This is a design choice that helps make research in the field more efficient and economically feasible.\n\nSince this microdata is not randomly collected, conventional statistical measures will be biased. Even simple statistics like the mean or the median must be properly weighted to accurately reflect population totals.\n\n## Identifying the survey\n\nThe PNADc survey can be identified both at the individual and the household level. To identify a household we construct the following key `UPA + V1008 + V1014`. Likewise, to identify an individual we construct the key `UPA + V1008 + V1014 + V2003`.\n\nThe `survey` package facilitates working with complex surveys. To make the data wrangling process smoother we suggest using the `svryr` package that emulates `dplyr` functionality for complex survey data frames.\n\nThe `pnad19` object is a `survey` object but the underlying data frame can be accessed via `pnad19$variables`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert to tbl_svy\n#> as_survey is needed to manipulate the survey object with dplyr functions\npnad19 <- as_survey(pnad19)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npnad19 <- pnad19 |> \n  mutate(\n    id_household = paste0(UPA, V1008, V1014),\n    id_individual = paste0(UPA, V1008, V1014, V2003))\n```\n:::\n\n\nAs of more recent releases of the `PNADcIBGE` package there already is a variable called `ID_DOMICILIO` that identifies each household. There isn't an explicit variable to identify each individual, since each line implicitlty is a unique individual.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall.equal(pnad19$variables$ID_DOMICILIO, pnad19$variables$id_household)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Remove duplicate rows\nhousehold <- pnad19$variables |> \n  distinct(id_household, .keep_all = TRUE)\n\n#> Create with survey::svydesign without bootstraping (slightly faster)\n#> also convert to column names to lowercase\n\nhousehold_simple <- pnad19$variables |> \n  distinct(id_household, .keep_all = TRUE) |> \n  janitor::clean_names()\n\nsvyhh <- survey::svydesign(\n  ids = ~id_household,\n  strata = ~estrato,\n  weights = ~v1032,\n  nest = TRUE,\n  data = household_simple\n)\n\n# Using PNADcIBGE::pnadc_design (must have original names for columns!)\n#> If precise confidence intervals are needed this is the recommended function\nsvyhh <- PNADcIBGE::pnadc_design(household)\n\n\n#> as_survey is needed to manipulate the survey object with dplyr functions\nsvyhh <- as_survey(svyhh)\nsvyhh$variables <- rename_with(svyhh$variables, tolower)\n```\n:::\n\n\n## Check results\n\n\n\n```{.r .cell-code}\n#> Estimate the average number of dwellers per household by state\nhhdwellers <- svyhh |> \n  group_by(uf) |> \n  summarise(avg = survey_mean(vd2003, na.rm = TRUE))\n\nprint_table(hhdwellers)\n```\n\n\nThe code below gets the official IBGE table from the SIDRA API using the `sidrar` package. Note that IBGE rounds its numbers to the first decimal. This makes sense since standard errors are about the first or second decimal case.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Get the official table generated by SIDRA\n\ntable_ibge <- sidrar::get_sidra(\n  x = 6578,\n  geo = \"State\",\n  variable = 10163,\n  period = \"2019\")\n\ntable_ibge |> \n  janitor::clean_names() |> \n  dplyr::select(unidade_da_federacao, valor) |> \n  print_table()\n```\n:::\n\n\n## Only point estimates\n\nSurvey functions can take a very long time to compute, mainly due to the processing time needed to calibrate estimations of standard-errors. If one only needs point estimates for simple statistics it is much easier to use `xtabs` and weighted sums and averages.\n\nThe code below compares computing time and shows that results are equal so there is no lost in precision of points estimates. We use the simple `tictoc` package to time the code but a more thorough analysis should use a more advanced package such as `microbenchmark`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tictoc)\n\ntic(\"slow method\")\ntab_slower <- svyhh |> \n  group_by(uf) |> \n  summarise(avg = survey_mean(vd2003, na.rm = TRUE))\ntoc()\n\ntic(\"fast method\")\ntab_faster <- svyhh$variables |> \n  group_by(uf) |> \n  summarise(avg = weighted.mean(vd2003, v1032))\ntoc()\n\nall.equal(tab_slower$avg, tab_faster$avg)\n```\n:::\n\n\nThe same is true when counting categorical variables. The code below counts the number of household by type (apartment, house, other) in each metropolitan region.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntic(\"slow method\")\ntab_slower <- svyhh |> \n  group_by(rm_ride, s01001) |> \n  survey_count()\ntoc()\n\ntic(\"fast method\")\ntab_faster <- xtabs(v1032 ~ rm_ride + s01001, data = svyhh$variables)\ntoc()\n```\n:::\n\n\nComparing the results is not as straightforward since each function outputs a different object. The slower method outputs a grouped `data.frame` while the faster xtabs method outputs a `table` object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(tab_slower)\n```\n:::\n\n\nThe outout from `xtabs` can be converted to a `data.frame` and is coerced into a convenient long format. The output is a contingency table from cross-classifying factors. Each row is a group of variables and the Freq column is the estimate of the total number of times that group appears in the population.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhhtype <- as.data.frame(tab_faster)\nhead(hhtype)\n```\n:::\n\n\nIn the example above we estimate a total of ... houses in the metropolitan region of Manaus.\n\nComparing both outputs we see that they differ in the last rows. This happens because of missing values in the `rm_ride` column. The slower survey method does not drop these missing by default.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall.equal(tab_slower$n, hhtype$Freq)\n```\n:::\n\n\nTo see this we can filter the missing values in the slower method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntab_slower |> \n  filter(is.na(rm_ride))\n```\n:::\n\n\n# Survey basics\n\n## Computing statistics\n\nComputing summary statistics such as means, totals, and quantiles is straightforward using `survey` functions. However, some knowledge on the survey's methodology is needed to guarantee meaningful and accurate results. It will also be important to note that some cases requires thoughtful choices by the researcher.\n\nTo compute the total number of households by type we use `svytotal`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsvytotal(~s01001, svyhh)\n```\n:::\n\n\nOr, using the `srvyr` syntax\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsvyhh |> \n  group_by(s01001) |> \n  survey_tally()\n```\n:::\n\n\nOr, finally using `xtabs`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxtabs(v1032 ~ s01001, data = svyhh$variables)\n```\n:::\n\n\nIn the following examples we will only use `srvyr` syntax since it imitates `dplyr` syntax which is more commonly known. To compute the average value of total family income we use `survey_mean`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsvyhh |> \n  summarise(income = survey_mean(vd5010))\n```\n:::\n\n\nWhen dealing with income data one might find it useful to remove households without income. This will naturally lead to higher estimates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsvyhh |> \n  # remove household with 0 income\n  filter(vd5010 > 0) |> \n  summarise(income = survey_mean(vd5010))\n```\n:::\n\n\nWe can also estimate grouped averages. The code below estimates the average household income by family type. In the following, Unipessoal represents someone living alone, Nuclear represents all 2 or more people family arrangements, Composta represents a nuclear family + one or more non-relatives that live together in the same household (e.g. maid), and Estendida represents all other cases.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsvyhh |> \n  # remove household with 0 income\n  filter(vd5010 > 0) |> \n  # group by family type\n  group_by(vd2004) |> \n  summarise(income = survey_mean(vd5010))\n```\n:::\n\n\nQuantile estimation is made using `survey_quantile`. Technical aspects can become more complex since quantiles do not depend smoothly on the underlying variable. Ties are also possible, though `survey_mean` will linearly interpolate the values by default.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsvyhh |> \n  summarise(income = survey_quantile(vd5010, seq(0.1, 0.9, 0.1)))\n```\n:::\n\n\nSince the median is a very commonly used quantile a wrapper `survey_median` is available:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsvyhh |> \n  # remove household with 0 income\n  filter(vd5010 > 0) |> \n  # group by family type\n  group_by(vd2004) |> \n  summarise(\n    avg = survey_mean(vd5010),\n    med = survey_median(vd5010))\n```\n:::\n\n\nEstimating proportions and ratios is accomplished using `survey_prop` and `survey_ratio`. At the national level, we estimate that 85.7% of households are houses and only 14.3% are apartments. Note that we consider only houses and apartments since these are much more common.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsvyhh |> \n  filter(s01001 %in% c(\"Casa\", \"Apartamento\")) |> \n  group_by(s01001) |> \n  summarise(prop = survey_prop())\n```\n:::\n\n\nWe could arrive at the same estimate without confidence intervals using tally and then computing the proportion. This is useful since we can quickly tally using `xtabs`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsvyhh |> \n  filter(s01001 %in% c(\"Casa\", \"Apartamento\")) |> \n  group_by(s01001) |> \n  survey_tally() |> \n  mutate(prop = n / sum(n))\n```\n:::\n\n\nThe code below relates homeownership to household types. Using `survey_prop` we find grouped proportions, so each homeownership group sums to 100%.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsvyhh <- svyhh |> \n  mutate(\n    ownership = case_when(\n      stringr::str_detect(s01017, \"^Próprio\") ~ \"Home Owner\",\n      s01017 == \"Alugado\" ~ \"Rent\",\n      TRUE ~ \"Other\"),\n    ownership = factor(ownership))\n\nsvyhh |> \n  filter(s01001 %in% c(\"Casa\", \"Apartamento\")) |> \n  group_by(ownership, s01001) |> \n  summarise(prop = survey_prop())\n```\n:::\n\n\nAlternatively, if we wish to compute the proportion over the entire data we use the `interact` function. This way we find that the most common group are homeowners of houses (62.5%) followed by renters of houses (14.6%).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsvyhh |> \n  filter(s01001 %in% c(\"Casa\", \"Apartamento\")) |> \n  group_by(interact(ownership, s01001)) |> \n  summarise(prop = survey_prop())\n```\n:::\n\n\nAs can be seen in the examples above, both by using `filter` and `group_by` we restrict our estimation to specific subpopulations of the sample. More formally this is domain estimating and while the technical aspects are dealt with by the `survey` functions one should keep in mind that too much restrictions/interactions will lead to imprecise estimations.\n\nThe code below computes the ownership x household types proportions for three major metropolitan regions in Brazil. Note how the standard errors are much larger than when we estimated this for the entire country.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntab_rm <- svyhh |> \n  filter(\n    stringr::str_detect(\n      rm_ride,\n      \"(São Paulo)|(Rio de Janeiro)|(Belo Horizonte)\"),\n    s01001 %in% c(\"Casa\", \"Apartamento\"),\n    vd5010 > 0) |> \n  group_by(rm_ride, ownership, s01001) |> \n  summarise(prop = survey_prop())\n\ntab_rm\n```\n:::\n\n\nThe table below shows the proportion of houses x apartments that are rented in each of the metro regions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntab_rm |> \n  filter(ownership == \"Rent\") |> \n  tidyr::pivot_wider(\n    id_cols = \"rm_ride\",\n    names_from = \"s01001\",\n    values_from = \"prop\",\n    values_fn = ~ round(. * 100, 1)) |> \n  print_table()\n```\n:::\n\n\n## Linear regression and hypothesis tests\n\nLinear models in general are implemented via the `svyglm` function where glm is short for Generalized Linear Model. Default specifications result in a linear model. For other types of linear models, such as binomial models, we can use `family = quasibinomial()`.\n\nThe linear regression model stated below serves only as an example and is broadly based on Acolin & Green (2017), *Measuring housing affordability in São Paulo metropolitan region: Incorporating location*. In their paper, the authors create a simple hedonic model to decompose house rents. Below we propose an even simpler hedonic model to explain house rent variation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsvyhh_reg <- svyhh |> \n  filter(\n    # Consider only houses and apartments\n    s01001 %in% c(\"Casa\", \"Apartamento\"),\n    # Remove 0 income families\n    vd5010 > 0,\n    !is.na(s01012a)) |> \n  mutate(\n    # (Respose variable) Natural logarithm of effective or implied monthly rent\n    rent = log(s01019),\n    # Truncate number of dwellers\n    ndwellers = ifelse(v2001 >= 5, 5, v2001),\n    # Truncate number of rooms\n    rooms = ifelse(s01005 >= 5, 5, s01005),\n    # \"One-hot encoding\" for number of bathrooms\n    # Important note: there exist households without bathrooms in the sample\n    bath1 = ifelse(s01011a == 1, 1L, 0L),\n    bath2 = ifelse(s01011a == 2, 1L, 0L),\n    bath3 = ifelse(s01011a >= 3, 1L, 0L),\n    # Natural logarithm \n    income = log(vd5010),\n    # Group roof material categorical variable\n    roof_material = case_when(\n      stringr::str_detect(s01003, \"^Telha\") ~ \"Tile\",\n      s01003 == \"Somente laje de concreto\" ~ \"Concrete\",\n      TRUE ~ \"Other\"),\n    # Group type of sewage categorical variable\n    sewage = case_when(\n      s01012a == \"Rede geral, rede pluvial\" ~ \"Sewer\",\n      stringr::str_detect(s01012a, \"^Fossa\") ~ \"Sceptic Tank\",\n      TRUE ~ \"Other\"),\n    # Dummy indicating if garbage is collected\n    is_garbage_collected = ifelse(\n      stringr::str_detect(s01013, \"^Coletado\"), 1L, 0L),\n    # Dummy indicating if house has electricity\n    has_electricity = ifelse(\n      stringr::str_detect(s01015, \"^Diária\"), 1L, 0L),\n    # Dummy indicating if household is an apartment\n    is_apto = factor(ifelse(s01001 == \"Apartamento\", 1L, 0L)))\n\nmodel.lm <- svyglm(\n  rent ~ income + is_apto + ndwellers + rooms + bath1 + bath2 + bath3 + \n    roof_material + sewage + is_garbage_collected + has_electricity +\n    as.factor(rm_ride),\n  svyhh_reg\n)\n```\n:::\n\n\nBelow I present the results of the estimation. Two crucial informations are lacking in this model: (1) the house floor area, and (2) the precise location of the house. Even so, only using external quality variables (roof material, type of sewage system, etc.) and proxies for floor area (number of rooms) we have a decent fit.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel.lm |> \n  broom.helpers::tidy_and_attach() |> \n  broom.helpers::tidy_select_variables(\n    include = -starts_with(\"as\")\n  )\n```\n:::\n\n\nThe logistic regression below is stated only for the sake of an example. It creates a dummy variable `is_rent` to identify if a household is for rent. As explanatory variables we use the (1) truncated number of dwellers, (2) the truncated number of rooms, (3) the type of family arrangement, (4) the natural logarithm of total family income, and (5) a dummy variable indicating if the house is an apartment. I also use metro-regions as a fixed-effect variable by wrapping it with `as.factor`. The code for the model is presented below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsvyhh_reg <- svyhh |> \n  mutate(\n    # (Response variable) dummy indicating if household is rental\n    is_rented = factor(ifelse(s01017 == \"Alugado\", 1L, 0L)),\n    # Truncate the number of dwellers\n    ndwellers = ifelse(v2001 >= 5, 5, v2001),\n    # Truncate the number of rooms\n    rooms = ifelse(s01005 >= 5, 5, s01005),\n    # Natural logarithm of income\n    income = log(vd5010),\n    # Lump alternative family arrangements into \"Other\"\n    family_type = ifelse(\n      vd2004 %in% c(\"Estendida\", \"Composta\"), \"Other\", vd2004),\n    # Dummy indicating if home is an apartment\n    is_apto = factor(ifelse(s01001 == \"Apartamento\", 1L, 0L))) |> \n  filter(\n    # Consider only houses and apartments\n    s01001 %in% c(\"Casa\", \"Apartamento\"),\n    # Remove 0 income families\n    vd5010 > 0)\n\n# Estimate logisitc model\nmodel.logistic <- svyglm(\n  is_rented ~ income + is_apto + ndwellers + rooms + family_type +\n    as.factor(rm_ride),\n  svyhh_reg,\n  family = quasibinomial())\n```\n:::\n\n\nResults are summarized in the following table. We see that variables are statistically significant and have intuitive signs. The binary variable for apartment indicates a higher likelihood of a household being rented given that is an apartment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel.logistic |> \n  broom.helpers::tidy_and_attach() |> \n  broom.helpers::tidy_select_variables(include = -starts_with(\"as\"))\n```\n:::\n\n\nWe can compute confidence intervals for these estimates:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconfint(model.logistic, parm = \"is_apto1\")\n```\n:::\n\n\nAnd compute an odds-ratio for the estimates. In the following we find that an apartment is associated with a 2.13 times increase in the average chance of a household being rented.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbetas <- coef(model.logistic)\nexp(betas[names(betas) == \"is_apto1\"])\n```\n:::\n\n\n## Interpreting standard-errors\n\nStandard errors give an idea of the precision of the parameter estimates. For broad analysis we may want to ignore this and only consider point estimates but when comparing different groups we should take them into account.\n\nMore generally, one should not use population estimates from survey data absolutely. Take the estimate of the total number of household by type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxtabs(v1032 ~ s01001, data = svyhh$variables)\n```\n:::\n\n\nAccording to estimator, there are 60,418,462 houses in Brazil. For practical purposes we seldom are interested in the total number of houses with such precision and it would be naive to assume that the survey has this amount of precision. A broad estimate of 60,418 thousand would, generally speaking, be enough. Moreover, if we compute the standard errors we can estimate a 95% confidence interval.\n\nThe interval below states that the true number of houses in Brazil is between 60188669 and 60648255, or 60,188 - 60,648 thousand.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhhtotal <- svytotal(~s01001, svyhh)\nconfint(hhtotal)\n```\n:::\n\n\nStandard errors are more useful when we wish to compare groups in a meaningful manner. In the example of the average number of dwellers we calculated that in Paraíba there are 3.11 persons per household and that in Rio Grande do Norte there are 3.13 persons per household. Can we safely conclude that the average number of dwellers per household is smaller in Paraíba?\n\nSince both estimates have an approximate standard error of 0.03 we can construct a 95% confidence interval around these estimates and compare them. Comparing all states visually we see that some of them cannot be distinguished\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhhdwellers <- hhdwellers |> \n  mutate(\n    ci_lower = avg - 1.96 * avg_se,\n    ci_upper = avg + 1.96 * avg_se,\n    uf = forcats::fct_reorder(uf, avg)\n    ) \n\nggplot(hhdwellers) +\n  geom_col(aes(x = uf, y = avg), fill = \"#344e41\") +\n  geom_errorbar(\n    aes(x = uf, ymin = ci_lower, ymax = ci_upper),\n    color = \"orange\",\n    width = 0.5) +\n  scale_x_discrete(labels = function(x) stringr::str_wrap(x, 12)) +\n  coord_flip() +\n  labs(\n    x = NULL,\n    y = \"Average dwellers per household\",\n    title = \"North and northeastern household are larger\",\n    caption = \"Source: PNADC/A.\") +\n  theme_benvi +\n  theme(\n    axis.text.x = element_text(angle = 0),\n    axis.text.y = element_text(hjust = 0.5)\n  )\n```\n:::\n\n\nFinally, we output these results more clearly. The code below calculates the share of each type of household in each metropolitan region. For clarity we only consider apartments and houses so shares will not sum to 100%.\n\n\n\n```{.r .cell-code}\nhhtype <- as.data.frame(tab_faster)\n\ntab_results <- hhtype |> \n  group_by(rm_ride) |> \n  mutate(share = Freq / sum(Freq) * 100) |> \n  filter(s01001 %in% c(\"Casa\", \"Apartamento\")) |> \n  tidyr::pivot_wider(\n    id_cols = \"rm_ride\",\n    names_from = \"s01001\",\n    values_from = c(\"Freq\", \"share\")) |> \n  mutate(across(where(is.numeric), round, 1)) |> \n  mutate(\n    rm_ride = as.character(rm_ride),\n    rm_ride = stringr::str_replace(rm_ride, \"Região Metropolitana de\", \"RM\"),\n    rm_ride = stringr::str_replace(\n      rm_ride,\n      \"Região Administrativa Integrada\\nde Desenvolvimento da\",\n      \"RIDE\"))\n\nprint_table(tab_results)\n```\n\n\n# Results\n\n## Functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Gets the city name from the rm_ride column\nclean_string <- function(x) {\n  \n  pattern <- c(\n    \"Região Metropolitana d[a-z] \",\n    \"Região Administrativa Integrada de Desenvolvimento da \",\n    \"Grande\", \n    \" \\\\([A-Z][A-Z]\\\\)\",\n    \"Vale do Rio\"\n    )\n  \n  pattern <- paste(stringr::str_glue(\"({pattern})\"), collapse = \"|\")\n  \n  x <- stringr::str_replace_all(x, \"\\n\", \" \")\n  x <- stringr::str_remove_all(x, pattern)\n  x <- stringr::str_trim(x)\n  x <- stringr::str_to_title(x)\n  \n  return(x)\n  \n}\n\n#> Adds geographic dimension to a table based on the rm_ride column\nadd_geo_dimension <- function(data) {\n  \n  dim_state <- readr::read_csv(here(\"data/dimension/dim_city_state.csv\"))\n  \n  data <- data |> \n    dplyr::mutate(\n      name_muni = clean_string(rm_ride),\n      abbrev_state = stringr::str_extract(rm_ride, \"(?<=\\\\().+?(?=\\\\))\")\n    ) |> \n    dplyr::left_join(dim_state, by = c(\"name_muni\", \"abbrev_state\")) |> \n    filter(!is.na(code_muni))\n  \n  return(data)\n}\n\n#> Computes mean and 1st, 2nd and 3rd quantiles.\nsummarize_stat <- function(data, x, ...) {\n  \n  data <- data |> \n    dplyr::group_by(...) |> \n    dplyr::summarize(\n      avg = srvyr::survey_mean({{ x }}, na.rm = TRUE),\n      med = srvyr::survey_median({{ x }}, na.rm = TRUE),\n      q25 = srvyr::survey_quantile({{ x }}, 0.25, na.rm = TRUE),\n      q75 = srvyr::survey_quantile({{ x }}, 0.75, na.rm = TRUE)\n    )\n  \n  return(data)\n  \n}\n#> Alternative spelling fot summarise function above\nsummarise_stat <- summarize_stat\n```\n:::\n\n\n### Find unique family arrangements\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Count total family compositions per household\ntab_family <- pnad19$variables |> \n  group_by(id_household, V1032) |> \n  summarise(family = paste(VD2002, collapse = \",\")) |> \n  count(family, wt = V1032) |> \n  group_by(family) |> \n  summarise(count = sum(n)) |> \n  arrange(desc(count))\n\n#> Find all unique family compositions\ns <- stringr::str_split(paste(tab_family$family, collapse = \",\"), pattern = \",\")\ns <- stringr::str_trim(unique(unlist(s)))\n#> Get only blood relatives excluding \"filho\" (son)\nrm <- \"(Pessoa responsável)|(Cônjuge)|(Filho)|(Empregado)|(empregado)|(Pensionista)\"\ns <- s[!stringr::str_detect(s, rm)]\n#> Escape all brackets\ns <- stringr::str_replace_all(s, \"\\\\(a\\\\)\", \"\\\\\\\\(a\\\\\\\\)\")\n# Collapse into a single pattern to detect relatives\nrelatives <- paste(stringr::str_glue(\"({s})\"), collapse = \"|\")\n\n#> Create dummies and count variables to detect if family (1) is composed of a\n#> single person; (2) is married; (3) has children; (4) lives with relatives - \n#> excluding spouse and children; (5) lives with non-relatives\n#> Note: married includes partners living together\n#> relatives includes \"agregados\" and \"conviventes\"\ntab_family <- tab_family |> \n  mutate(\n    alone = dplyr::if_else(family == \"Pessoa responsável\", 1L, 0L),\n    married = stringr::str_count(family, \"Cônjuge\"),\n    children = stringr::str_count(family, \"Filho\"),\n    relative = as.integer(stringr::str_detect(family, relatives)),\n    other = as.integer(stringr::str_detect(family, \"(mpregado)|(Pensionista)\")),\n    units = 1 + stringr::str_count(family, \"\\\\,\")\n    )\n\n#> Classify family types into 10 most common groups + other\nkey_ftype <- tab_family |> \n  mutate(\n    family_type = case_when(\n      alone == 1L ~ \"One-person household\",\n      married == 1L & units == 2L ~ \"Married without children\",\n      married == 1L & children == 1  & units == 3L ~ \"Married with 1 child\",\n      married == 1L & children == 2  & units == 4L ~ \"Married with 2 children\",\n      married == 1L & children >= 3L & relative == 0L ~ \"Married with 3 or more children\",\n      married == 1L & children == 0L & relative > 0L ~ \"Married without children and with relatives\",\n      married == 1L & children > 0L  & relative > 0L ~ \"Married with children and with relatives\",\n      married == 0L & children > 0L  & relative == 0L ~ \"Single father/mother with children\",\n      married == 0L & children == 0L & relative > 0L ~ \"Single without children and with relatives\",\n      married == 0L & children > 0L  & relative > 0L ~ \"Single with children and with relatives\",\n      TRUE ~ \"Other\")) |> \n  select(family, family_type, alone, married, children, relative, other)\n\n#> Group original data by household (id) and join with family types\nid_ftype <- pnad19$variables |> \n  dplyr::group_by(id_household) |> \n  dplyr::summarise(family = paste(VD2002, collapse = \",\")) |> \n  dplyr::left_join(key_ftype, by = \"family\")\n#> Join the household identified survey data.frame with family types\nhousehold <- dplyr::left_join(household, id_ftype)\n#> Convert to srvyr object again\nsvyhh <- PNADcIBGE::pnadc_design(household)\nsvyhh <- as_survey(svyhh)\nsvyhh$variables <- dplyr::rename_with(svyhh$variables, tolower)\n#> Recreate home-ownership column\nsvyhh <- svyhh |> \n  mutate(\n    ownership = case_when(\n      stringr::str_detect(s01017, \"^Próprio\") ~ \"Home Owner\",\n      s01017 == \"Alugado\" ~ \"Rent\",\n      TRUE ~ \"Other\"),\n    ownership = factor(ownership))\n```\n:::\n\n\n## Main tables\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir <- here::here(\"data/br-ibge-pnad/microdata\")\ndict <- readxl::read_excel(\n  here(dir, \"documentation/dicionario_PNADC_microdados_2019_visita1_20220224.xls\"),\n  skip = 4,\n  col_names = c(\n    \"init_pos\", \"char_length\", \"code\", \"num\", \"description\", \"cat_type\",\n    \"cat_desc\", \"period\"))\n#> Fill columns downwards \ndict <- tidyr::fill(dict, names(dict))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#> V5007 - Received rent?\n#> S01001 - Type of house ownership (e.g. owned, rented, etc.).\n#> S01006 - Number of rooms in the house (1 to 30).\n#> S01018 - What was the amount that was paid or that should have been paid as\n#> payment for mortgage.\n#> S01019 - What was the amount that was paid or that should have been paid as\n#> rent service.\n#> VD2002 - Status in the household (e.g. responsible, father, mother, son, etc.).\n#> VD2003 - Number of people living in the household (1 to 30).\n#> VD2004 - Type of the household arrangement (e.g. single, nuclear, etc.).\n#> VD3004 - Highest level of education achieved.\n#> VD4020 - Effective personal income from all types of work.\n#> VD4022 - Effective personal income from all sources.\n#> VD5007 - Effective family income from all sources.\n#> VD5008 - Per capita family income from all sources.\n#> VD5009 - Per capita family income from all sources (binned).\n\n#> Obs: Income variables include individuals with 0 income.\ncodes <- c(\"v5007a\", \"s01018\", \"s01019\", \"vd2002\", \"vd2003\", \"vd2004\",\n           \"vd3004\", \"vd4020\", \"vd4022\", \"vd5007\", \"vd5008\", \"vd5009\")\n```\n:::\n\n\n### Household Ownership\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Estimate total number of households by ownership in all Metro Regions\ntab_ownership <- svyhh |> \n  group_by(rm_ride, ownership, s01001) |> \n  survey_tally() |> \n  ungroup() |> \n  add_geo_dimension()\n```\n:::\n\n\n```{.r .cell-code}\ntab_ownership |> \n  filter(code_muni == 3550308) |>  \n  tidyr::pivot_wider(\n    id_cols = \"ownership\",\n    names_from = \"s01001\",\n    values_from = \"n\") |> \n  mutate(across(is.numeric, format_number)) |> \n  print_table(col_names = c(\"Ownership\", \"House\", \"Apartament\", \"Other\"))\n```\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Estimate the proportion of households by ownership in all Metro Regions\ntab_ownership_prop <- svyhh |> \n  group_by(rm_ride, ownership, s01001) |> \n  summarise(prop = survey_prop()) |> \n  ungroup() |> \n  add_geo_dimension()\n```\n:::\n\n\n```{.r .cell-code}\ntab_ownership_prop |> \n  filter(code_muni == 3550308, s01001 %in% c(\"Casa\", \"Apartamento\")) |> \n  select(name_muni, ownership, house_type = s01001, prop, prop_se) |> \n  tidyr::pivot_wider(\n    id_cols = \"ownership\",\n    names_from = \"house_type\",\n    values_from = \"prop\") |> \n  print_table()\n```\n\n\n### Rooms per Household\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Estimate the number of households by number of rooms (truncated at 4) in \n#> all Metro Regions\ntab_rooms <- svyhh |>\n  mutate(rooms = ifelse(s01006 >= 4, 4, s01006)) |> \n  group_by(rm_ride, rooms, s01001) |> \n  survey_tally() |> \n  ungroup() |> \n  add_geo_dimension()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Estimate the proportion of households by number of rooms (truncated at 4) in\n#> all Metro Regions\ntab_rooms_prop <- svyhh |>\n  mutate(rooms = ifelse(s01006 >= 4, 4, s01006)) |> \n  group_by(rm_ride, rooms, s01001) |> \n  summarise(prop = survey_prop()) |> \n  ungroup() |> \n  add_geo_dimension()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntab_rooms_prop |> \n  filter(s01001 == \"Apartamento\") |> \n  tidyr::pivot_wider(\n    id_cols = \"name_muni\",\n    names_from = \"rooms\",\n    values_from = \"prop\",\n    values_fn = ~. * 100) |> \n  mutate(across(where(is.numeric), format_number, digits = 2)) |> \n  print_table()\n```\n:::\n\n\n### Dwellers per household\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Estimate the number of household by number of dwellers (truncated at 5) in\n#> all Metro Regions.\ntab_dwellers <- svyhh |> \n  mutate(dwellers = ifelse(vd2003 >= 5, 5, vd2003)) |> \n  group_by(rm_ride, dwellers, vd2003) |> \n  survey_tally() |> \n  ungroup() |> \n  add_geo_dimension()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Estimate the proportion of household by number of dwellers (truncated at 5)\n#> in all Metro Regions.\ntab_dwellers_prop <- svyhh |>\n  mutate(dwellers = ifelse(vd2003 >= 5, 5, vd2003)) |> \n  group_by(rm_ride, dwellers, vd2003) |> \n  summarise(prop = survey_prop()) |> \n  ungroup() |> \n  add_geo_dimension()\n```\n:::\n\n\n### Family arrangement by household\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Estimate the number of households by family arrangement in all MRs\ntab_arrangement <- svyhh |> \n  group_by(rm_ride, vd2004) |> \n  survey_tally() |> \n  ungroup() |> \n  add_geo_dimension()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Estimate the proportion of households by family arrangement in all MRs\ntab_arrangement_prop <- svyhh |> \n  group_by(rm_ride, vd2004) |> \n  summarise(prop = survey_prop()) |> \n  ungroup() |> \n  add_geo_dimension()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Estimate the number of the most common family types\ntab_ftypes <- svyhh |> \n  group_by(rm_ride, family_type) |> \n  survey_tally() |> \n  ungroup() |> \n  add_geo_dimension()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Estimate the proportion of the most common family types\ntab_ftypes_prop <- svyhh |> \n  group_by(rm_ride, family_type) |> \n  summarise(prop = survey_prop()) |> \n  ungroup() |> \n  add_geo_dimension()\n```\n:::\n\n\n### Mortgage and rents\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Estimate how much families pay for mortgage on their homes in all MRs\ntab_mortgage <- svyhh |> \n  filter(s01018 > 0) |> \n  group_by(rm_ride) |> \n  summarise(\n    avg = survey_mean(s01018, na.rm = TRUE),\n    med = survey_median(s01018, na.rm = TRUE),\n    q25 = survey_quantile(s01018, 0.25, na.rm = TRUE),\n    q75 = survey_quantile(s01018, 0.75, na.rm = TRUE))\n\n#> Estimates how much families pay for rent in all MRs\ntab_rent <- svyhh |> \n  filter(s01019 > 0, s01017 == \"Alugado\") |> \n  group_by(rm_ride) |> \n  summarise(\n    avg = survey_mean(s01019, na.rm = TRUE),\n    med = survey_median(s01019, na.rm = TRUE),\n    q25 = survey_quantile(s01019, 0.25, na.rm = TRUE),\n    q75 = survey_quantile(s01019, 0.75, na.rm = TRUE))\n```\n:::\n\n\n### Income\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Estimate total family income in all Metro Regions (excludes 0 income families)\ntab_income <- svyhh |> \n  filter(vd5010 > 0) |> \n  summarize_stat(vd5010, rm_ride)\n\n#> Estimate per capital family income in all Metro Regions (excludes 0 income\n#> families).\ntab_income_pc <- svyhh |> \n  filter(vd5010 > 0) |> \n  summarize_stat(vd5011, rm_ride)\n\n#> Estimates the proportion of families by per capita income in all Metro \n#> Regions (excludes 0 income families)\ntab_income_pc_binned <- svyhh |> \n  filter(vd5010 > 0) |> \n  group_by(rm_ride, vd5009) |> \n  summarise(prop = survey_prop())\n```\n:::\n\n\n```{.r .cell-code}\ntab_income_pc |> \n  select(rm_ride, avg, avg_se) |> \n  arrange(desc(avg)) |> \n  mutate(across(is.numeric, format_number)) |> \n  print_table(col_names = c(\"Metro Region\", \"Average\", \"Std. Err.\"))\n```\n\n\n# Appendix\n\n## Base code to execute analysis\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_pnadc_identified <- function(\n    year = 2019,\n    interview = 1,\n    simplified = FALSE,\n    is_srvyr = TRUE,\n    aux_variables = TRUE,\n    unit = \"household\") {\n  \n  pnad <- PNADcIBGE::get_pnadc(year = year, interview = interview)\n\n  if (isTRUE(aux_variables)) {\n    \n    pnad$variables <- dplyr::mutate(\n      pnad$variables,\n      # Lump house ownership into broader groups\n      ownership = dplyr::case_when(\n        stringr::str_detect(s01017, \"^Próprio\") ~ \"Home Owner\",\n        S01017 == \"Alugado\" ~ \"Rent\",\n        TRUE ~ \"Other\"),\n      ownership = factor(ownership),\n      # Group roof material categorical variable\n      roof_material = dplyr::case_when(\n        stringr::str_detect(s01003, \"^Telha\") ~ \"Tile\",\n        s01003 == \"Somente laje de concreto\" ~ \"Concrete\",\n        TRUE ~ \"Other\"),\n      # Group type of sewage categorical variable\n      sewage = dplyr::case_when(\n        s01012a == \"Rede geral, rede pluvial\" ~ \"Sewer\",\n        stringr::str_detect(s01012a, \"^Fossa\") ~ \"Sceptic Tank\",\n        TRUE ~ \"Other\"),\n      # Dummy indicating if garbage is collected\n      is_garbage_collected = ifelse(\n        stringr::str_detect(s01013, \"^Coletado\"), 1L, 0L),\n      # Dummy indicating if house has electricity\n      has_electricity = ifelse(\n        stringr::str_detect(s01015, \"^Diária\"), 1L, 0L),\n      # Dummy indicating if household is an apartment\n      is_apto = factor(ifelse(s01001 == \"Apartamento\", 1L, 0L))\n    )\n    \n    \n  }\n  \n  if (unit == \"household\") {\n    #> Remove duplicate rows\n    household <- dplyr::distinct(pnad$variables, .keep_all = TRUE)\n    \n    if (isFALSE(simplified)) {\n      # If precise confidence intervals are needed this is recommended\n      svy <- PNADcIBGE::pnadc_design(household)\n    } else {\n      # Simple (and quicker) approach\n      svy <- survey::svydesign(\n        ids = ~ID_DOMICILIO,\n        strata = ~Estrato,\n        weights = ~V1032,\n        nest = TRUE,\n        data = pnad\n        )\n    }\n\n  }\n  \n  if (unit == \"individual\") {\n    if (isFALSE(simplified)) {\n      svy <- pnad\n    } else {\n      # Simple (and quicker) approach\n      svy <- survey::svydesign(\n        ids = ~1,\n        strata = ~Estrato,\n        weights = ~V1032,\n        nest = TRUE,\n        data = pnad\n        )\n      } \n    }\n    \n  if (isTRUE(is_srvyr)) {\n    svy <- srvyr::as_survey(svy)\n    svy$variables <- dplyr::rename_with(svy$variables, tolower)\n  }\n  \n  return(svy)\n  \n}\n```\n:::\n\n\n## A bit on the theory of complex surveys\n\nSuppose we take a random sample of 1000 people from Rio Grande do Sul (with a total population of 10,000,000). Any given individual has a $\\pi_{i} = 0.00001$ chance of being selected into this sample. If 200 people from this sample have a dog as a pet we can expect that $200 \\times 10000 = 2.000.000$ people, in fact, have a dog as a pet.\n\nThe idea behind this is that any individual $i$, sampled with probability $\\pi_{i}$ represents $\\frac{1}{\\pi}$ individuals in the population. In the example, the total number of dog owners $X$ is approximated by the fraction of individuals in the sample that have a dog multiplied by their relative weight in the total population. Since we assume random sampling, every individual has the same weight, the same *sampling weight*. In other words, $\\pi_{i} = \\pi \\, \\forall \\, i$.\n\nFormally we have the following estimator\n\n$$\n\\hat{X} = \\frac{1}{\\pi_{i}}x_{i}\n$$\n\nwhere $x_{i}$ is the observed value of variable $x$ for individual $i$ sampled with probability $\\pi_{i}$. For the simplest case, suppose only a single individual is sampled and that $X$ is the total wealth of the population.\n\nGiven a sample of size $N$ we define the Horwitz-Thompson estimator $\\hat{T}_{X}$ for the population total $T_{X}$ of $X$ as:\n\n$$\n\\hat{T}_{X} = \\sum_{i = 1}^{N}\\frac{1}{\\pi_{i}}x_{i}\n$$\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}