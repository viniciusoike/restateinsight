{
  "hash": "bbc96c1338bca4fe437b5e49f962edcd",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Definindo objetos no R. `=` ou `<-` ?\"\ndate: '2023-07-11'\nimage-alt: \"/static/codigo_generico.png\"\nimage: \"/static/codigo_generico.png\"\ncategories: [\"tutorial-R\"]\n---\n\n# Definindo objetos no R\n\nHá dois operadores para definir um objeto no R: `=` e `<-`. A maior parte dos usuários parece preferir o último apesar dele parecer um tanto inconveniente. Em teclados antigos, havia uma tecla específica com o símbolo `<-`, mas em teclados ABNT modernos ele exige três teclas para ser escrito.\n\nPara contornar este incômodo é comum criar um atalho no teclado para esse símbolo; o RStudio, por exemplo, tem um atalho usando a teclas `Alt` e `-` em conjunto. Mas ainda assim fica a questão: por que não utilizar o `=`? A resposta curta é que o símbolo `<-` é a melhor e mais consistente forma de definir objetos R. Na prática, contudo, há poucas diferenças entre as expressões e elas dificilmente vão fazer alguma diferença. Podemos começar com um exemplo bastante simples para entender estas diferenças.\n\n## Qual a diferença?\n\nO código abaixo cria duas variáveis, `x` e `y`, cujos valores são a sequência $1, 2, 3, 4, 5$. Até aí tudo igual. A função `all.equal` certifica que os objetos são iguais e a função `rm` \"deleta\" os objetos. Esta última vai ser conveniente para manter os exemplos organizados.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 1:5\ny <- 1:5\n\nall.equal(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nrm(x, y)\n```\n:::\n\n\nAgora considere o código abaixo. A função `median` está sendo aplicada em `x <- 1:5`. O que acontece desta vez? O resultado é que é criada uma variável `x` com valor `1 2 3 4 5` e também é impresso a mediana deste vetor, i.e., `3`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmedian(x <- 1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nrm(x)\n```\n:::\n\n\nPoderíamos fazer o mesmo usando `=`, certo? Errado. Aí está uma das primeiras diferenças entre estes operadores. O código abaixo calcula a mediana do vetor, mas não cria um objeto chamado `x` com valor `1 2 3 4 5`. Por quê? O problema é que o operador `=` tem *duas finalidades distintas*. Ele serve tanto para definir *novos* objetos, como em `x = 2`, como também para definir o *valor dos argumentos de uma função*, como em `rnorm(n = 10, mean = 5, sd = 1)`. Coincidentemente, o nome do primeiro argumento da função `median` é x. Logo, o código abaixo é interpretado como: tire a mediana do vetor `1 2 3 4 5`. O mesmo acontece com outras funções (ex: `mean`, `var`, etc.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmedian(x = 1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: object 'x' not found\n```\n\n\n:::\n\n```{.r .cell-code}\nrm(x)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in rm(x): object 'x' not found\n```\n\n\n:::\n:::\n\n\nOutro exemplo em que há divergência entre os operadores é com o comando `lm`. Usando `<-` podemos escrever, numa única linha, um comando que define um objeto `lm` (resultado de uma regressão) ao mesmo tempo em que pedimos ao R para imprimir os resultados desta regressão. O código abaixo faz justamente isto.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Imprime os resultados da regressão e salva as info num objeto chamado 'fit'\nsummary(fit <- lm(mpg ~ wt, data = mtcars))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = mpg ~ wt, data = mtcars)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-4.5432 -2.3647 -0.1252  1.4096  6.8727 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  37.2851     1.8776  19.858  < 2e-16 ***\nwt           -5.3445     0.5591  -9.559 1.29e-10 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 3.046 on 30 degrees of freedom\nMultiple R-squared:  0.7528,\tAdjusted R-squared:  0.7446 \nF-statistic: 91.38 on 1 and 30 DF,  p-value: 1.294e-10\n```\n\n\n:::\n\n```{.r .cell-code}\n# Verifica que é, de fato, um objeto lm\nclass(fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"lm\"\n```\n\n\n:::\n\n```{.r .cell-code}\nrm(fit)\n```\n:::\n\n\nNote que isto não é possível com o operador `=`. Isto acontece, novamente, porque o `=` é interpretado de maneira diferente quando aparece dentro de uma função. É necessário quebrar o código em duas linhas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Este exemplo não funciona\nsummary(fit = lm(mpg ~ wt, data = mtcars))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in summary.lm(fit = lm(mpg ~ wt, data = mtcars)): argument \"object\" is missing, with no default\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# É preciso reescrever o código em duas linhas\nfit = lm(mpg ~ wt, data = mtcars)\nsummary(fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = mpg ~ wt, data = mtcars)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-4.5432 -2.3647 -0.1252  1.4096  6.8727 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  37.2851     1.8776  19.858  < 2e-16 ***\nwt           -5.3445     0.5591  -9.559 1.29e-10 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 3.046 on 30 degrees of freedom\nMultiple R-squared:  0.7528,\tAdjusted R-squared:  0.7446 \nF-statistic: 91.38 on 1 and 30 DF,  p-value: 1.294e-10\n```\n\n\n:::\n\n```{.r .cell-code}\nrm(fit)\n```\n:::\n\n\nHá também algumas pequenas divergências pontuais. Os primeiros dois argumentos da função `lm` são `formula` e `data`. Considere o código abaixo. Sem executar o código qual deve ser o resultado?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit <- lm(formula <- mpg ~ wt, data <- mtcars)\n```\n:::\n\n\nEstamos aplicando a função `lm` em dois argumentos. O primeiro deles se chama `formula` e é definido como `mpg ~ wt`, o segundo é chamado `data` e é definido como os valores no data.frame `mtcars`. Ou seja, o resultado deve ser o mesmo do exemplo acima com `median(x <- 1:5)`. A função é aplicada sobre os argumentos e os objetos `formula` e `data` são criados.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit <- lm(formula <- mpg ~ wt, data <- mtcars)\nfit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = formula <- mpg ~ wt, data = data <- mtcars)\n\nCoefficients:\n(Intercept)           wt  \n     37.285       -5.344  \n```\n\n\n:::\n\n```{.r .cell-code}\nformula\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nmpg ~ wt\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n```\n\n\n:::\n\n```{.r .cell-code}\nrm(fit, formula, data)\n```\n:::\n\n\nNote que usei os nomes dos argumentos apenas para exemplificar o caso. Pode-se colocar um nome diferente, pois não estamos \"chamando\" o argumento e sim especificando qual valor/objeto a função deve utilizar.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exemplo utilizando nomes diferentes\nfit <- lm(a <- \"mpg ~ wt\", b <- mtcars)\nfit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = a <- \"mpg ~ wt\", data = b <- mtcars)\n\nCoefficients:\n(Intercept)           wt  \n     37.285       -5.344  \n```\n\n\n:::\n\n```{.r .cell-code}\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"mpg ~ wt\"\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n```\n\n\n:::\n\n```{.r .cell-code}\nrm(list = ls())\n```\n:::\n\n\nO mesmo não é possível com `=`, por causa da duplicidade apontada acima.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit = lm(a = \"mpg ~ wt\", b = mtcars)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in terms.formula(formula, data = data): argument is not a valid model\n```\n\n\n:::\n:::\n\n\nHá ainda mais alguns exemplos estranhos, resultados da ordem que o R processa os comandos. O segundo código abaixo, por exemplo, não funciona. Isto acontece porque o `<-` tem \"prioridade\" e é lido primeiro.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(x = y <- 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\n(x <- y = 5)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in x <- y = 5: could not find function \"<-<-\"\n```\n\n\n:::\n:::\n\n\nÉ difícil encontrar desvatagens em usar o `<-` (além da dificuldade de escrevê-lo num teclado normal). Mas há pelo menos um caso em que ele pode levar a problemas. O código abaixo mostra como este operador pode ser sensível a espaços em branco. No caso, define-se o valor de `x` como `-2`. O primeiro teste verifica se o valor de `x` é menor que $-1$. Logo, espera-se que o código imprima `\"ótimo\"` pois `-2` é menor que `-1`. Já o segundo teste faz *quase* o mesmo. A única diferença é um espaço em branco, mas agora ao invés de um teste, a linha de código define o valor de x como `1` e imprime `\"ótimo\"`, pois o valor do teste (por padrão) é `TRUE`.\n\nAssim como muitos dos exemplos acima, é difícil imaginar que isto possa ser um problema real. Eventualmente, podemos apagar espaços em branco usando o 'localizar e substituir' e isto talvez leve a um erro como o abaixo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define x como -2\nx <- -2\n# Se x for menor que -1 (menos um) então \"ótimo\"\nif (x < -1) {\n  \"ótimo\"\n} else {\n  \"errado\"\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ótimo\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Verifica o valor de x\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -2\n```\n\n\n:::\n\n```{.r .cell-code}\n# Mesma linha com uma diferença sutil\nif (x <- 1) {\n  \"ótimo\"\n} else {\n  \"errado\"\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ótimo\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Agora acabamos de mudar o valor de x (e não há aviso algum!)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n## Mais um adendo\n\nEu citei apenas dois operadores: `=` e `<-`; mas na verdade há ainda outros: `<<-`, `->` e `->>` (veja `help(\"assignOps\")`). Os operadores com \"flecha dupla\" são comumente utilizadas dentro de funções para usos específicos. Algumas pessoas acham que o operador `->` é mais intuitivo quando usado com \"pipes\". Pessoalmente, acho este tipo de código abominável.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAirPassengers |>\n  log() |>\n  window(start = c(1955, 1), end = c(1958, 12)) -> sub_air_passengers\n\nsub_air_passengers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          Jan      Feb      Mar      Apr      May      Jun      Jul      Aug\n1955 5.488938 5.451038 5.587249 5.594711 5.598422 5.752573 5.897154 5.849325\n1956 5.648974 5.624018 5.758902 5.746203 5.762051 5.924256 6.023448 6.003887\n1957 5.752573 5.707110 5.874931 5.852202 5.872118 6.045005 6.142037 6.146329\n1958 5.828946 5.762051 5.891644 5.852202 5.894403 6.075346 6.196444 6.224558\n          Sep      Oct      Nov      Dec\n1955 5.743003 5.613128 5.468060 5.627621\n1956 5.872118 5.723585 5.602119 5.723585\n1957 6.001415 5.849325 5.720312 5.817111\n1958 6.001415 5.883322 5.736572 5.820083\n```\n\n\n:::\n:::\n\n\nAlém dos operadores base, o popular pacote `magrittr` também possui um novo tipo de operador. Muitos conhecem o `%>%` que ajuda a formar \"pipes\" e carregar objetos progressivamente em funções distintas. Menos conhecido, mas igualmente poderoso, o `%<>%` faz algo parecido.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(magrittr)\nx <- 1:5\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nx %<>% mean() %<>% sin()\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.14112\n```\n\n\n:::\n:::\n\n\nNote que o código acima é equivalente ao abaixo. A vantagem do operador `%<>%` é de evitar a repetição do `x <- x ...` o que pode ser conveniente quando o nome do objeto é longo. Da mesma forma, também pode ser aplicado para transformar elementos em uma lista ou colunas num `data.frame`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:5\nx <- x %>% mean() %>% sin()\n```\n:::\n\n\nNão recomendo o uso nem do `->` e nem do `%<>%`.\n\n## Resumo\n\nNo geral, o operador `<-` é a forma mais \"segura\" de se definir objetos. De fato, atualmente, este operador é considerado o mais apropriado. O livro [*Advanced R*](https://adv-r.hadley.nz/), do influente autor Hadley Wickham, por exemplo, recomenda que se use o operador `<-` *exclusivamente* para definir objetos.\n\nA inconveniência de escrevê-lo num teclado moderno é contornada, como comentado acima, por atalhos como o `Alt` + `-` no RStudio. Em editores de texto como o VSCode, Sublime Text ou Notepad++ também é possível criar atalhos personalizados para o `<-`. Pessoalmente, eu já me acostumei a digitar `<-` manualmente e não vejo grande problema nisso. Acho que o `=` tem seu valor por ser mais intutivo, especialmente para usuários que já tem algum conhecimento de programação, mas acabo usando mais o `<-`. Por fim, o `<-` fica bem bonito quando se usa uma fonte com ligaturas como o [Fira Code](https://github.com/tonsky/FiraCode).\n\nÉ importante frisar que o `<-` continua sendo o operador de predileção da comunidade dos usuários de R e novas funções/pacotes devem ser escritas com este sinal. Por sorte há opções bastante simples que trocam os `=` para `<-` corretamente como o `formatR` apresentado abaixo. Veja também o addin do pacote `styler`. Ou seja, é possível escrever seu código usando `=` e trocá-los por `<-` de maneira automática se for necessário.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(formatR)\ntidy_source(text = \"x = rnorm(n = 10, mean = 2)\", arrow = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nx <- rnorm(n = 10, mean = 2)\n```\n\n\n:::\n:::\n\n\nEm livros de econometria ambos os operadores são utilizados. Os livros [Introduction to Econometrics with R](https://www.econometrics-with-r.org/index.html), [Applied Econometrics with R](https://www.zeileis.org/teaching/AER/), [Arbia. Spatial Econometrics](https://link.springer.com/book/10.1057/9781137317940), entre outros, usam o `<-`. Já os livros [Tsay. Financial Time Series](https://faculty.chicagobooth.edu/ruey-s-tsay/research/analysis-of-financial-time-series-3rd-edition) e [Shumway & Stoffer. Time Series Analysis](https://link.springer.com/book/10.1007/978-3-319-52452-8) usam `=`.\n\nO ponto central deste post, na verdade, é mostrar como os operadores `<-` e `=` são muito similares na prática e que a escolha entre um ou outro acaba caindo numa questão subjetiva. Há quem acredite ser mais cômodo usar o `=` não só porque ele é mais fácil de escrever, mas também porque ele é mais próximo de *universal*. Várias linguagens de programação comuns para a/o economista (Matlab, Python, Stata, etc.) usam o sinal de igualdade para definir objetos e parece estranho ter que usar o `<-` somente para o R.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}