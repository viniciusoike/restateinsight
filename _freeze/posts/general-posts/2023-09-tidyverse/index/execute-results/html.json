{
  "hash": "c706a2f18709d52acde7ffef6886a1f8",
  "result": {
    "markdown": "---\ntitle: \"A filosofia do Tidyverse\"\ndate: '2023-10-09'\ncategories: ['tidyverse', 'data-science', 'R']\nexecute: \n  eval: false\n  message: false\n  warning: false\n---\n\n::: {.cell}\n\n:::\n\n\n# Tidyverse\n\nO [tidyverse](https://tidyverse.tidyverse.org) é um metapacote, ou conjunto de pacotes. Pode-se pensar no tidyverse como uma família de pacotes, unidos por uma filosofia comum; grosso modo, os pacotes que compõem o tidyverse tem o mesmo objetivo: facilitar a manipulação de dados. Estes pacotes criaram uma nova forma de se escrever código, que substitui boa parte ou mesmo todas as funções base do R. Atualmente, o tidyverse parece estar se consolidando como a variante dominante do R. De fato, a maior parte dos pacotes do tidyverse consta na lista dos mais baixados no [repositório CRAN](#0).\n\nO tidyverse é intimamente ligado com o estatístico [Hadley Wickham](https://hadley.nz), criador ou co-criador da maioria dos seus pacotes, e autor do [influente artigo](https://vita.had.co.nz/papers/tidy-data.pdf) em que ele define o que é \"tidy\" data. Ele também é autor de diversos livros didáticos como [R for Data Science](https://r4ds.hadley.nz) e [ggplot2: Elegant graphics for Data Analysis](https://ggplot2-book.org), que ajudaram a popularizar o tidyverse.\n\nWickham também tem posição de liderança dentro da Posit (antigamente conhecida como RStudio), que mantém o GUI mais popular de R e que patrocina inúmeras [atividades vinculadas com o aprendizado de R](https://posit.co/resources/), que costumam enfatizar os pacotes do tidyverse. De fato, tornou-se lugar comum começar a se ensinar R pelo tidyverse como se vê pela prevalência de cursos no [Coursera](https://www.coursera.org/specializations/tidyverse-data-science-r) ou [Datacamp](https://www.datacamp.com/courses/introduction-to-the-tidyverse).\n\nQuando se olha para a curta história do tidyverse é difícil explicar o porquê do seu enorme sucesso, mas é fato que este conjunto de pacotes se tornou um dialeto dominante dentro da comunidade do R. As funções do tidyverse tem algumas vantagens importantes sobre o base-R.\n\n### Consistência e qualidade\n\nAs funções do tidyverse possuem uma característica ausente na maior parte das funções base do R: consistência. As funções do tidyverse oferecem consistência sintática: o nome da funções segue certas convenções e a ordem dos argumentos segue regras previsíveis.\n\nUm exemplo imediato é o pacote `stringr`, que serve para manipulação de strings. Todas as funções deste pacote começam com prefixo `str_` e seus argumentos seguem a lógica: `string` e `pattern` como em `str_detect(string, pattern)`[^1]. Além disso, as funções são mais otimizadas em relação às funções base do R.\n\n[^1]: As funções base `gsub`, `grep` e `grepl`, por exemplo seguem o padrão `pattern`, `string`. Já a função `strsub` usa o padrão `string`, `pattern`. Para mais diferenças entre as funções base para manipulação de texto e o `stringr` [consulte este material](https://stringr.tidyverse.org/articles/from-base.html).\n\nO `purrr` faz algo similar, ao simplificar a família de funções `apply` em diversas funções `map_*`. Neste caso, além da consistência sintática, as funções `map_*` também garantem a consistência do output, em termos da classe do objeto que é retornado como resultado da função. Isto é uma grande vantagem, especialmente quando comparado com a função `sapply` que \"simplifica\" o output de maneiras às vezes imprevisíveis.\n\nEm termos de eficiência, o tidyverse costuma ganhar das funções equivalentes em base-R. O `dplyr`/`tidyr`, de maneira geral, garante manipulações de dados muito mais velozes[^2], assim como o `readr` importa dados mais rapidamente[^3]. As funções `map` também tem paralelos simples na família `future_` do pacote `furrr`, que permite usar processamento paralelo no R.\n\n[^2]: Existem diversos benchmarks que atestam os ganhos do `dplyr` em relação ao base-R. Veja, por exemplo, este [comparativo](https://www.r-bloggers.com/2022/10/efficiency-comparison-of-dplyr-and-tidyr-functions-vs-base-r/). Apesar disto, o `dplyr` é menos eficiente que seu concorrente `data.table`. Existem algumas alternativas como [dtplyr](https://dtplyr.tidyverse.org) e, mais recentemente, [tidytable](https://markfairbanks.github.io/tidytable/), que fornecem a velocidade do data.table com a sintaxe do `dplyr`.\n\n[^3]: Similarmente ao `dplyr`, o `readr` também perde para seu concorrente `data.table::fread`. Contudo, o pacote `vroom` oferece uma alternativa mais veloz ao `readr` dentro do universo tidyverse.\n\n### Material de apoio\n\nHá muito material de apoio para tidyverse: livros, materiais didáticos, posts em blogs, respostas em fóruns, etc. Como citado acima, o próprio Posit produz inúmeros materiais didáticos e livros que ajudam a aprender e a ensinar tidyverse. Na medida em que o tidyverse consolida-se como o dialeto dominante isto tende a se tornar um ciclo virtuoso.\n\nO R é uma linguagem bastante versátil, que reúne pesquisadores de campos distintos. Recentemente, parece haver uma convergência para o tidyverse. O campo de séries de tempo, por exemplo, agora tem o `tidyquant`, `fable` e `modeltime` que utilizam os princípios do `tidyverse`. Com o tempo, deve-se observar movimentos similares de outros campos.\n\n### Tudo em um\n\nO tidyverse oferece funções que se aplicam a cada uma das etapas de uma análise de dados. Neste sentido, ele vai de ponta-a-ponta, cobrindo importação, limpeza, modelagem e visualização de dados. A natureza autocontida do tidyverse é bastante atraente pois oferece um caminho seguro para novatos no R, especialmente para quem tem interesse em ciência de dados.\n\n### Escalabilidade\n\nO conhecimento no R muitas vezes é bastante horizontal. Cada pacote novo traz funções diferentes, que funcionam de novas maneiras e este conhecimento adquirido nem sempre se traduz para outras tarefas. Já sintaxe do `dplyr` é bastante geral, pode ser utilizada em vários contextos. O `dbplyr`, por exemplo, é um backend para databases (como BigQuery, PostgreSQL, etc.) que usa a sintaxe do `dplyr` como frontend. O mesmo acontece com `dtplyr`/`tidytable` que permite usar a sintaxe do `dplyr` junto com a eficiência do `data.table`. Até para dados complexos já existe o pacote `srvyr` que usa o `survey` como backend.\n\n### Facilidade de uso\n\nEste último ponto é bastante mais contencioso. Eu acredito que o `tidyverse` é mais fácil do que base-R. Eu tenho um conhecimento razoável de base-R e avançado tanto de `tidyverse` como de `data.table`. Na minha opinião, a lógica do tidyverse de usar o nome das colunas de um `data.frame` como objetos é muito poderosa e intuitiva. Não só torna o código mais legível como também evita uma sintaxe carregada com operadores estranhos como `$`.\n\nA integração com pipes também simplifica muito o workflow da análise de dados. Com o tempo, a leitura de um código em pipes torna-se natural. Por fim, fazer funções com tidyverse também é muito fácil. Especialmente no caso de funções simples, a sintaxe `{{x}}` e `!!x` facilita bastante e, de maneira geral, considero mais simples programar usando princípios \"tidy\" do que programar usando base-R.\n\n# Explorando o tidyverse\n\nO \"núcleo duro\", por assim dizer, do tidyverse é composto por 8 pacotes:\n\n-   `dplyr`\n\n-   `tidyr`\n\n-   `tibble`\n\n-   `readr`\n\n-   `stringr`\n\n-   `lubridate`\n\n-   `forcats`\n\n-   `purrr`\n\n-   `ggplot2`\n\nPessoalmente, gosto muito de todos estes pacotes, a ponto de ter listado todos no meu post de [pacotes essenciais de R](https://restateinsight.com/posts/general-posts/pacotes-essenciais-r/). Cada um destes pacotes resolve algum problema central na análise de dados. O pacote `readr` importa os dados; o `tibble` é a plataforma que contém os dados; `dplyr` e `tidyr` limpam os dados; e, finalmente, `ggplot2` visualiza os dados. Os pacotes `lubridate`, `forcats` e `stringr` lidam com as três classes importantes de dados: datas, factors e texto. Por fim, o pacote `purrr` amarra todo este ecossistema de pacotes numa abordagem de programação funcional que é elegante e eficiente.\n\nAlém dos pacotes core, o tidyverse traz junto consigo outros pacotes importantes como `rvest`/`xml2`/`httr`, para webscrapping, `jsonlite`/`readxl`/`haven`/`feather`, para importação de outros tipos de arquivos de dados e `modelr`/`broom` para modelagem de dados e apresentação de resultados.\n\n## O tidyverse em números\n\nOlhando para as estatísticas do CRAN, vê-se que os pacotes do tidyverse são muito relevantes dentro do ecossistema. Os dados compilados abaixo mostram o retrato dos pacotes do CRAN em 05 de setembro de 2023, quando havia cerca de 19.800 pacotes ativos.\n\nAtualmente, cerca de um terço dos pacotes no CRAN dependem de algum dos pacotes core do tidyverse. O crescimento desta razão tem sido crescente: de todos os pacotes ativos em 2023, 40% dependem diretamente do tidyverse. Note que no gráfico abaixo, o ano de publicação reflete o ano da versão mais recente de cada pacote. Assim, pacotes ativos cuja última atualização foi anterior a 2016 dificilmente vão possuir alguma dependência com os pacotes do tidyverse já que a maioria deles não existia nesta época.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nVale lembrar que há três tipos de \"dependência\" entre pacotes no R: **imports**, **depends** e **suggests**. Tipicamente, se um pacote A usa algumas funções de outro pacote B, então o pacote A importa (**imports**) o pacote B. Isto é, ele assume que o usuário tenha o pacote B instalado. Já a relação **depends** é mais estrita: se um pacote A **depends** de um pacote C então os pacotes são carregados conjuntamente quando se chama `library()`[^4]. Por fim se um pacote A usa um pacote D, em algum contexto específico, mas não requer que o usuário tenha o pacote D instalado, então o pacote A **suggests** o pacote D[^5].\n\n[^4]: O pacote `ggforce`, por exemplo, *depends* do `ggplot2`. Isto significa que `library(ggforce)` automaticamente carrega o pacote `ggplot2`.\n\n[^5]: Em geral, os pacotes sugeridos (**suggests**) são listados para os desenvolvedores do pacote ou utilizados para testes e exemplos. Você provavelmente já deve ter visto algum exemplo que começa com: `if (require(\"pacote\")) { … }`. O pacote `nnet`, por exemplo, não depende nem importa outros pacotes, mas utiliza o pacote `MASS` em seus exemplos; assim, o pacote `nnet` suggests o pacote `MASS`. Também existem casos onde um pacote tem mais capacidades ou melhor performance quando os pacotes sugeridos estão instalados; nestes casos, recomenda-se instalar o pacote com `install.packages(dependencies = TRUE)`\\`.\n\nOlhando os dados por pacote vê-se que o ggplot2 e dplyr são os mais populares.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n## A filosofia do `tidyverse`\n\nA filosofia geral do `tidyverse` toma muito emprestado da gramática. As funções têm nomes de verbos que costumam ser intuitivos e são encadeados via \"pipes\"[^6] que funcionam como conectivos numa frase. Em tese, isto torna o código mais legível e até mais didático. A tarefa de renomear colunas, criar variáveis e calcular uma média nos grupos torna-se \"linear\" no mesmo sentido em que uma frase com sujeito-verbo-objeto é linear.\n\n[^6]: Para saber mais sobre pipes e a diferença entre o novo pipe nativo `|>` e o pipe `|>` do `magrittr` veja meu post sobre o assunto.\n\n### Pipes\n\nO pipe, essencialmente, carrega o resultado de uma função adiante numa cadeia de comandos: `objeto |> função1 |> função2 |> função3`. Isto tem duas vantagens: primeiro, evita que você use funções compostas que são lidas \"de dentro para fora\" como `exp(mean(log(x)))`; e, segundo, dispensa a criação de objetos intermediários \"inúteis\" que estão ali somente para segurar um valor que não vai ser utilizado mais adiante.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmodel <- lm(log(AirPassengers) ~ time(AirPassengers))\n\n#> Função composta\nmean(exp(fitted(model)))\n#> Usando pipes\nmodel |> fitted() |> exp() |> mean()\n#> Usando objetos intermediários\nx1 <- fitted(model)\nx2 <- exp(x1)\nx3 <- mean(x2)\n```\n:::\n\n\nNum contexto de manipulação de dados pode-se ter algo como o código abaixo.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntab_vendas_cidade <- dados |> \n  #> Renomeia colunas\n  rename(date = data, city = cidade, variable = vendas, value = valor) |> \n  #> Transforma colunas\n  mutate(\n    value = value / 1000,\n    date = readr::parse_date(date, format = \"%Y-%b%-d\", locale = readr::locale(\"pt\")),\n    year = lubridate::year(date)\n    ) |> \n  #> Agrupa pela coluna year e calcula algumas estatísticas\n  group_by(year) |> \n  summarise(\n    total = sum(value),\n    count = n()\n  )\n```\n:::\n\n\nEm base-R o mesmo código ficaria algo como o descrito abaixo.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnames(dados) <- c(\"date\", \"city\", \"variable\", \"value\")\n\ndados$value <- dados$value / 1000\ndados$date <- readr::parse_date(\n  dados$date, format = \"%Y-%b%-d\", locale = readr::locale(\"pt\")\n  )\ndados$year <- lubridate::year(dados$date)\n\ntab_vendas_cidade <- tapply(\n  dados$value,\n  dados$city,\n  \\(x) {data.frame(total = sum(x), count = length(x))}\n  )\n```\n:::\n\n\nHá um tempo atrás argumentava-se contra o uso de \"pipes\", pois estes dificultavam a tarefa de encontrar bugs no código. Isto continua sendo parcialmente verdade, mas as funções do `tidyvserse` atualmente têm mensagens de erro bastante ricas e permitem encontrar a fonte do erro com relativa facilidade. Ainda assim, não se recomenda encadear funções em excesso, i.e., pipes com 10 funções ou mais[^7].\n\n[^7]: Para mais sobre pipes consulte o [meu post sobre o assunto](https://restateinsight.com/posts/general-posts/2023-09-pipes-in-r/).\n\n### Funções\n\nOutra filosofia do `tidyverse` é de que tarefas rotineiras devem ser transformadas em funções específicas. Neste sentido, os pacotes `dplyr`, `tidyr` e afins são recheados de funções, às vezes com nomes muito semelhantes e com usos redundantes. As funções `starts_with` e `ends_with`, por exemplo, são casos específicos da função `matches`. Há funções que permitem até duas formas de grafia como `summarise` e `summarize`. Outras como `slice_min` e `slice_max` são convenientes mas são literalmente: `arrange + slice`.\n\nSomando somente os dois principais pacotes, `dplyr` e `tidyr`, há 360 funções disponíveis. Contraste isto com o `data.table` que permite fazer 95% das transformações de dados somente com `dt[i, j, by = c(), .SDcols = cols]`.\n\nMesmo as funções base do `R` costumam ser mais sucintas do que códigos em `tidyverse`. No exemplo abaixo, a função `tapply` consegue o mesmo resultado que o código mais extenso feito com `dplyr`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntapply(mtcars$mpg, mtcars$cyl, mean)\n\nmtcars |> \n  group_by(cyl) |> \n  summarise(avg = mean(cyl))\n```\n:::\n\n\nAs vantagens do `tidyverse` se tornam mais evidentes com o tempo. De fato, o pacote permite abstrações muito poderosas, e eventualmente, pode-se fazer um código centenas de vezes mais sucinto combinando as suas funções. Em outros casos, as funções do tidyverse são simplesmente muito convenientes.\n\nTome a `starts_with`, por exemplo, que seleciona as colunas que começam de uma certa forma. Suponha uma tabela simples em que há múltiplas colunas cujos nomes começam com a letra \"x\". O código em tidyverse é muito mais limpo que o código em base-R.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf <- df |> \n  select(date, starts_with(\"x\"))\n\ndf <- df[, c(\"date\", names(df)[grep(\"^x\", names(df))])]\ndf <- df[, c(\"date\", names(df)[stringr::str_detect(names(df), \"^x\")])]\n```\n:::\n\n\nO exemplo abaixo é inspirado [neste post](https://www.r-bloggers.com/2023/03/unlocking-the-power-of-purrr-how-to-create-multiple-lags-like-a-pro-in-r/), que mostra como calcular lags de uma série de tempo que esteja em um `data.frame`. Calcular defasagens de uma série de tempo é uma tarefa um pouco árdua quando se usa somente funções base. O código abaixo mostra não somente a elegância do tidyverse mas também a facilidade em se criar funções a partir do tidyverse.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncalculate_lags <- function(df, var, lags) {\n  \n map_lag <- lags |> map(~partial(lag, n = .x))\n out <- df |>\n   mutate(\n     across(.cols = {{var}},\n            .fns = map_lag,\n            .names = \"{.col}_lag{lags}\")\n     )\n \n return(out)\n}\n\ndf <- data.frame(\n  date = time(AirPassengers),\n  value = as.numeric(AirPassengers)\n)\n\ndf |> calculate_lags(value, 1:3) |> head()\n#       date value value_lag1 value_lag2 value_lag3\n# 1 1949.000   112         NA         NA         NA\n# 2 1949.083   118        112         NA         NA\n# 3 1949.167   132        118        112         NA\n# 4 1949.250   129        132        118        112\n# 5 1949.333   121        129        132        118\n# 6 1949.417   135        121        129        132\n```\n:::\n\n\n### Desvantagens\n\nO lado negativo da abordagem \"gramatical\" é que para não-falantes de inglês muitas destas vantagens são despercebidas[^8] e o resultado é somente um código \"verborrágico\", cheio de funções. Além disso, pode-se argumentar que há ambiguidades inerentes na linguagem. A função `filter`, por exemplo, é utilizada para *filtrar* as linhas de um `data.frame`, mas podia, igualmente, chamar-se `select`, que *selecionaria* as linhas de um `data.frame`. A função `select`, contudo, é usada para *selecionar* as colunas de um `data.frame`.\n\n[^8]: No fundo, isto é ainda mais um incentivo para aprender inglês.\n\nUm fato particularmente irritante do `tidyverse` é a frequência com que os pacotes mudam. Na maior parte das vezes, as mudanças são positivas, mas isto faz com que o código escrito em `tidyverse` não seja sustentável ao longo do tempo.\n\nEu demorei um bom tempo para entender as funções `tidyr::gather` e `tidyr::spread` e, atualmente, ambas foram descontinuadas e substituídas pelas funções `pivot_longer` e `pivot_wider`[^9]. As funções `mutate_if`, `mutate_at` e similares do `dplyr` foram todas suprimidas pela sinataxe mais geral do `across`. A função `tidyr::separate` agora está sendo substituída por `separate_wider_position` e `separate_wider_delim`.\n\n[^9]: Tecnicamente, elas foram \"superseded\", ou suplatandas. Isto significa que elas continuam existindo exatamente da forma como sempre existiram e que não receberão mais atualizações.\n\nMesmo um código bem escrito há poucos anos atrás tem grandes chances de não funcionar mais porque as funções foram alteradas ou descontinuadas. Em 2021, Wickham discutiu este problema abertamente [numa palestra](https://posit.co/resources/videos/maintaining-the-house-the-tidyverse-built/). Desde então, o tidyverse tem melhorado a sua política de [manutenção de funções](https://lifecycle.r-lib.org/articles/stages.html).\n\nA velocidade e eficiência das funções do tidyverse pode ser um problema, mas atualmente existem diversas boas soluções como o já citado `tidytable`. Particularmente, são raras as situações em que a velocidade do tidyverse me incomoda.\n\nAtualmente, parece haver um consenso crescente de que a melhor forma de começar a aprender R é começando pelo `tidyverse`; esta visão não é livre de críticos como de [Norm Matloff, professor de estatística da UC Davis](https://matloff.wordpress.com/2022/04/02/greatly-revised-edition-of-tidyverse-skeptic/). Essencialmente, Matloff considera que o `tidyverse` é muito complexo para iniciantes: há muitas funções para se aprender e o incentivo à programação funcional torna o código muito abstrato. O tidyverse também esconde o uso do base-R e não ensina operadores básicos como `[[` e `$`. Matloff também considera que \"pipes\" prejudicam o aprendizado pois dificultam a tarefa de encontrar a fonte dos erros no código.\n\n# À força de uma conclusão\n\nO `tidyverse` é um conjunto de pacotes muito úteis que atualmente dominam o ecossistema do R. Pessoalmente, acredito que a melhor forma de aprender R é começando pelo `tidyverse`. As suas vantagens mais do que compensam as suas falhas. Além disso, o fato dele ser o dialeto dominante de R é, por si só, um bom motivo para aprendê-lo.\n\nA crítica de Matloff é válida em um ponto importante: em grande parte, o tidyverse substitui o base-R e dispensa o seu aprendizado. Isto cria uma lacuna importante que eventualmente vai causar prejuízos. Neste sentido, recomendo dois livros para aprender base-R e os princípios mais gerais da linguagem:\n\n-   [Grolemund, G. Hands-on programming with R](https://rstudio-education.github.io/hopr/)\n\n-   [Wickham, H. Advanced R. 1a ed.](http://adv-r.had.co.nz) - É importante notar a edição. A edição mais recente deste livro omite bastante do base-R.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}