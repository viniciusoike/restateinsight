{
  "hash": "397f6e9f2619b3256db76a67d2838244",
  "result": {
    "markdown": "---\ntitle: \"Cidades Brasil\"\ncategories: ['tutorial-R', 'mapas']\ndraft: true\n---\n\n\n\n\n# O objetivo\n\nO objetivo deste post é conseguir gerar o gráfico abaixo com uma única linha de código. Isto será possível, pois todo o processamento dos dados será feito por funções auxiliares. A inspiração do mapa vem diretamente de [BlakeRMills](https://www.blakerobertmills.com/my-work/visualizations), criador do pacote [{MetBrewer}](https://github.com/BlakeRMills/MetBrewer).\n\nAbaixo segue a lista de todos os pacotes utilizados neste post. Não é necessário chamar todos eles com `library` mas é preciso ter todos eles instalados[^1]. Com exceção dos três primeiros, usaremos somente uma ou duas funções de cada um dos pacotes.\n\n[^1]: Chamar muitos pacotes numa mesma sessão pode levar a muitos conflitos entre funções com o mesmo nome. Isto não é um problema muito sério já que sempre é possível especificar `nome_pacote::nome_funcao`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Principais pacotes\nlibrary(dplyr)\nlibrary(sf)\nlibrary(ggplot2)\n#> Pacotes auxiliares\n#> library(osmdata)\nlibrary(purrr)\nlibrary(rvest)\nlibrary(xml2)\nlibrary(ggthemes)\nlibrary(BAMMtools)\nlibrary(geobr)\nlibrary(elevatr)\nlibrary(raster)\nlibrary(stringr)\nlibrary(purrr)\nlibrary(janitor)\n```\n:::\n\n\n# Recife\n\nPara ganhar intuição sobre o processo vamos montar um único caso. Escolho a cidade de Recife, pois, entre as capitais, ela não é tão grande.\n\n## Baixando os dados\n\nO objetivo é gerar o mapa de altitude das maiores cidades do Brasil. Ao invés de ranquear as cidades por área, eu prefiro ordená-las por tamanho de população. Uma maneira fácil de conseguir esta informação é buscando ela diretamente na Wikipedia. No link temos uma tabela com código do IBGE, nome do município, nome do estado e população total em 2022.\n\nÉ bastante simples importar esta tabela no R. O código abaixo, interpreta a página com base na url, encontra todas as tabelas[^2] e escolhe especificamente a tabela principal.\n\n[^2]: Na verdade, o código encontra todos os elementos com a classe `table` na página.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nurl = \"https://pt.wikipedia.org/wiki/Lista_de_municípios_do_Brasil_por_população\"\n\ntab <- xml2::read_html(url) |> \n  rvest::html_table() |> \n  purrr::pluck(2)\n\nhead(tab)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  Posição `Código IBGE` Município      `Unidade federativa` População \n  <chr>   <chr>         <chr>          <chr>                <chr>     \n1 1º      3550308       São Paulo      São Paulo            11 451 245\n2 2º      3304557       Rio de Janeiro Rio de Janeiro       6 211 423 \n3 3º      5300108       Brasília       Distrito Federal     2 817 068 \n4 4º      2304400       Fortaleza      Ceará                2 428 678 \n5 5º      2927408       Salvador       Bahia                2 418 005 \n6 6º      3106200       Belo Horizonte Minas Gerais         2 315 560 \n```\n:::\n:::\n\n\nEste dado está um pouco sujo então eu limpo a tabela para facilitar nosso trabalho. Após limpar os dados, eu seleciono as 20 cidades mais populosas.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nas_numeric_char <- Vectorize(function(x) {\n  ls <- stringr::str_extract_all(x, \"[[:digit:]]\")\n  y <- paste(ls[[1]], collapse = \"\")\n  as.numeric(y)\n})\n\nclean_tab <- tab |> \n  janitor::clean_names() |> \n  rename(\n    code_muni = codigo_ibge,\n    name_muni = municipio,\n    rank = posicao,\n    name_state = unidade_federativa,\n    pop = populacao\n  ) |> \n  filter(name_muni != \"Brasil\") |> \n  mutate(\n    code_muni = as.numeric(code_muni),\n    pop = as_numeric_char(pop),\n    rank = rank(-pop)\n  )\n\ntop20 <- slice_max(clean_tab, pop, n = 20)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n```{=html}\n<div class=\"datatables html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-5026b4573ca29f83a751\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-5026b4573ca29f83a751\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\"],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],[3550308,3304557,5300108,2304400,2927408,3106200,1302603,4106902,2611606,5208707,4314902,1501402,3518800,3509502,2111300,2704302,5002704,3304904,2211001,2507507],[\"São Paulo\",\"Rio de Janeiro\",\"Brasília\",\"Fortaleza\",\"Salvador\",\"Belo Horizonte\",\"Manaus\",\"Curitiba\",\"Recife\",\"Goiânia\",\"Porto Alegre\",\"Belém\",\"Guarulhos\",\"Campinas\",\"São Luís\",\"Maceió\",\"Campo Grande\",\"São Gonçalo\",\"Teresina\",\"João Pessoa\"],[\"São Paulo\",\"Rio de Janeiro\",\"Distrito Federal\",\"Ceará\",\"Bahia\",\"Minas Gerais\",\"Amazonas\",\"Paraná\",\"Pernambuco\",\"Goiás\",\"Rio Grande do Sul\",\"Pará\",\"São Paulo\",\"São Paulo\",\"Maranhão\",\"Alagoas\",\"Mato Grosso do Sul\",\"Rio de Janeiro\",\"Piauí\",\"Paraíba\"],[11451245,6211423,2817068,2428678,2418005,2315560,2063547,1773733,1488920,1437237,1332570,1303309,1291784,1138309,1037775,957916,897938,896744,866300,833932]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th> <\\/th>\\n      <th>rank<\\/th>\\n      <th>code_muni<\\/th>\\n      <th>name_muni<\\/th>\\n      <th>name_state<\\/th>\\n      <th>pop<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"columnDefs\":[{\"className\":\"dt-right\",\"targets\":[1,2,5]},{\"orderable\":false,\"targets\":0}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\n## Shape da cidade\n\nAgora que temos uma lista de cidades podemos importar o shapefile com os limites territoriais do município do Recife. Graças ao pacote {geobr} isto é muito simples. A função `read_municipality` faz justamente isto e precisa apenas do código de 7 dígitos do IBGE.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncode_muni = top20 |> \n  filter(name_muni == \"Recife\") |> \n  pull(code_muni)\n\nborder = geobr::read_municipality(code_muni)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nDownloading: 1.9 kB     \nDownloading: 1.9 kB     \nDownloading: 11 kB     \nDownloading: 11 kB     \nDownloading: 43 kB     \nDownloading: 43 kB     \nDownloading: 75 kB     \nDownloading: 75 kB     \nDownloading: 150 kB     \nDownloading: 150 kB     \nDownloading: 180 kB     \nDownloading: 180 kB     \nDownloading: 220 kB     \nDownloading: 220 kB     \nDownloading: 260 kB     \nDownloading: 260 kB     \nDownloading: 260 kB     \nDownloading: 260 kB     \n```\n:::\n\n```{.r .cell-code}\nggplot(border) +\n  geom_sf() +\n  ggtitle(\"Limites do município\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Principais vias\n\nO segundo passo é importar o shape das principais vias da cidade. Aqui, uso o {osmdata}. O código abaixo importa as vias como \"linhas\" e depois usa os limites do município para remover os segmentos de linhas que estão fora da cidade.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Define os \"limites\" da busca. Monta um bounding box em torno do Recife\nrec = opq(bbox = getbb(\"Recife, Pernambuco, Brazil\"))\n\n#> Pega as principais vias\nstreets = add_osm_feature(\n  rec,\n  key = \"highway\",\n  value = c(\"primary\", \"secondary\", \"tertiary\", \"residential\")\n  )\n\n#> Converte o objeto para sf (LINESTRING)\nstreets = osmdata_sf(streets)\nstreets = streets$osm_lines\nstreets = select(streets, osm_id, name)\nstreets = st_transform(streets, crs = 4674)\n#> Encontra a intersecção entre as vias e os limites do município\nstreets_border = st_intersection(streets, border)\n```\n:::\n\n\nPara tornar mais evidente o que está acontecendo mostro primeiro o resultado geral, com todas as vias.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(streets) + \n  geom_sf(linewidth = 0.2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nE agora o resultado após a intersecção entre as vias e os limites do município.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = border, fill = NA) +\n  geom_sf(data = streets_border, linewidth = 0.2, color = \"gray20\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Altitude\n\nO terceiro passo é importar os dados de altitude da cidade. Isto é feito com o pacote {elevatr}. Como os dados de altitude são armazenados como raster preciso convertê-los para dados em formato de vetor[^3]. Novamente eu faço a intersecção destes dados com os limites do município para ficar somente com os valores que nos interessam.\n\n[^3]: Para uma introdução aos tipos de objetos espaciais (*raster* e *vector*) veja [Lovelace (2023)](https://r.geocompx.org/spatial-class).\n\nO gráfico abaixo mostra o resultado final.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Importa os dados de altitude\naltitude <- elevatr::get_elev_raster(border, z = 7, clip = \"bbox\")\n#> Converte para 'vector'\nrec_alti <- raster::rasterToPolygons(altitude)\nrec_alti <- sf::st_as_sf(rec_alti)\nnames(rec_alti)[1] <- \"elevation\"\n\n#> Converte o CRS e intersecta com os limites do município\nrec_alti <- rec_alti %>%\n  st_transform(crs = 4674) %>%\n  st_intersection(border) %>%\n  #> Remove geometrias inválidas\n  filter(st_is_valid(.))\n\n#> Mapa\nggplot(rec_alti) +\n  geom_sf(aes(fill = elevation)) +\n  scale_fill_viridis_c(option = \"inferno\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### Classificando a altitude\n\nPara facilitar a visualização dos dados, classifica-se eles em grupos. Eu uso o algoritmo de Jenks para classificar os dados de elevação em 7 grupos distintos. O algoritmo de Jenks, também conhecido como \"quebras naturais\", é bastante utilizado com dados espaciais.\n\nComo todo algoritmo de clustering, o algoritmo de Jenks busca minimizar a distância intraclasse enquanto tenta maximizar a distância entre as classes; isto é ele busca observações parecidas e juntas elas em um grupo e busca separar os grupos o máximo possível.\n\nA medida de distância/dissemelhança que o algoritmo usa é a soma do quadrado dos desvios (em relação à média do grupo). O algortimo busca minimizar esta \"variância\" em cada um dos grupos para encontrar os grupos mais \"parecidos\" possíveis. O número de grupos é arbitrário e precisa ser selecionado manualmente[^4]. Eu costumo escolher algum número entre 3 e 9.\n\n[^4]: Existem alguns métodos que ajudam a escolher um número \"ótimo\" de clusters, como o \"elbow method\" mas vale lembrar que clustering é muito mais arte do que ciência. Clustering envolve agrupar dados semelhantes em um número finito de grupos, mas há inúmeras maneiras de definir \"semelhante\"; além disso, o algoritmo de clustering sempre chega num agrupamento, qualquer que seja a escolha do número de grupos. Assim, é importante frisar que estes resultados são mais explortatórios, por assim dizer.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njbreaks <- BAMMtools::getJenksBreaks(rec_alti$elevation, k = 7)\njbreaks <- round(jbreaks, -1)\n\nrec_alti <- rec_alti %>%\n  mutate(\n    jenks_group = cut(elevation, jbreaks)\n  )\n\n#> Mapa\nggplot(rec_alti) +\n  geom_sf(aes(fill = jenks_group)) +\n  scale_fill_viridis_d(option = \"inferno\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Juntando as partes\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstreet_levels <- list()\n\n\n\nfor (i in seq_along(groups)) {\n  \n}\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_streets_altitude <- function(shp) {\n  \n  stopifnot(any(colnames(shp) %in% \"jenks_group\"))\n  \n  #> Get all groups\n  groups = levels(shp$jenks_group)\n  \n  #> For each group get the full polygon and join with streets\n  join_streets = function(group) {\n    \n    poly = rec_alti %>%\n      filter(jenks_group == group) %>%\n      st_union(.) %>%\n      st_as_sf()\n    \n    joined = st_intersection(streets, poly)\n    \n    return(joined)\n    \n  }\n  #> Apply the function to all groups\n  street_levels = purrr::map(groups, join_streets)\n  #> Bind all results together\n  out = bind_rows(street_levels, .id = \"level\")\n  \n  return(out)\n  \n}\n\nrec_streets_altitude = get_streets_altitude(rec_alti)\n```\n:::\n\n\n## Mapa final\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncores <- c(\n  \"#ffd902\", \"#FFAB28\", \"#FF751B\", \"#FF3E0D\", \"#cc0600\", \"#a20d46\", \"#5f0078\"\n  )\n\njlabels = paste(jbreaks, jbreaks[-1], sep = \"-\")\njlabels[length(jlabels)] = paste0(max(jbreaks), \"+\")\n\nggplot(data = rec_streets_altitude) +\n  geom_sf(aes(color = level, fill = level), linewidth = 0.2) +\n  scale_color_manual(name = \"Altitude\", values = cores, labels = jlabels) +\n  scale_fill_manual(name = \"Altitude\", values = cores, labels = jlabels) +\n  guides(fill = guide_legend(nrow = 1), color = guide_legend(nrow = 1)) +\n  ggtitle(\"Recife\") +\n  ggthemes::theme_map() +\n  coord_sf() +\n  theme(\n    plot.title = element_text(size = 16, hjust = 0.5),\n    legend.position = \"top\",\n    legend.direction = \"horizontal\",\n    legend.text = element_text(size = 10)\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n# Programação funcional\n\nA ideia geral da programação funcional é de transformar nosso código em funções.\n\nFunções compartimentalizam o seu ambiente de trabalho. O que acontece dentro da função, fica dentro da função (a não ser que\n\n## Shape da cidade\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncities_brasil = st_drop_geometry(geobr::read_municipality(showProgress = FALSE))\nstates_brasil = st_drop_geometry(geobr::read_state(showProgress = FALSE))\ncities_brasil = mutate(cities_brasil, code_state = as.numeric(code_state))\ncities_brasil = inner_join(cities_brasil, states_brasil)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_border = function(city) {\n  \n  #> Encontra o código do município\n  code_muni = cities_brasil |> \n    filter(name_muni == city) |> \n    pull(code_muni)\n  \n  #> Baixa o shapefile do município\n  border = geobr::read_municipality(code_muni, showProgress = FALSE)\n  \n  return(border)\n}\n```\n:::\n\n\n## Principais vias\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_streets = function(city, border) {\n  \n  #> Encontra o nome da Unidade Federativa\n  nome_uf = cities_brasil |> \n    filter(name_muni == city) |> \n    pull(name_state)\n  #> Monta o nome do local\n  name_place = stringr::str_glue(\"{city}, {nome_uf}, Brazil\")\n  #> Monta a query\n  place = opq(bbox = getbb(name_place))\n  \n  #> Importa todas as principais vias da cidade\n  streets = add_osm_feature(\n    place,\n    key = \"highway\",\n    value = c(\"primary\", \"secondary\", \"tertiary\", \"residential\")\n    )\n  \n  #> Converte o dado\n  streets = streets %>%\n    osmdata_sf() %>%\n    .$osm_lines %>%\n    select(osm_id, name) %>%\n    st_transform(crs = 4674)\n  \n  #> Enconrtra a intersecção entre as estradas e o limites do município\n  streets_border = st_intersection(streets, border)\n  \n  out = list(streets = streets, streets_border = streets_border)\n  \n  return(out)\n  \n}\n```\n:::\n\n\n## Altitude\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_elevation <- function(border) {\n  \n  altitude <- elevatr::get_elev_raster(border, z = 7, clip = \"bbox\")\n  altitude <- raster::rasterToPolygons(altitude)\n  altitude <- st_as_sf(altitude)\n  names(altitude)[1] <- \"elevation\"\n  \n  altitude = st_transform(altitude, crs = 4674)\n  altitude = suppressWarnings(st_intersection(altitude, border))\n  altitude = filter(altitude, st_is_valid(altitude))\n  \n  return(altitude)\n  \n}\n```\n:::\n\n\n### Classificando\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nadd_jenks_breaks = function(shp, k = 7, round = TRUE, r = 0) {\n  #> Classifica os dados de altitude em k grupos segundo o algo. de Jenks\n  jbreaks = BAMMtools::getJenksBreaks(shp$elevation, k = k)\n  #> Arredonda os números para chegar numa legenda menos quebrada\n  if (round) {\n    jbreaks = round(jbreaks, r)\n  }\n  #> Cria a coluna 'jenks_group' que classifica cada valor num grupo\n  shp = mutate(shp, jenks_group = cut(elevation, jbreaks))\n  \n  #> Verifica se todas as observações tem um grupo\n  check = any(is.na(shp$jenks_group))\n  if (check) {\n    warning(\"Some observations have failed to be grouped\")\n  }\n  \n  #> Transforma os groups em legendas\n  labels = get_jenks_labels(jbreaks)\n  \n  #> Retorna o output numa lista\n  out = list(shp = shp, labels = labels)\n  return(out)\n  \n}\n\nget_jenks_labels <- function(x) {\n  labels = paste(x, x[-1], sep = \"-\")\n  labels[length(labels)] = paste0(max(x), \"+\")\n  return(labels)\n}\n```\n:::\n\n\n## Juntando as partes\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_streets_altitude <- function(altitude, streets) {\n  \n  stopifnot(any(colnames(altitude) %in% \"jenks_group\"))\n  \n  #> Get all groups\n  groups = levels(altitude$jenks_group)\n  \n  #> For each group get the full polygon and join with streets\n  join_streets = function(group) {\n    \n    poly = altitude %>%\n      filter(jenks_group == group) %>%\n      st_union(.) %>%\n      st_as_sf()\n    \n    joined = suppressWarnings(st_intersection(streets, poly))\n    \n    return(joined)\n    \n  }\n  #> Apply the function to all groups\n  street_levels = purrr::map(groups, join_streets)\n  #> Bind all results together\n  out = bind_rows(street_levels, .id = \"level\")\n  \n  return(out)\n  \n}\n```\n:::\n\n\n## Mapa\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap_plot = function(shp, labels, title, showtext = TRUE) {\n  \n  cores = c(\n  \"#ffd902\", \"#FFAB28\", \"#FF751B\", \"#FF3E0D\", \"#cc0600\", \"#a20d46\", \"#5f0078\"\n  )\n  \n  font = ifelse(showtext == TRUE, \"Roboto Condensed\", \"sans\")\n  \n  plot =\n    ggplot(data = shp) +\n    geom_sf(aes(color = level, fill = level), linewidth = 0.2) +\n    scale_color_manual(name = \"Altitude\", values = cores, labels = labels) +\n    scale_fill_manual(name = \"Altitude\", values = cores, labels = labels) +\n    guides(fill = guide_legend(nrow = 1), color = guide_legend(nrow = 1)) +\n    ggtitle(title) +\n    ggthemes::theme_map() +\n    coord_sf() +\n    theme(\n      plot.title = element_text(\n        size = 16,\n        hjust = 0.5,\n        family = font\n        ),\n      legend.text = element_text(\n        size = 10,\n        family = font,\n        color = \"gray10\"\n        ),\n      legend.position = \"top\",\n      legend.direction = \"horizontal\"\n    )\n  \n  return(plot)\n  \n}\n```\n:::\n\n\n## Uma função final\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap_altitude <- function(city, full = FALSE) {\n  \n  #> Importa o shape do limite do município\n  message(\"Importando os limites do município: \", city)\n  city_border = get_border(city)\n  #> Importa as principais vias da cidade e junta com o limite do muni\n  message(\"Importando as vias.\")\n  city_street = get_streets(city, city_border)\n  #> Importa a altitude da cidade\n  message(\"Importando a altitude.\")\n  city_elevation = suppressMessages(get_elevation(city_border))\n  #> Classifica a altitude em grupos\n  message(\"Classificando e juntando os shapefiles.\")\n  jenks = add_jenks_breaks(city_elevation)\n  city_elevation = jenks[[\"shp\"]]\n  labels = jenks[[\"labels\"]]\n  #> Junta a altitude (agrupada) com as vias\n  if (full) {\n    city_street <- city_street$streets\n  } else {\n    city_street <- city_street$streets_border\n  }\n  city_street_elevation = get_streets_altitude(city_elevation, city_street)\n  \n  #> Monta o mapa final\n  message(\"Gerando o mapa final.\")\n  plot = map_plot(city_street_elevation, labels = labels, title = city)\n  message(\"Feito.\")\n  #> Retorna o output numa lista\n  out <- list(\n    shp = city_street_elevation,\n    streets = city_street,\n    elevation = city_elevation,\n    plot = plot\n    )\n  \n  return(out)\n  \n}\n```\n:::\n\n\n## Testando a função\n\nFunciona!\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap_altitude(\"Porto Alegre\")$plot\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){fig-align='center' width=100%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap_altitude(\"Ouro Preto\")$plot\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-1.png){fig-align='center' width=100%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nexport_citymap = function(city, w = 14, h = 16) {\n  \n  plot = map_altitude(city)$plot\n  \n  name_file = glue::glue(\n    \"elevation_{janitor::make_clean_names(city)}.svg\"\n    )\n  \n  ggsave(\n    here::here(\"static/maps/\", name_file),\n    plot,\n    width = w,\n    height = h\n    )\n}\n\nmap(top20$name_city, export_citymap)\n```\n:::\n\n\n# Resultado final\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(dplyr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(osmdata)\nlibrary(purrr)\n\ncities_brasil = st_drop_geometry(geobr::read_municipality(showProgress = FALSE))\nstates_brasil = st_drop_geometry(geobr::read_state(showProgress = FALSE))\ncities_brasil = mutate(cities_brasil, code_state = as.numeric(code_state))\ncities_brasil = inner_join(cities_brasil, states_brasil)\n\nget_border = function(city) {\n  \n  #> Encontra o código do município\n  code_muni = cities_brasil |> \n    filter(name_muni == city) |> \n    pull(code_muni)\n  \n  #> Baixa o shapefile do município\n  border = geobr::read_municipality(code_muni, showProgress = FALSE)\n  \n  return(border)\n}\n\nget_streets = function(city, border) {\n  \n  #> Encontra o nome da Unidade Federativa\n  nome_uf = cities_brasil |> \n    filter(name_muni == city) |> \n    pull(name_state)\n  #> Monta o nome do local\n  name_place = stringr::str_glue(\"{city}, {nome_uf}, Brazil\")\n  #> Monta a query\n  place = opq(bbox = getbb(name_place))\n  \n  #> Importa todas as principais vias da cidade\n  streets = add_osm_feature(\n    place,\n    key = \"highway\",\n    value = c(\"primary\", \"secondary\", \"tertiary\", \"residential\")\n    )\n  \n  #> Converte o dado\n  streets = streets %>%\n    osmdata_sf() %>%\n    .$osm_lines %>%\n    select(osm_id, name) %>%\n    st_transform(crs = 4674)\n  \n  #> Enconrtra a intersecção entre as estradas e o limites do município\n  streets_border = st_intersection(streets, border)\n  \n  out = list(streets = streets, streets_border = streets_border)\n  \n  return(streets_border)\n  \n}\n\nget_elevation <- function(border) {\n  \n  altitude <- elevatr::get_elev_raster(border, z = 7, clip = \"bbox\")\n  altitude <- raster::rasterToPolygons(altitude)\n  altitude <- st_as_sf(altitude)\n  names(altitude)[1] <- \"elevation\"\n  \n  altitude = st_transform(altitude, crs = 4674)\n  altitude = suppressWarnings(st_intersection(altitude, border))\n  altitude = filter(altitude, st_is_valid(altitude))\n  \n  return(altitude)\n  \n}\n\nadd_jenks_breaks = function(shp, k = 7, round = TRUE, r = -1) {\n  #> Classifica os dados de altitude em k grupos segundo o algo. de Jenks\n  jbreaks = BAMMtools::getJenksBreaks(shp$elevation, k = k)\n  #> Arredonda os números para chegar numa legenda menos quebrada\n  if (round) {\n    jbreaks = round(jbreaks, r)\n  }\n  #> Cria a coluna 'jenks_group' que classifica cada valor num grupo\n  shp = mutate(shp, jenks_group = cut(elevation, jbreaks))\n  \n  #> Verifica se todas as observações tem um grupo\n  check = any(is.na(shp$jenks_group))\n  if (check) {\n    warning(\"Some observations have failed to be grouped\")\n  }\n  \n  #> Transforma os groups em legendas\n  labels = get_jenks_labels(jbreaks)\n  \n  #> Retorna o output numa lista\n  out = list(shp = shp, labels = labels)\n  return(out)\n  \n}\n\nget_jenks_labels <- function(x) {\n  labels = paste(x, x[-1], sep = \"-\")\n  labels[length(labels)] = paste0(max(x), \"+\")\n  return(labels)\n}\n\nget_streets_altitude <- function(altitude, streets) {\n  \n  stopifnot(any(colnames(altitude) %in% \"jenks_group\"))\n  \n  #> Get all groups\n  groups = levels(altitude$jenks_group)\n  \n  #> For each group get the full polygon and join with streets\n  join_streets = function(group) {\n    \n    poly = altitude %>%\n      filter(jenks_group == group) %>%\n      st_union(.) %>%\n      st_as_sf()\n    \n    joined = suppressWarnings(st_intersection(streets, poly))\n    \n    return(joined)\n    \n  }\n  #> Apply the function to all groups\n  street_levels = purrr::map(groups, join_streets)\n  #> Bind all results together\n  out = bind_rows(street_levels, .id = \"level\")\n  \n  return(out)\n  \n}\n\nmap_plot = function(shp, labels, title, showtext = TRUE) {\n  \n  cores = c(\n  \"#ffd902\", \"#FFAB28\", \"#FF751B\", \"#FF3E0D\", \"#cc0600\", \"#a20d46\", \"#5f0078\"\n  )\n  \n  font = ifelse(showtext == TRUE, \"Roboto Condensed\", \"sans\")\n  \n  plot =\n    ggplot(data = shp) +\n    geom_sf(aes(color = level, fill = level), linewidth = 0.2) +\n    scale_color_manual(name = \"Altitude\", values = cores, labels = labels) +\n    scale_fill_manual(name = \"Altitude\", values = cores, labels = labels) +\n    guides(fill = guide_legend(nrow = 1), color = guide_legend(nrow = 1)) +\n    ggtitle(title) +\n    ggthemes::theme_map() +\n    coord_sf() +\n    theme(\n      plot.title = element_text(\n        size = 16,\n        hjust = 0.5,\n        family = font\n        ),\n      legend.text = element_text(\n        size = 10,\n        family = font,\n        color = \"gray10\"\n        ),\n      legend.position = \"top\",\n      legend.direction = \"horizontal\"\n    )\n  \n  return(plot)\n  \n}\n\nmap_altitude <- function(city) {\n  \n  #> Importa o shape do limite do município\n  message(\"Importando os limites do município: \", city)\n  city_border = get_border(city)\n  #> Importa as principais vias da cidade e junta com o limite do muni\n  message(\"Importando as vias.\")\n  city_street = get_streets(city, city_border)\n  #> Importa a altitude da cidade\n  message(\"Importando a altitude.\")\n  city_elevation = suppressMessages(get_elevation(city_border))\n  #> Classifica a altitude em grupos\n  message(\"Classificando e juntando os shapefiles.\")\n  jenks = add_jenks_breaks(city_elevation)\n  city_elevation = jenks[[\"shp\"]]\n  labels = jenks[[\"labels\"]]\n  #> Junta a altitude (agrupada) com as vias\n  city_street_elevation = get_streets_altitude(city_elevation, city_street)\n  \n  #> Monta o mapa final\n  message(\"Gerando o mapa final.\")\n  plot = map_plot(city_street_elevation, labels = labels, title = city)\n  message(\"Feito.\")\n  #> Retorna o output numa lista\n  return(list(shp = city_street_elevation, plot = plot))\n  \n}\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../../site_libs/htmlwidgets-1.6.2/htmlwidgets.js\"></script>\n<link href=\"../../../site_libs/datatables-css-0.0.0/datatables-crosstalk.css\" rel=\"stylesheet\" />\n<script src=\"../../../site_libs/datatables-binding-0.28/datatables.js\"></script>\n<script src=\"../../../site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"../../../site_libs/dt-core-1.13.4/css/jquery.dataTables.min.css\" rel=\"stylesheet\" />\n<link href=\"../../../site_libs/dt-core-1.13.4/css/jquery.dataTables.extra.css\" rel=\"stylesheet\" />\n<script src=\"../../../site_libs/dt-core-1.13.4/js/jquery.dataTables.min.js\"></script>\n<link href=\"../../../site_libs/crosstalk-1.2.0/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"../../../site_libs/crosstalk-1.2.0/js/crosstalk.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}