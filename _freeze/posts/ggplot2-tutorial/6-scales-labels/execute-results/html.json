{
  "hash": "effe0b4beab7915a0a6464dc286f80b8",
  "result": {
    "markdown": "---\ntitle: 'Estético: Escalas e Cores'\ndate: '2023-09-05'\ncategories: ['data-visualization', 'ggplot2', 'tutorial-R']\ndescription: \"Escalas, legendas e cores são elementos essenciais numa boa visualização. Este post apresenta a lógica das funções que controlam as escalas do gráfico e as suas cores com diversos exemplos.\"\nimage: \"/static/ggplot2_scales.svg\"\nimage-alt: \"/static/ggplot2_scales.svg\"\nexecute: \n  message: false\n  warning: false\nformat:\n  html:\n    code-fold: false\n    code-tools: true\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n# Escalas e Cores\n\nEste post é o primeiro da série de tutoriais que não vai tratar de um tipo de gráfico ou, mais especificamente, de um tipo de `geom`. Escalas, no contexto do `ggplot2` são tanto os eixos do gráfico como as suas cores, quando usa-se a função `aes` para mapear alguma variável em cores. As funções `scale_*` controlam todos os aspectos das escalas, incluindo as cores e as suas respectivas legendas.\n\nAlguns aspectos mais detalhados das escalas, como a fonte do texto, o tamanho, etc. são controlados por uma função mais específica `theme`. Em alguns exemplos deste post eu apresento como utilizar esta função, mas uma apresentação mais formal fica postergada para outro momento. A função `theme` é talvez a mais burocrática e complexa do pacote `ggplot2`.\n\nO código abaixo lista os pacotes necessários para acompanhar este post.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Os pacotes necessários para acompanhar este post\nlibrary(ggplot2)\nlibrary(scales)\nlibrary(dplyr)\nlibrary(forcats)\nlibrary(stringr)\nlibrary(readr)\n#> Importa os dados limpos da Zona OD.\npod <- read_csv(\"https://github.com/viniciusoike/restateinsight/raw/main/posts/ggplot2-tutorial/table_pod.csv\")\n#> Seleciona apenas zonas de São Paulo com população acima de zero\npod <- filter(pod, code_muni == 36, pop > 0)\n```\n:::\n\n\nPara este post, além das bases de dados que já acompanham o pacote `ggplot2` também uso a base da [Pesquisa Origem e Destino (POD) de São Paulo](https://www.metro.sp.gov.br/pesquisa-od/), de 2018. A POD é uma pesquisa feita pela companhia Metrô de São Paulo que compila informações sobre os deslocamentos diários da população da Região Metropolitana de São Paulo. Além de dados sobre mobilidade, a POD também reúne uma série de informações socioeconômicas. Os dados são agregados a nível de Zona Origem e Destino ou Zona OD; as zonas OD são subconjuntos de distritos de São Paulo e das demais cidades da Região Metropolitana e, na prática, são como bairros de cada cidade[^1].\n\n[^1]: Vale lembrar, que a cidade de São Paulo não possui uma divisão oficial de bairros, apenas de distritos e subprefeituras.\n\nEu mesmo tratei a base e as funções utilizadas para montar esta tabela estão disponíveis no [repositório {tidypod}](https://github.com/viniciusoike/tidypod) do meu GitHub.\n\nNeste post vou explorar apenas as zonas OD da cidade de São Paulo, excluindo as zonas \"não-residenciais\", como a Cidade Universitária (campus da USP).\n\n# Escalas\n\nEscalas, no contexto do `ggplot`, significam tanto a manipulação dos eixos do gráfico como das cores dos elementos. Há uma infinidade de funções `scale_*` e não vale a pena entrar nos detalhes de cada uma delas. Neste post vou discutir a lógica geral destas funções e apresentar aquelas que acredito que possam ser as mais úteis.\n\nO uso de escalas de cores e legendas está intimamente ligado ao tipo de variável que se está visualizando. Para entender melhor o funcionamento das escalas é preciso compreender o tipo de variável que se vai plotar e como o `R` interpreta esta variável. A próxima seção vai revisar a distinção entre variáveis contínuas e variáveis discretas e como estes dados são processados e armazenados no `R`.\n\n## Tipos de variáveis\n\nO `ggplot`, grosso modo, divide as variáveis em **contínuas** e **discretas**. As variáveis contínuas, em geral, são numéricas e podem assumir qualquer valor; já as variáveis discretas costumam ser \"categóricas\" e são \"contáveis\". O preço de um imóvel, por exemplo, é uma variável contínua. Já uma variável que categoriza um imóvel entre \"casa\" e \"apartamento\" é uma variável discreta.\n\nEsta lógica é aplicada nas funções que controlam os eixos x e y de um gráfico.\n\n-   `scale_y_continuous()`\n-   `scale_y_discrete()`\n-   `scale_x_continuous()`\n-   `scale_x_discrete()`\n\nUma lógica muito similar se aplicas às principais funções que controlam as cores e a legenda de cores de um gráfico:\n\n-   `scale_color_continuous()`\n-   `scale_color_discrete()`\n-   `scale_fill_continuous()`\n-   `scale_fill_discrete()`\n\nMesmo quando modificamos outros aspectos estéticos do gráfico como `size` e `alpha` temos:\n\n-   `scale_alpha_continuous()`\n-   `scale_alpha_discrete()`\n-   `scale_size_continuous()`\n-   `scale_size_discrete()`\n\n### Variáveis contínuas\n\nUma variável contínua costuma representar algum número. No R há várias formas de armazenar números, mas isto não costuma ser muito relevante para a tarefa de visualização dos dados. Na maior parte dos casos, basta garantir que a coluna numérica em questão seja um número usando `is.numeric()` ou `as.numeric()`.\n\nComo mencionado acima, exemplos comuns de variáveis contínuas são: preço de um imóvel, salário de um indivíduo, a taxa de inflação num mês, etc.\n\n### Variáveis discretas\n\nUma variável discreta costuma representar uma categoria. No R existe uma classe especial de variável para armazenar este tipo de dado chamada `factor`. Um `factor` é um vetor de texto ou de números que segue uma *ordem*. Além de ter uma ordem, cada elemento pode ter um `label`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfactor(x = c(...), levels = c(...), labels = c(...))\n```\n:::\n\n\nPara se definir um factor basta usar a função homônima. Note que na ausência de uma ordem explicitamente definida, o `R` organiza o vetor em ordem alfabética. Se, ao invés de um vetor de texto tivéssemos usado um vetor de números, eles teriam sido ordenados no sentido ascedente (do menor para o maior).\n\nPara acessar a ordem do `factor` pode-se usar a função `order()` ou, mais especificamente, a função `levels()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Criando um factor \nmedalhas <- factor(c(\"ouro\", \"prata\", \"bronze\"))\n#> [1] ouro   prata  bronze\n#> Levels: bronze ouro prata\n\n#> Conferindo a ordem dos elementos\norder(medalhas)\n#> [1] 3 1 2\nlevels(medalhas)\n#> [1] \"bronze\" \"ouro\"   \"prata\" \n```\n:::\n\n\nO código abaixo recria o `factor`, deixando mais explícito a estrutura deste tipo de objeto. Note que o argumento `levels` e `labels` não precisam ser repetidos.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Criando um factor \nmedalhas <- factor(\n  c(\"ouro\", \"prata\", \"bronze\", \"bronze\", \"ouro\", \"bronze\"),\n  levels = c(\"bronze\", \"prata\", \"ouro\"),\n  labels = c(\"Bronze\", \"Prata\", \"Ouro\")\n  )\n\nmedalhas\n#> [1] Ouro   Prata  Bronze Bronze Ouro   Bronze\n#> Levels: Bronze Prata Ouro\n```\n:::\n\n\nTrabalhar com factors pode ser uma tarefa bastante frustrante. Neste sentido, recomendo muito o uso do pacote `forcats`, que provê uma série de funções `fct_*` que facilitam muito a manipulação deste tipo de objeto. Os exemplos abaixo mostram algumas das funções mais úteis deste pacote.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf <- data.frame(\n  x = c(5, 2, 3),\n  y = factor(c(\"bronze\", \"prata\", \"ouro\"))\n)\n\n#> Troca a ordem do factor segundo algum outro vetor\nfct_reorder(df$y, df$x)\n#> [1] bronze prata  ouro  \n#> Levels: prata ouro bronze\n\n#> Troca os labels do factor usando uma função\nfct_relabel(df$y, toupper)\n#> [1] BRONZE PRATA  OURO  \n#> Levels: BRONZE OURO PRATA\n\n#> Troca os labels do factor manualmente\nfct_recode(df$y, \"Bronze\" = \"bronze\")\n#> [1] Bronze prata  ouro  \n#> Levels: Bronze ouro prata\n\n#> Conta a ocorrência de cada factor\nfct_count(df$y)\n#> A tibble: 3 × 2\n#>   f          n\n#>   <fct>  <int>\n#> 1 bronze     1\n#> 2 ouro       1\n#> 3 prata      1\n```\n:::\n\n\nPor fim, vale comentar brevemente sobre uma particularidade de um `factor` criado a partir de uma variável numérica. Para converter um factor de texto em character basta usar `as.character(x)`. Para converter de volta um factor de números é preciso usar `as.numeric(as.character(x))`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(1, 10, 2, 5, 1)\ny <- as.factor(x)\n\n#> Por padrão, as.numeric retorna a ordem do factor. Equivalente a order()\nas.numeric(y)\n#> [1] 1 4 2 3 1\n\n#> Para converter de volta no número original\nas.numeric(as.character(y))\n#> [1]  1 10  2  5  1\n```\n:::\n\n\n## Escalas: o básico\n\n### Escalas Contínuas\n\nVamos começar com um gráfico simples que mostra a renda domiciliar média da Zona OD no eixo-x e o número médio de carros por domicílio no eixo-y.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = income_avg, y = car_rate)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nNo caso do gráfico acima, ambas as variáveis são contínuas, portanto, para alterar algum dos eixos usa-se as funções `scale_x_continuous()` e `scale_y_continuous()`. Estas funções tem 5 argumentos principais: `name`, `breaks`, `labels`, `limits` e `expand`.\n\nO argumento `name` define o título do eixo. Alternativamente, pode-se usar a função `labs`, como fizemos em posts anteriores.\n\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Define o título de cada eixo usando as funções scale\nggplot(pod, aes(x = income_avg, y = car_rate)) +\n  geom_point() +\n  scale_x_continuous(name = \"Renda Domiciliar Média (R$)\") +\n  scale_y_continuous(name = \"Automóveis por domicílio\")\n\n#> Define o título de cada eixo usando a função labs\nggplot(pod, aes(x = income_avg, y = car_rate)) +\n  geom_point() +\n  labs(x = \"Renda Domiciliar Média (R$)\", y = \"Automóveis por domicílio\")\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-10-1.png){fig-align='center' width=50%}\n:::\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-10-2.png){fig-align='center' width=50%}\n:::\n:::\n\n\nPara controlar as 'quebras' do eixo-x (os pontos onde aparece cada número) usa-se o argumento `breaks`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = income_avg, y = car_rate)) +\n  geom_point() +\n  scale_x_continuous(breaks = seq(0, 20000, 2500))\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nPor padrão, o número exibido no gráfico é igual ao argumento fornecido em `breaks`, mas pode-se alterar isto usando `labels`. Para ser mais preciso: `breaks` define a posição onde o `labels` vai ser exibido.\n\nNo exemplo abaixo uso o fato do salário mínimo, à época da pesquisa, ser de R\\$954.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = income_avg, y = car_rate)) +\n  geom_point() +\n  scale_x_continuous(\n    breaks = 954 * c(2, 4, 6, 10, 15),\n    labels = stringr::str_glue(\"{c(2, 4, 6, 10, 15)} S.M.\")\n    )\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-12-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nO argumento `labels` pode ser qualquer texto, desde que ele tenha o mesmo número de elementos que o argumento `breaks`. O pacote `scales` oferece algumas funções `label_*` pré-definidas que auxiliam a formatar as escalas. O exemplo abaixo mostra como usar a função `label_dollar` para formatar o eixo-x.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = income_avg, y = car_rate)) +\n  geom_point() +\n  scale_x_continuous(\n    breaks = seq(0, 20000, 2500),\n    labels = label_dollar(big.mark = \".\")\n    )\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-13-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nNa minha experiência, as funções mais úteis do pacote são:\n\n-   `label_number()`: usado para formar números de maneira geral\n-   `label_percent()`: usado para formatar números expressados percentualmente\n-   `label_dollar()`: usado para formatar números que representam dinheiro\n\nPara seguir o padrão brasileiro, utiliza-se `big.mark = \".\"` e `decimal.mark = \",\"`.\n\nPara dar um \"zoom-in\" no gráfico pode-se alterar o argumento `limits`. Este argumento recebe um par de números para definir o número máximo e mínimo que deve ser plotado. Para deixar o eixo \"livre\" basta definir o valor como `NA`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = income_avg, y = car_rate)) +\n  geom_point() +\n  scale_x_continuous(limits = c(3000, 5000)) +\n  scale_y_continuous(limits = c(NA, 1))\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nPor fim, o argumento `expand` diminui ou aumenta a distância entre o gráfico e o limite dos eixos. A aplicação mais comum disso é para reduzir o espaço em branco que \"sobra\" em alguns gráficos.\n\nO par de histogramas abaixo mostra a distribuição do número médio de automóveis por domicílio entre as zonas OD.\n\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = car_rate)) +\n  geom_histogram(bins = 12, color = \"white\")\n\nggplot(pod, aes(x = car_rate)) +\n  geom_histogram(bins = 12, color = \"white\") +\n  scale_x_continuous(expand = c(0, 0))\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-15-1.png){fig-align='center' width=50%}\n:::\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-15-2.png){fig-align='center' width=50%}\n:::\n:::\n\n\n### Escalas discretas\n\nEscalas discretas funcionam praticamente da mesma forma. Uma distinção importante é que, no caso de uma variável discreta ou categórica, o eixo - por padrão - vai plotar o `label` da variável.\n\nO código abaixo encontra os 5 distritos mais populosos de São Paulo.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Seleciona os cinco distritos mais populosos\ndstr_pop <- pod |> \n  #> Soma a variável pop em cada distrito\n  summarise(total_pop = sum(pop), .by = \"name_district\") |> \n  #> Encontra os cinco valores mais elevados \n  slice_max(total_pop, n = 5) |> \n  #> Converte a variável `name_district` para factor\n  mutate(name_district = factor(name_district))\n\nggplot(dstr_pop, aes(x = name_district, y = total_pop)) +\n  geom_col()\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-16-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nCaso não se queira alterar o tipo da variável é possível definir os `labels` diretamente na função `scale_x_discrete()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(dstr_pop, aes(x = name_district, y = total_pop)) +\n  geom_col() +\n  scale_x_discrete(\n    labels = c(\"Capão Redondo\", \"Grajaú\", \"Jd. Ângela\", \"Jd. São Luis\",\n               \"Sapopemba\")\n    )\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-17-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nPor fim, vale notar que o argumento `labels` aceita uma função. Neste caso, fornece-se apenas o nome da função, sem argumentos explícitos. O gráfico abaixo mostra quatro exemplos.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbase_plot <- ggplot(dstr_pop, aes(x = name_district, y = total_pop)) +\n  geom_col() +\n  coord_flip() +\n  labs(x = NULL, y = NULL)\n\n#> Texto maísculo\nbase_plot + scale_x_discrete(labels = stringr::str_to_upper)\n#> Texto minúsculo\nbase_plot + scale_x_discrete(labels = stringr::str_to_lower)\n#> Texto em formato de 'título'\nbase_plot + scale_x_discrete(labels = stringr::str_to_title)\n#> Quebras de linha automáticas no texto\nbase_plot + scale_x_discrete(labels = \\(x) stringr::str_wrap(x, width = 8))\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-19-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nNo exemplo acima, utiliza-se a função `stringr::str_to_upper` para converter o texto do eixo x para maiúsculo.\n\nNo caso de uma função que precisa de um argumento adicional, como é o caso da função `stringr::str_wrap` é preciso criar uma 'função anônima'. Uma função anônima funciona exatamente como uma função convencional e permite que um argumento adicional seja inserido.\n\nA sintaxe para definir uma função anônima é simplesmente `function(x) g(x, ...)` onde `g(x)` é alguma função qualquer. Por exemplo. `function(x) mean(x, na.rm = TRUE)`. Alternativamente, é possível definir uma função anônima simplesmente com `\\(x)`.\n\n## Um pouco mais de escalas\n\nAlém das funções `scale_*` há também algumas mais específicas. O código abaixo apresenta a função `scale_x_log10()` que, como o nome sugere, aplica uma transformação log na variável x.\n\nUma das vantagens de usar esta função, ao invés de transformar os dados usando a função `log()`, ou mesmo de usar `trans = 'log'` dentro de `scale_x_continuous()`, é que as quebras do eixo-x fiquem num formato num formato mais bonito como se vê abaixo.\n\nDe maneira geral, a função `scale_x_log10()` é útil quando há variância crescente nos dados ou a variável segue algum tipo de crescimento exponencial.\n\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = income_avg, y = car_rate)) +\n  geom_point() +\n  scale_x_log10()\n\nggplot(pod, aes(x = income_avg, y = car_rate)) +\n  geom_point() +\n  scale_x_continuous(trans = \"log\")\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-20-1.png){fig-align='center' width=50%}\n:::\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-20-2.png){fig-align='center' width=50%}\n:::\n:::\n\n\nOutra função interessante que eventualmente pode ser útil é a `scale_*_reverse()` que inverte a direção dos dados. Esta função é muito mais prática do que, por exemplo, trocar o sinal do dado original e aí utilizar o argumento `labels` para ajustar os números.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = income_avg, y = car_rate)) +\n  geom_count() +\n  scale_y_reverse()\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-21-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nPor fim, outra função interessante é a `scale_*_binned()`, que ajuda a discretizar uma varíalvel contínua. Ela funciona de maneira similar a um historgrama, argupando uma variável contínua em grupos: isto facilita a observação de padrões nos dados. No caso do gráfico abaixo, vê-se que o grupo mais comum é de zonas com renda entre R\\\\\\$4000 e R\\\\\\$6000 com número médio de automóveis por domicílios entre 0,6 e 0,8.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = income_avg, y = car_rate)) +\n  geom_count() +\n  scale_x_binned() +\n  scale_y_binned()\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-22-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n## Datas\n\nUm dado em formato de data é significativamente mais complicado do que as variáveis contínuas e discretas que vimos acima. Existem inúmeros formatos distintos para se apresentar datas que variam de local para local; além disso, pode ser necessário lidar com fusos horários, feriados, anos bissextos, etc.\n\nIdealmente, toda coluna com datas deve sempre estar no formato YYYY-MM-DD, isto é, `2014-01-15` (15 de janeiro de 2014). Para converter um `character` em `Date` basta usar a função `as.Date`. Se a data não estiver no formato YYYY-MM-DD será necessário especificar o formato usando o argumento `format`. Para casos mais complexos recomendo o uso do pacote [{lubridate}](https://lubridate.tidyverse.org).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(\"2014-01-01\", \"2014-02-01\")\ny <- c(\"01/01/2014\", \"01/02/2014\")\n\nas.Date(x)\n#> [1] \"2014-01-01\" \"2014-02-01\"\nas.Date(y, format = \"%d/%m/%Y\")\n#> [1] \"2014-01-01\" \"2014-02-01\"\n```\n:::\n\n\nComo datas têm uma classe especial elas, por conseguinte, têm também algumas funções dedicadas. A função `scale_x_date` tem dois argumentos principais[^2]:\n\n[^2]: Existe também a função `scale_y_date` mas datas quase sempre são apresentadas no eixo-x.\n\n-   `date_breaks`: que aceita valores como \"1 year\", \"3 months\", etc.\n-   `date_labels`: que aceita valores como \"%Y%m%d\", \"%Y%b\", etc.\n\nVou apresentar esta função de maneira breve, diretamente atráveis de exemplos. O exemplo abaixo mostra o funcionamento geral desta função.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(economics, aes(x = date, y = psavert)) +\n  geom_line() +\n  scale_x_date(date_breaks = \"5 year\", date_labels = \"%Y\")\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-24-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nO próximo exemplo mostra como exibir o número do ano junto com a nome abreviado do mês. Note como o uso de `\\n` quebra a linha no eixo-x.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprices_austin <- txhousing %>%\n  filter(city == \"Austin\", year %in% 2007:2011) %>%\n  mutate(date = lubridate::make_date(year, month))\n\nggplot(prices_austin, aes(x = date, y = sales)) +\n  geom_line() +\n  scale_x_date(date_breaks = \"3 month\", date_labels = \"%Y\\n%b\")\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-25-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nPara escolher datas específicas, usa-se o argumento convencional `breaks`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndatas <- c(as.Date(\"2007-01-01\"), as.Date(\"2008-07-30\"), as.Date(\"2010-03-01\"))\n\nggplot(prices_austin, aes(x = date, y = sales)) +\n  geom_line() +\n  scale_x_date(breaks = datas, date_labels = \"%Y\\n%b\")\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-26-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nO exemplo abaixo pula alguns passos, já que ainda não se apresentou formalmente a função `theme`. Essencialmente, a função `theme` diminui o número de linhas verticais no fundo do gráfico e gira o texto do eixo-x em 90 graus.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprices_austin10 <- txhousing %>%\n  filter(city == \"Austin\", year %in% 2010:2011) %>%\n  mutate(date = lubridate::make_date(year, month))\n\nggplot(prices_austin10, aes(x = date, y = sales)) +\n  geom_line() +\n  scale_x_date(\n    breaks = seq(as.Date(\"2010-01-01\"), as.Date(\"2011-12-01\"), by = \"month\"),\n    date_labels = \"%Y-%m\"\n    ) +\n  theme(\n    panel.grid.minor = element_blank(),\n    axis.text.x = element_text(angle = 90)\n  )\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-27-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nA tabela abaixo resume como funciona a codificação dos padrões de datas. Vale notar que os inputs `%b` e `%B` usam o nome dos meses definidos ou pelo sistema operacional ou pelo padrão de locale do `R`. O mesmo vale para `%A` e outras que imprimem algum texto.\n\nPara consultar o padrão do seu computador veja `Sys.getlocale()`. Para trocar o padrão usa-se `Sys.setlocale()`, mas recomendo evitar este tipo de comando a não ser que você saiba o que está fazendo. É importante reforçar que não basta somente definir um `date_labels` apropriado, é preciso também que o dado esteja no formato correto.\n\n| Input | Label                                          |\n|-------|------------------------------------------------|\n| %Y    | Ano completo (e.g. 2010) (0000-9999)           |\n| %y    | Ano abreviação (e.g. 10) (00-99)               |\n| %m    | Mês em número (e.g. 11) (01-12)                |\n| %b    | Mês abreviação (e.g. Jan) (Jan-Dec)            |\n| %B    | Mês completo (e.g. January) (January-December) |\n| %d    | Dia do mês (e.g. 02) (01-31)                   |\n| %a    | Dia da semana, abreviação (Mon-Sun)            |\n| %A    | Dia da semana, completo (Monday-Sunday)        |\n| %I    | Hora, no padrão 12 horas (01-12)               |\n| %H    | Hora, no padrão 24 horas (00-23)               |\n\n: Códigos de datas\n\n# Cores\n\nEm posts anteriores, vimos que o `ggplot` mapeia elementos estéticos em elementos visuais no gráfico. Neste sentido, pode-se fazer com que as cores do gráfico representem alguma variável dos dados. Há dois tipos de \"cores\": `color` e `fill`. Grosso modo, `color` é utilizado para desenhar o contorno de objetos ou alguns objetos pequenos, enquanto `fill` é utilizado para preencher objetos.\n\nNo histograma abaixo isto fica evidente: a cor fornecida para o argumento `color` é mapeada no contorno da barra, enquanto a cor fornecida para `fill` preenche a barra.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = car_rate)) +\n  geom_histogram(bins = 12, color = \"white\", fill = \"dodgerblue4\")\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-28-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nHá dois casos gerais para se pensar o uso de cores no `ggplot`. Caso você já tenha uma pré-seleção de cores, basta usar `scale_color_manual()` ou `scale_fill_manual()`. Caso você não tenha uma paleta de cores pré-definida será necessário depender de alguma das várias funções do `ggplot` como:\n\n-   `scale_color_brewer()`\n-   `scale_color_distiller()`\n-   `scale_color_grey()`\n-   `scale_color_viridis_*()`\n\nAlém das funções do pacote `ggplot2` há diversos pacotes que oferecem paletas de cores adicionais como:\n\n-   [Ghibli](https://github.com/ewenme/ghibli)\n-   [MetBrewer](https://github.com/BlakeRMills/MetBrewer)\n-   [WesAnderson](https://github.com/karthik/wesanderson)\n-   [Paletteer](https://github.com/EmilHvitfeldt/paletteer)\n\nNo restante deste post vou mostrar como alterar as cores de um gráfico, mas não vou discutir aspectos técnicos sobre a escolha de cores[^3].\n\n[^3]: Não conheço boas referências sobre teoria de cores em português. Atualmente, o ChatGPT pode fornecer boas paletas de cores: \"Quero uma paleta de cores profissional com tons de laranja. Esta paleta de cores será utilizada dentro do R. Quero o retorno em vetores de tamanhos de 3 a 8 elementos com cores em formato hexadecimal. Retorne os vetores numa lista.\".\n\n## Cores: o básico\n\n### Variáveis discretas\n\nNovamente, vamos começar com um exemplo simples. O código abaixo seleciona algumas Zonas OD e ranqueia elas segundo a variável `prop_educ_superior` que é o percentual de indivíduos (naquela Zona) com ensino superior.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nzonas <- c(\"Vila Mariana\", \"Paraíso\", \"Saúde\", \"Jabaquara\", \"Grajaú\")\n\nsubpod <- pod %>%\n  filter(name_zone %in% zonas) %>%\n  mutate(\n    name_zone = factor(name_zone),\n    name_zone = fct_reorder(name_zone, prop_educ_superior)\n    )\n```\n:::\n\n\nUsando o argumento `aes` sabemos que é possível mapear uma cor diferente para cada uma das regiões como no gráfico abaixo.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(subpod, aes(x = name_zone, y = prop_educ_superior)) +\n  geom_col(aes(fill = name_zone))\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-30-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nPara trocar as cores usamos a função `scale_fill_manual`. Note que uso a função `scale_fill_*` pois quero trocar as cores do `fill`. Vale notar que, neste caso, a função `scale_fill_discrete` atingiria o mesmo resultado.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncores <- c(\"#C0D1B6\", \"#A3C9A8\", \"#84B59F\", \"#69A297\", \"#50808E\")\n\nggplot(subpod, aes(x = name_zone, y = prop_educ_superior)) +\n  geom_col(aes(fill = name_zone)) +\n  scale_fill_manual(values = cores)\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-31-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nNote que os mesmos argumentos `name`, `labels`, etc. continuam valendo.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(subpod, aes(x = name_zone, y = prop_educ_superior)) +\n  geom_col(aes(fill = name_zone)) +\n  scale_fill_manual(\n    name = \"ZONAS\",\n    values = cores,\n    labels = toupper\n    )\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-32-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nPara controlar os detalhes da legenda de cores usa-se a função `guide` em conjunto com a função `guide_legend`. Os exemplos abaixo mostram algumas das customizações possíveis. Para mais detalhes vale conferir a página de ajuda da função `guide_legend`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbase_plot <- ggplot(subpod, aes(x = name_zone, y = prop_educ_superior)) +\n  geom_col(aes(fill = name_zone)) + \n  scale_fill_manual(name = \"Zona\", values = cores) +\n  labs(x = NULL, y = NULL) +\n  scale_x_discrete(labels = c(\"GRA\", \"JAB\", \"SAU\", \"PAR\", \"VMR\"))\n\n#> Remove a legenda\nbase_plot + guides(fill = \"none\")\n#> Posiciona o título da legenda em baixo\nbase_plot + guides(fill = guide_legend(title.position = \"bottom\"))\n#> Centraliza o texto da legenda\nbase_plot + guides(fill = guide_legend(\n  label.position = \"left\", label.hjust = 0.5, title.hjust = 0.5\n))\n#> Inverte a disposição da legenda\nbase_plot + guides(fill = guide_legend(reverse = TRUE))\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-34-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nComo mencionado acima, pode-se usar funções com cores pré-definidas. Abaixo mostro alguns exemplos.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbase_plot <- ggplot(subpod, aes(x = name_zone, y = prop_educ_superior)) +\n  geom_col(aes(fill = name_zone)) +\n  labs(x = NULL, y = NULL) +\n  scale_x_discrete(labels = c(\"GRA\", \"JAB\", \"SAU\", \"PAR\", \"VMR\"))\n\n#> Usando ColorBrewer\nbase_plot + scale_fill_brewer(type = \"qual\", palette = 4)\n#> Escala de cinza\nbase_plot + scale_fill_grey()\n#> Usando Ghibli, cores do filme Princesa Mononoke\nbase_plot + ghibli::scale_fill_ghibli_d(\"MononokeMedium\")\n#> Usando MetBrewer, cores do artista Hokusai\nbase_plot + MetBrewer::scale_fill_met_d(\"Hokusai1\")\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-36-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nPor fim, mostro um exemplo onde as cores podem tanto ajudar a enxergar tendências de longo prazo como também algum tipo de padrão sazonal nos dados. O gráfico de linha abaixo mostra o preço mediano de venda de imóveis na cidade de Austin a cada mês durante o período 2000-2014.\n\nRepare no uso da função `scale_x_continuous` para mostrar o nome abreviado de cada mês no eixo-x e o uso de `as.factor` para garantir que o R interprete a variável `year` como categórica e não como contínua.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\naustin <- filter(txhousing, city == \"Austin\", year < 2015)\n\nggplot(austin, aes(x = month, y = median)) +\n  geom_line(aes(color = as.factor(year))) +\n  scale_x_continuous(breaks = 1:12, labels = month.abb) +\n  scale_color_viridis_d()\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-37-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n### Variáveis contínuas\n\nA mesma lógica apresentada acima se aplica a variáveis contínuas. Infelizmente, algumas das aplicações mais úteis de escalas de cores contínuas envolvem tipos de gráficos que ainda não vimos, como `geom_tile()` e `geom_sf()`.\n\nO exemplo abaixo mostra a relação entre renda e escolaridade, olhando especificamente para a taxa de indivíduos com ensino superior. Note o uso da função `scale_y_log10`.\n\nA função `scale_color_continuous` não é particularmente útil pois, ao contrário do caso discreto, em que podíamos escolher as cores manualmente usando a função `scale_color_discrete` ou `scale_color_manual`, não existe uma maneira de \"escolher\" as cores no caso contínuo.\n\nO problema acontece porque teríamos que escolher \"infinitas\" cores, ou melhor, todo um gradiente de cores. Para definir um gradiente de cores com facilidade, usamos a função `scale_color_gradient`. Esta função define um gradiente a partir dos argumentos `low` e `high`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = prop_educ_superior, y = income_avg)) +\n  geom_point(aes(color = pop_density)) +\n  scale_y_log10() +\n  scale_color_gradient(low = \"blue\", high = \"orange\")\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-38-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nPara construir um gradiente \"divergente\", que destaca valores longe da média, por exemplo, pode-se usar `scale_color_gradient2`. O exemplo abaixo usa a função `scale` para \"normalizar\" a densidade populacional.\n\nO gráfico agora destaca em azul/roxo as Zonas com alta densidade populacional e em vermelho as Zonas com baixa densidade populacional; as Zonas com densidade próximas da média ficam em branco.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = prop_educ_superior, y = income_avg)) +\n  geom_point(aes(color = scale(pop_density))) +\n  scale_y_log10() +\n  scale_color_gradient2(limits = c(-4, 4))\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-39-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nUma função muito útil para trabalhar este tipo de dado é a `scale_*_distiller()`, que cria gradientes de cores a partir das paletas de cores do ColorBrewer, que vimos anteriormente. A cor de cada ponto no gráfico abaixo ilustra a densidade populacional de cada Zona em que os pontos mais escuros são as Zonas mais densas.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = prop_educ_superior, y = income_avg)) +\n  geom_point(aes(color = pop_density)) +\n  scale_y_log10() +\n  scale_color_distiller(palette = 3, direction = 1)\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-40-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nA principal vantagem de trabalhar com esta função é a facilidade em testar e gerar boas escalas de cores. Os exemplos abaixo mostram algumas das aplicações. Para conhecer mais vale consultar `?scale_color_distiller`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbase_plot <- ggplot(pod, aes(x = prop_educ_superior, y = income_avg)) +\n  geom_point(aes(color = pop_density)) +\n  scale_y_log10() +\n  guides(color = \"none\")\n\n#> Seleciona uma paleta de cores usando número e tipo\nbase_plot + scale_color_distiller(palette = 1, type = \"sequential\")\n#> Seleciona uma paleta de cores usando uma abreviação (BluesGreen)\nbase_plot + scale_color_distiller(palette = \"BuGn\")\n#> Seleciona uma paleta de cores usando uma abreviação (YellowOrangeRed)\nbase_plot + scale_color_distiller(palette = \"YlOrRd\")\n#> Seleciona uma paleta de cores e inverte a direção\nbase_plot + scale_color_distiller(palette = 1, direction = 1)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-42-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nNovamente, os argumentos das funções `scale_*` são compartilhados. No exemplo abaixo, mostro como usar `breaks` dentro de `scale_color_distiller`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = prop_educ_superior, y = income_avg)) +\n  geom_point(aes(color = pop_density)) +\n  scale_y_log10() +\n  scale_color_distiller(\n    name = \"Dens. Pop\",\n    breaks = seq(50, 400, 50),\n    palette = 3,\n    direction = 1\n    )\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-43-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nA função `scale_*_binned` permite uma visualização um pouco mais simplificada de dados contínuos ao agrupar eles em grupos. Esta função não permite customizar a escolha dos grupos, mas, em geral, ela funciona muito bem. Em casos mais complexos, vale mais a pena agrupar os dados antes de visualizá-los, e então tratá-los como dados discretos. Outra opção é usar uma função que permita maior controle como `scale_color_steps` ou `scale_color_gradient`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = prop_educ_superior, y = income_avg)) +\n  geom_point(aes(color = pop_density), alpha = 0.7) +\n  scale_y_log10() +\n  scale_color_binned(type = \"viridis\")\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-44-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nA função `scale_color_binned` tem apenas duas opções de cores: `\"gradient\"` e `\"viridis\"`. Contudo, ela também aceita escalas customizadas de outras funções. No exemplo abaixo mostro como utilizar uma escala do `MetBrewer`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = prop_educ_superior, y = income_avg)) +\n  geom_point(aes(color = pop_density), alpha = 0.7) +\n  scale_y_log10() +\n  scale_color_binned(type = \\(x) MetBrewer::scale_color_met_c(name = \"VanGogh3\"))\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-45-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nPor fim, para controlar os detalhes da legenda, novamente usa-se a função `guides` mas agora em conjunto com `guide_colorbar`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = prop_educ_superior, y = income_avg)) +\n  geom_point(aes(color = pop_density), alpha = 0.7) +\n  scale_y_log10() +\n  scale_color_binned(type = \"viridis\") +\n  guides(color = guide_colorbar(reverse = TRUE))\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-46-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nO `{ggplot2}` é um pacote muito flexível, oferece todo tipo de visualização imaginável. Como resultado, podemos (como já vimos em vários casos) gerar todo tipo de gráfico sem sentido. O exemplo abaixo mostra novamente a série da taxa de poupança, mas agora a cor da linha é proporcional à taxa de desemprego naquele mês.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(economics, aes(x = date, y = psavert)) +\n  geom_line(aes(color = unemploy/pop)) +\n  scale_color_viridis_c()\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-47-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nEm geral, usa-se cores em gráficos de linha para ajudar a distinguir entre diferentes séries de tempo. Pode-se usar cores diferentes numa única série para enfatizar a sua mudança no tempo. O gráfico abaixo mostra a série das \"anomalias de temperatura\" nas últimos décadas. Por anomalia de temperatura, entende-se, o desvio da temperatura média anual em relação à média histórica (1951-1980)[^4].\n\n[^4]: Esta base de dados é exportada em conjunto com o pacote `astsa`. Para mais informações consulte [o site da NASA](https://data.giss.nasa.gov/gistemp/), que é a fonte original dos dados e que, também, disponibiliza uma versão atualizada da série.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngtemp_both <- astsa::gtemp_both\n# Converte o objeto para data.frame\ndf <- data.frame(\n  date = as.numeric(time(gtemp_both)),\n  temp = as.numeric(gtemp_both)\n  )\n\nggplot(df, aes(x = date, y = temp, color = temp)) + \n  geom_line() +\n  scale_color_viridis_c(option = \"inferno\")\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-48-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n# Outros elementos estéticos\n\nPara efeitos de {ggplot2} o tamanho e a transparência dos objetos também são elementos estéticos. O exemplo abaixo mostra como controlar a legenda no caso em que o tamanho do elemento é variável. Nos gráficos abaixo, mostro o mesmo gráfico de renda e carros, mas agora o tamanho de cada ponto é proporcional à população total de cada Zona. Eu omito a legenda usando `guides(size = \"none\")`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbase_plot <- ggplot(pod, aes(x = income_avg, y = car_rate)) +\n  geom_point(aes(size = pop), alpha = 0.5) +\n  guides(size = \"none\")\n\np1 <- base_plot + scale_size_continuous(range = c(0, 5))\np2 <- base_plot + scale_size_continuous(range = c(0, 8))\np3 <- base_plot + scale_size_continuous(range = c(0, 10))\np4 <- base_plot + scale_size_continuous(range = c(0, 20))\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-50-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nOutro elemento estético comumente utilizado é `alpha`, que controla a transparência da visualização. Honestamente, apesar dele ser muito útil para evitar a sobreposição de elementos no gráfico, é difícil imaginar algum uso prático de `scale_alpha`. O gráfico abaixo mostra o estoque de imóveis e o preço mediano de venda por mês.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntxhousing |> \n  filter(city == \"Austin\") |> \n  ggplot(aes(x = inventory, y = median)) +\n  geom_point(aes(alpha = year)) +\n  scale_alpha()\n```\n\n::: {.cell-output-display}\n![](6-scales-labels_files/figure-html/unnamed-chunk-51-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n# Resumo\n\nEste foi o post mais longo e mais técnico da série de tutoriais até o momento. Por algum tempo pensei em separar ele em duas partes, mas acredito que há vantagens em apresentar cores e escalas conjuntamente, já que as funções compartilham sintaxes semelhantes. A discussão inevitavelmente torna-se mais técnica pois agora é preciso pensar no formato das variáveis (`Date`, `factor`, etc.). Isto, contudo, é um ponto positivo pois força o usuário a pensar melhor nas suas variáveis e recompensa o uso de bases de dados limpas e organizadas.\n\nEscalas, legendas e cores são elementos essenciais numa boa visualização. Às vezes elas podem exigir um trabalho considerável, mas este esforço muitas vezes diferencia uma visualização simplória de uma visualização refinada.\n",
    "supporting": [
      "6-scales-labels_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}