{
  "hash": "0cdaa8b2346d77057b56442d8f988c05",
  "result": {
    "markdown": "---\ntitle: 'Estético: Legendas, escalas e temas'\ndate: '2022-12-26'\ncategories: ['data-visualization', 'ggplot2', 'tutorial-R']\ndescription: \"Gráficos de linha são frequentemente usados para representar séries de tempo, isto é, valores que mudam ao longo do tempo. Estes gráficos revelam a evolução de uma variável ao longo do tempo.\"\ntitle-block-banner: true\nexecute: \n  message: false\n  warning: false\nformat:\n  html:\n    code-fold: false\n    code-tools: true\ndraft: true\nfreeze: true\n---\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(scales)\nlibrary(dplyr)\nlibrary(forcats)\nlibrary(stringr)\n\npod <- readr::read_csv(\n  here::here(\"posts/ggplot2-tutorial/table_pod.csv\"),\n  show_col_types = FALSE\n  )\n\npod <- filter(pod, code_muni == 36, pop > 0)\n```\n:::\n\n\n# Legendas, escalas e temas\n\n# Escalas\n\nEscalas, no contexto do `ggplot`, significam tanto a manipulação dos eixos do gráfico como das cores dos elementos. Há uma infinidade de funções `scale_*` e não vale a pena entrar nos detalhes de cada uma delas. Neste post vou discutir a lógica geral destas funções e apresentar aquelas que acredito que possam ser as mais úteis\n\nO uso de escalas de cores e legendas está intimamente ligado ao tipo de variável que se está visualizando. Para entender melhor o funcionamento das escalas é preciso compreender o tipo de variável que se vai plotar e como o `R` interpreta esta variável. A próxima seção \n\n## Tipos de variáveis\n\nO `ggplot`, grosso modo, divide as variáveis em contínuas e discretas. As variáveis contínuas, em geral, são numéricas e podem assumir qualquer valor; já as variáveis discretas costumam ser \"categóricas\" e são \"contáveis\". O preço de um imóvel, por exemplo, é uma variável contínua. Já uma variável que categoriza um imóvel entre \"casa\" e \"apartamento\" é uma variável discreta.\n\nEsta lógica é aplicada nas funções que controlam os eixos x e y de um gráfico.\n\n-   `scale_y_continuous()`\n-   `scale_y_discrete()`\n-   `scale_x_continuous()`\n-   `scale_x_discrete()`\n\nUma lógica muito similar se aplicas às principais funções que controlam as cores e a legenda de cores de um gráfico: \n\n-   `scale_color_continuous()`\n-   `scale_color_discrete()`\n-   `scale_fill_continuous()`\n-   `scale_fill_discrete()`\n\nMesmo quando modificamos outros aspectos estéticos do gráfico como `size` e `alpha` temos:\n\n- `scale_alpha_continuous()`\n- `scale_alpha_discrete()`\n- `scale_size_continuous()`\n- `scale_size_discrete()`\n\n### Variáveis contínuas\n\nUma variável contínua costuma representar algum número. No R há várias formas de armazenar números, mas isto não costuma ser muito relevante para a tarefa de visualização dos dados. Na maior parte dos casos, basta garantir que a coluna numérica em questão seja um número usando `is.numeric()` ou `as.numeric()`.\n\n### Variáveis discretas\n\nUma variável discreta costuma representar uma categoria. No R existe uma classe especial de variável para armazenar este tipo de dado chamada `factor`. Um `factor` é um vetor de texto ou de números que segue uma ordem. Além de ter uma ordem, cada elemento pode ter um `label`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfactor(x = c(...), levels = c(...), labels = c(...))\n```\n:::\n\n\nPara se definir um factor basta usar a função homônima. Note que na ausência de uma ordem explicitamente definida, o `R` organiza o vetor em ordem alfabética. Se, ao invés de um vetor de texto tivéssemos usado um vetor de números, eles teriam sido ordenados no sentido ascedente (do menor para o maior).\n\nPara acessar a ordem do `factor` pode-se usar a função `order()` ou, mais especificamente, a função `levels()`. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Criando um factor \nmedalhas <- factor(c(\"ouro\", \"prata\", \"bronze\"))\n#> [1] ouro   prata  bronze\n#> Levels: bronze ouro prata\n\n#> Conferindo a ordem dos elementos\norder(medalhas)\n#> [1] 3 1 2\nlevels(medalhas)\n#> [1] \"bronze\" \"ouro\"   \"prata\" \n```\n:::\n\n\nO código abaixo recria o `factor`, deixando mais explícito a estrutura deste tipo de objeto. Note que o argumento `levels` e `labels` não precisam ser repetidos.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Criando um factor \nmedalhas <- factor(\n  c(\"ouro\", \"prata\", \"bronze\", \"bronze\", \"ouro\", \"bronze\"),\n  levels = c(\"bronze\", \"prata\", \"ouro\"),\n  labels = c(\"Bronze\", \"Prata\", \"Ouro\")\n  )\n\nmedalhas\n#> [1] Ouro   Prata  Bronze Bronze Ouro   Bronze\n#> Levels: Bronze Prata Ouro\n```\n:::\n\n\nTrabalhar com factors pode ser uma tarefa bastante frustrante. Neste sentido, recomendo muito o uso do pacote `forcats`, que provê uma série de funções `fct_*` que facilitam muito a manipulação deste tipo de objeto. Os exemplos abaixo mostram algumas das funções mais úteis deste pacote.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf <- data.frame(\n  x = c(5, 2, 3),\n  y = factor(c(\"bronze\", \"prata\", \"ouro\"))\n)\n\n#> Troca a ordem do factor segundo algum outro vetor\nfct_reorder(df$y, df$x)\n#> [1] bronze prata  ouro  \n#> Levels: prata ouro bronze\n\n#> Troca os labels do factor usando uma função\nfct_relabel(df$y, toupper)\n#> [1] BRONZE PRATA  OURO  \n#> Levels: BRONZE OURO PRATA\n\n#> Troca os labels do factor manualmente\nfct_recode(df$y, \"Bronze\" = \"bronze\")\n#> [1] Bronze prata  ouro  \n#> Levels: Bronze ouro prata\n\n#> Conta a ocorrência de cada factor\nfct_count(df$y)\n#> A tibble: 3 × 2\n#>   f          n\n#>   <fct>  <int>\n#> 1 bronze     1\n#> 2 ouro       1\n#> 3 prata      1\n```\n:::\n\n\nPor fim, vale comentar brevemente sobre uma particularidade de um `factor` criado a partir de uma variável numérica. Para converter um factor de texto em character basta usar `as.character(x)`. Para converter de volta um factor de números é preciso usar `as.numeric(as.character(x))`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(1, 10, 2, 5, 1)\ny <- as.factor(x)\n\n#> Por padrão, as.numeric retorna a ordem do factor. Equivalente a order()\nas.numeric(y)\n#> [1] 1 4 2 3 1\n\n#> Para converter de volta no número original\nas.numeric(as.character(y))\n#> [1]  1 10  2  5  1\n```\n:::\n\n\n## Escalas: o básico\n\nVamos começar com um gráfico simples que mostra a renda domiciliar média da Zona OD no eixo-x e o número médio de carros por domicílio no eixo-y.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = income_avg, y = car_rate)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](6-scales-labels-themes_files/figure-html/unnamed-chunk-7-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nNo caso do gráfico acima, ambas as variáveis são contínuas, portanto, para alterar algum dos eixos usa-se as funções `scale_x_continuous()` e `scale_y_continuous()`. Estas funções tem 4 argumentos principais: `breaks`, `labels`, `limits` e `expand`.\n\nPara controlar as 'quebras' do eixo-x (os pontos onde aparece cada número) usa-se o argumento `breaks`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = income_avg, y = car_rate)) +\n  geom_point() +\n  scale_x_continuous(breaks = seq(0, 20000, 2500))\n```\n\n::: {.cell-output-display}\n![](6-scales-labels-themes_files/figure-html/unnamed-chunk-8-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nPor padrão, o número exibido no gráfico é igual ao argumento fornecido em `breaks`, mas pode-se alterar isto usando `labels`. Para ser mais preciso: `breaks` define a posição onde o `labels` vai ser exibido.\n\nNo exemplo abaixo uso o fato do salário mínimo, à época da pesquisa, ser de R$954. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = income_avg, y = car_rate)) +\n  geom_point() +\n  scale_x_continuous(\n    breaks = 954 * c(2, 4, 6, 10, 15),\n    labels = stringr::str_glue(\"{c(2, 4, 6, 10, 15)} S.M.\")\n    )\n```\n\n::: {.cell-output-display}\n![](6-scales-labels-themes_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nO argumento `labels` pode ser qualquer texto, desde que ele tenha o mesmo número de elementos que o argumento `breaks`. O pacote `scales` oferece algumas funções `label_*` pré-definidas que auxiliam a formatar as escalas. O exemplo abaixo mostra como usar a função `label_dollar` para formatar o eixo-x.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = income_avg, y = car_rate)) +\n  geom_point() +\n  scale_x_continuous(\n    breaks = seq(0, 20000, 2500),\n    labels = label_dollar(big.mark = \".\")\n    )\n```\n\n::: {.cell-output-display}\n![](6-scales-labels-themes_files/figure-html/unnamed-chunk-10-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nNa minha experiência, as funções mais úteis do pacote são: \n\n- `label_number()`: usado para formar números de maneira geral\n- `label_percent()`: usado para formatar números expressados percentualmente\n- `label_dollar()`: usado para formatar números que representam dinheiro\n\nPara seguir o padrão brasileiro, utiliza-se `big.mark = \".\"` e `decimal.mark = \",\"`.\n\nPara dar um \"zoom-in\" no gráfico pode-se alterar o argumento `limits`. Este argumento recebe um par de números para definir o número máximo e mínimo que deve ser plotado. Para deixar o eixo \"livre\" basta definir o valor como `NA`. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = income_avg, y = car_rate)) +\n  geom_point() +\n  scale_x_continuous(limits = c(3000, 5000)) +\n  scale_y_continuous(limits = c(NA, 1))\n```\n\n::: {.cell-output-display}\n![](6-scales-labels-themes_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nPor fim, o argumento `expand` diminui ou aumenta a distância entre o gráfico e o limite dos eixos. A aplicação mais comum disso é para reduzir o espaço em branco que \"sobra\" em alguns gráficos.\n\nO par de histogramas abaixo mostra a distribuição da renda domiciliar média entre as zonas OD.\n\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = car_rate)) +\n  geom_histogram(bins = 12, color = \"white\")\n\nggplot(pod, aes(x = car_rate)) +\n  geom_histogram(bins = 12, color = \"white\") +\n  scale_x_continuous(expand = c(0, 0))\n```\n\n::: {.cell-output-display}\n![](6-scales-labels-themes_files/figure-html/unnamed-chunk-12-1.png){fig-align='center' width=50%}\n:::\n\n::: {.cell-output-display}\n![](6-scales-labels-themes_files/figure-html/unnamed-chunk-12-2.png){fig-align='center' width=50%}\n:::\n:::\n\n\nEscalas discretas funcionam praticamente da mesma forma. Uma distinção importante é que, no caso de uma variável discreta ou categórica, o eixo - por padrão - vai plotar o `label` da variável.\n\nO código abaixo encontra os 5 distritos mais populosos de São Paulo.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndstr_pop <- pod |> \n  summarise(total_pop = sum(pop), .by = \"name_district\") |> \n  slice_max(total_pop, n = 5) |> \n  mutate(\n    name_district = factor(\n      name_district,\n      labels = c(\"Capão Redondo\", \"Grajaú\", \"Jd. Ângela\", \"Jd. São Luis\",\n                 \"Sapopemba\")\n      )\n    )\n\nggplot(dstr_pop, aes(x = name_district, y = total_pop)) +\n  geom_col()\n```\n\n::: {.cell-output-display}\n![](6-scales-labels-themes_files/figure-html/unnamed-chunk-13-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nCaso não se queira alterar o tipo da variável é possível definir os `labels` diretamente na função `scale_x_discrete()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(dstr_pop, aes(x = name_district, y = total_pop)) +\n  geom_col() +\n  scale_x_discrete(\n    labels = c(\"Capão Redondo\", \"Grajaú\", \"Jd. Ângela\", \"Jd. São Luis\",\n               \"Sapopemba\")\n    )\n```\n\n::: {.cell-output-display}\n![](6-scales-labels-themes_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nO exemplo abaixo é um pouco mais sofisticado\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntop_car <- pod %>%\n  slice_max(car_rate, n = 10) |> \n  mutate(\n    name_zone = factor(name_zone),\n    name_zone = forcats::fct_reorder(name_zone, car_rate)\n    )\n\nggplot(top_car, aes(x = name_zone, y = car_rate)) +\n  geom_col() +\n  coord_flip() +\n  scale_x_discrete(labels = \\(x) stringr::str_wrap(x, width = 12)) +\n  theme(axis.text.y = element_text(hjust = 0.5))\n```\n\n::: {.cell-output-display}\n![](6-scales-labels-themes_files/figure-html/unnamed-chunk-15-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n## Um pouco mais\n\n\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n\n```{.r .cell-code}\n# ggplot(aluguel, aes(x = area, y = rent)) + \n#   geom_point() +\n#   scale_y_log10()\n# \n# ggplot(aluguel, aes(x = area, y = rent)) + \n#   geom_point() +\n#   scale_y_continuous(trans = \"log\")\n```\n:::\n\n\n\n\n\n### Um pouco mais de escalas\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntop_sales <- txhousing %>%\n  filter(year == 2010) %>%\n  summarise(total = sum(sales), .by = \"city\") %>%\n  slice_max(total, n = 15) %>%\n  mutate(city = factor(city), city = forcats::fct_reorder(city, total))\n\nggplot(top_sales, aes(x = city, total)) +\n  geom_col() + \n  coord_flip() +\n  scale_x_discrete(labels = function(x) stringr::str_wrap(x, width = 10)) +\n  theme(axis.text.y = element_text(hjust = 0.5))\n```\n\n::: {.cell-output-display}\n![](6-scales-labels-themes_files/figure-html/unnamed-chunk-17-1.png){fig-align='center' width=80%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = income_avg, y = car_rate)) +\n  geom_count() +\n  scale_x_binned() +\n  scale_y_binned()\n```\n\n::: {.cell-output-display}\n![](6-scales-labels-themes_files/figure-html/unnamed-chunk-18-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n### Datas\n\nDatas têm uma classe especial e, por conseguinte, tem também algumas funções dedicadas. A função `scale_x_date` tem dois argumentos principais:\n\n- `date_breaks`: que aceita valores como \"1 year\", \"3 months\", etc.\n- `date_labels`: que aceita valores como \"%Y%m%d\", \"%Y%b\", etc.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(economics, aes(x = date, y = psavert)) +\n  geom_line() +\n  scale_x_date(date_breaks = \"5 year\", date_labels = \"%Y\")\n```\n\n::: {.cell-output-display}\n![](6-scales-labels-themes_files/figure-html/unnamed-chunk-19-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nO exemplo abaixo mostra como exibir o número do ano junto com a nome abreviado do mês. Note como o uso de `\\n` quebra a linha no eixo-x.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprices_austin <- txhousing %>%\n  filter(city == \"Austin\", year %in% 2007:2011) %>%\n  mutate(date = lubridate::make_date(year, month))\n\nggplot(prices_austin, aes(x = date, y = sales)) +\n  geom_line() +\n  scale_x_date(date_breaks = \"3 month\", date_labels = \"%Y\\n%b\")\n```\n\n::: {.cell-output-display}\n![](6-scales-labels-themes_files/figure-html/unnamed-chunk-20-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nPara escolher datas específicas, usa-se o argumento convencional `breaks`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(prices_austin, aes(x = date, y = sales)) +\n  geom_line() +\n  scale_x_date(\n    breaks = c(as.Date(\"2007-01-01\"), as.Date(\"2008-07-30\")),\n    date_labels = \"%Y\\n%b\")\n```\n\n::: {.cell-output-display}\n![](6-scales-labels-themes_files/figure-html/unnamed-chunk-21-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nPor fim, o exemplo abaixo pula alguns passos, já que ainda não se apresentou formalmente a função `theme`. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprices_austin10 <- txhousing %>%\n  filter(city == \"Austin\", year %in% 2010:2011) %>%\n  mutate(date = lubridate::make_date(year, month))\n\nggplot(prices_austin10, aes(x = date, y = sales)) +\n  geom_line() +\n  scale_x_date(\n    breaks = seq(as.Date(\"2010-01-01\"), as.Date(\"2011-12-01\"), by = \"month\"),\n    date_labels = \"%Y-%m\"\n    ) +\n  theme(\n    panel.grid.minor = element_blank(),\n    axis.text.x = element_text(angle = 90)\n  )\n```\n\n::: {.cell-output-display}\n![](6-scales-labels-themes_files/figure-html/unnamed-chunk-22-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n## Cores\n\n\n\n\n::: {.cell layout-ncol=\"3\" layout-align=\"center\"}\n\n```{.r .cell-code}\n# aluguel <- mutate(aluguel, room = factor(room))\n# \n# base_plot <- ggplot(aluguel, aes(x = room, y = rent, fill = room)) +\n#   geom_bar(stat = \"summary_bin\", fun = mean) +\n#   theme(legend.position = \"none\")\n# \n# base_plot + scale_fill_brewer(type = \"qual\", palette = 2)\n# base_plot + scale_fill_brewer(type = \"qual\", palette = 6)\n# base_plot + scale_fill_brewer(type = \"qual\", palette = 7)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsub <- txhousing %>%\n  filter(\n    city %in% c(\"Austin\", \"Dallas\", \"Houston\", \"San Antonio\"),\n    year == 2010\n    )\n\nggplot(sub, aes(x = month, y = sales)) +\n  geom_col(aes(fill = city), position = position_fill()) +\n  scale_y_continuous(labels = label_percent()) +\n  scale_fill_viridis_d()\n```\n\n::: {.cell-output-display}\n![](6-scales-labels-themes_files/figure-html/unnamed-chunk-24-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n## Outros elementos estéticos\n\n\n::: {.cell layout-ncol=\"3\" layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(pod, aes(x = income_avg, y = car_rate)) +\n  geom_point(aes(size = pop), alpha = 0.5) +\n  scale_size_continuous(range = c(0, 5)) +\n  guides(size = \"none\")\n\nggplot(pod, aes(x = income_avg, y = car_rate)) +\n  geom_point(aes(size = pop), alpha = 0.5) +\n  scale_size_continuous(range = c(0, 10)) +\n  guides(size = \"none\")\n\nggplot(pod, aes(x = income_avg, y = car_rate)) +\n  geom_point(aes(size = pop), alpha = 0.5) +\n  scale_size_continuous(range = c(0, 20)) +\n  guides(size = \"none\")\n```\n\n::: {.cell-output-display}\n![](6-scales-labels-themes_files/figure-html/unnamed-chunk-25-1.png){fig-align='center' width=80%}\n:::\n\n::: {.cell-output-display}\n![](6-scales-labels-themes_files/figure-html/unnamed-chunk-25-2.png){fig-align='center' width=80%}\n:::\n\n::: {.cell-output-display}\n![](6-scales-labels-themes_files/figure-html/unnamed-chunk-25-3.png){fig-align='center' width=80%}\n:::\n:::\n\n\nOutro elemento estético comumente utilizado é `alpha`. Honestamente, apesar deste elemento ser muito útil para evitar a sobreposição de elementos no gráfico, é difícil imaginar algum uso prático de `scale_alpha`. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntxhousing |> \n  filter(city == \"Austin\") |> \n  ggplot(aes(x = inventory, y = median)) +\n  geom_point(aes(alpha = year)) +\n  scale_alpha(range = c(0.4, 0.6))\n```\n\n::: {.cell-output-display}\n![](6-scales-labels-themes_files/figure-html/unnamed-chunk-26-1.png){fig-align='center' width=80%}\n:::\n:::\n",
    "supporting": [
      "6-scales-labels-themes_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}