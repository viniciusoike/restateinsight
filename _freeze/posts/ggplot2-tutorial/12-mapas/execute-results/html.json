{
  "hash": "27fc0909d5c51077bf63d702fb8bd15a",
  "result": {
    "markdown": "---\ntitle: 'You need a map'\ndate: '2023-01-05'\ncategories: ['data visualization', 'ggplot2', 'turorial-R']\ndescription: \"Facets são pequenos gráficos que, lado a lado, ajudam a comparar várias informações ao mesmo tempo. Este post intermediário ensina a fazer gráficos de facets no R usando o ggplot2.\"\ndraft: true\n---\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(sf)\nlibrary(dplyr)\nsf::sf_use_s2(FALSE)\n\nrent <- readr::read_csv(here::here(\"posts/ggplot2-tutorial/rents_liberdade.csv\"))\ncem <- readr::read_csv(here::here(\"static/data/cem_imoveis.zip\"))\npod <- readr::read_csv(here::here(\"posts/ggplot2-tutorial/table_pod.csv\"))\ncem2010 <- filter(cem, ano_lanc == 2010)\n```\n:::\n\n\n# Mapas\n\nEu começo este post com uma confissão: eu sofri muito até conseguir fazer mapas minimamente apresentáveis com o R. Há duas dificuldades bem sérias: primeiro, objetos geométricos são uma classe de objetos bastante complexa; segundo, há inúmeras convenções na elaboração de mapas que escapam completamente aos objetivos do economista.\n\nEste post vai tentar ensinar a fazer mapas, apresentando absolutamente o mínimo necessário sobre convenções cartográficas, tipos de projeção, e geografia de maneira geral.\n\nNo primeiro caso, o desafio é conseguir aprender o mínimo necessário para lidar com objetos espaciais. Neste sentido, não vou fingir que entendo o que significa CRS, EPSG, GDAL, etc. Apenas saiba que a Terra, infelizmente, não é plana, então é preciso sempre escolher algum tipo de projeção que mapeie nosso planeta tri-dimensional num plano bi-dimensional. Na prática, lembre-se dos números 4326, 4674 e 32722.\n\nFelizmente, existe o pacote {sf} que funciona como um `data.frame` com uma coluna especial chamada `geometry`. É possível ignorar a existência desta coluna e trabalhar normalmente com seus dados, usando todo o seu conhecimento acumulado previamente com dados tabulares convencionais. Eventualmente, será necessário juntar um shapefile com uma base de dados e até com outro shapefile; o {sf} também facilita isto bastante.\n\nNo segundo caso, das convenções, novamente, não vou fingir que eu entendo algo sobre cartografia, que me interesse fazer mapas com uma escala, com uma seta indicando o norte, com linhas paralelas indicando meridianos, etc. Saiba que tudo isto é muito possível de ser feito dentro do R e que eu não faço isso.\n\n# Quero apenas fazer um mapa interativo\n\nSe o seu objetivo é fazer um mapa interativo não use `ggplot`. Comece explorando o `leaflet`. Se o objetivo for menos visualização e mais \"ciência de dados\" e você não quer perder horas customizando cores no {leaflet} use o {tmap} ou {mapview}.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(leaflet)\n\nleaflet() %>%\n  addTiles() %>%\n  setView(lng = -46.6554, lat = -23.5651, zoom = 13)\n```\n\n::: {.cell-output-display}\n```{=html}\n<div class=\"leaflet html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-4bf9533a2ce073d8f66e\" style=\"width:80%;height:400.464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-4bf9533a2ce073d8f66e\">{\"x\":{\"options\":{\"crs\":{\"crsClass\":\"L.CRS.EPSG3857\",\"code\":null,\"proj4def\":null,\"projectedBounds\":null,\"options\":{}}},\"calls\":[{\"method\":\"addTiles\",\"args\":[\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",null,null,{\"minZoom\":0,\"maxZoom\":18,\"tileSize\":256,\"subdomains\":\"abc\",\"errorTileUrl\":\"\",\"tms\":false,\"noWrap\":false,\"zoomOffset\":0,\"zoomReverse\":false,\"opacity\":1,\"zIndex\":1,\"detectRetina\":false,\"attribution\":\"&copy; <a href=\\\"https://openstreetmap.org\\\">OpenStreetMap<\\/a> contributors, <a href=\\\"https://creativecommons.org/licenses/by-sa/2.0/\\\">CC-BY-SA<\\/a>\"}]}],\"setView\":[[-23.5651,-46.6554],13,[]]},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\n# Mapas com ggplot2\n\n## Mapas sem objetos espaciais\n\nA abordagem mais simples para tratar dados espaciais é simplesmente tratá-los como dados tabulados quaisquer. Isto funciona perfeitamente bem para objetos geométricos na forma de pontos e linhas, mas torna-se impraticável no caso de polígonos.\n\nNo plano cartesiano, longitude e latitude são literalmente coordenadas; pode-se mapear estas coordenadas como pontos num gráfico de dispersão. Para tornar os exemplos mais aplicados vamos usar a base de Empreendimentos Residenciais Verticais do Centro de Estudos da Metrópole da FAU/USP. Os dados compreendem todos os lançamentos residenciais na Região Metropolitana de São Paulo entre 1985 e 2013. Para simplificar nossa análise vamos nos restringir somente aos empreendimentos lançados na capital.\n\nNo gráfico abaixo cada ponto é um empreendimento residencial lançado em São Paulo entre 1985 e 2013.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncem <- cem |> \n  mutate(code_muni = as.numeric(substr(ap2010, 1, 7))) |> \n  filter(code_muni == 3550308)\n\nggplot(cem, aes(x = lon, y = lat)) +\n  geom_point(size = 0.1) +\n  coord_sf()\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-4-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nA principal vantagem de tratar os pontos, simplesmente como pontos, é que podemos aplicar todo o nosso conhecimento acumulado até agora. Os pontos no gráfico seguem a mesma lógica dos [gráficos de dispersão, visto anteriormente](https://restateinsight.com/posts/ggplot2-tutorial/1-grafico-dispersao) e a manipulação dos dados segue as mesmas [convenções de dados tabulares](https://restateinsight.com/posts/ggplot2-tutorial/apendix-manipular-enxergar).\n\nNo exemplo abaixo, o tamanho de cada círculo é proporcional ao número de unidades do empreendimento e a cor sinaliza se o empreendimento é veritical ou horizontal.\n\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Seleciona somente empreendimentos lançados em 2008\ncem08 <- cem |> \n  filter(ano_lanc == 2008)\n#> Seleciona empreendimentos lançados entre 2008 e 2011\nsub <- cem |> \n  filter(ano_lanc %in% 2008:2011)\n\nggplot(cem08, aes(x = lon, y = lat)) +\n  geom_point(aes(size = emp_unid, color = as.factor(emp_tipo)), alpha = 0.5)\n\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_point(size = 0.4) +\n  facet_wrap(vars(ano_lanc))\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-5-1.png){fig-align='center' width=100%}\n:::\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-5-2.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### Agregando pontos\n\nPode-se agregar os pontos em mapas de calor (contorno). Há duas funções principais:\n\n-   `geom_density_2d` - que desenha linhas de contorno\n-   `geom_density_2d_filled` - que desenha uma mapa de contorno\n\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_density_2d() +\n  theme(legend.position = \"none\")\n\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_density_2d_filled() +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-6-1.png){fig-align='center' width=100%}\n:::\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-6-2.png){fig-align='center' width=100%}\n:::\n:::\n\n\nTalvez o argumento mais útil destas funções seja o `bins` ou `binwidth`, similar ao argumento de `geom_histogram`. Os mapas abaixo mostram como este argumento controla o número de quebras nas linhas de contorno. A função que calcula os contornos é a `MASS::kde2d()` e, em geral, ela escolhe bons valores para o número de bins.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_density_2d_filled(bins = 5)\n\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_density_2d_filled(bins = 8)\n\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_density_2d_filled(bins = 10)\n\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_density_2d_filled(bins = 15)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/density-bins-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nMais a título de curiosidade, também é possível usar adaptar a função `stat_density_2d()` para gerar um mapa similar ao do `geom_count`.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-7-1.png){fig-align='center' width=100%}\n:::\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-7-2.png){fig-align='center' width=100%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsub <- sub |> \n  mutate(\n    group = findInterval(emp_andares, c(1, 5, 10, 20, 35)),\n    group = factor(\n      group,\n      labels = c(\"1\", \"1 a 5\", \"5 a 10\", \"10 a 20\", \"20 a 35\")\n      )\n  )\n\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_density_2d(aes(color = group)) +\n  scale_color_brewer(name = \"Número de andares\", palette = 6, type = \"qual\")\n\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_density_2d_filled() +\n  theme(legend.position = \"none\") +\n  facet_wrap(vars(group))\n```\n:::\n\n\nComo de costume, é possível\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsub <- sub |> \n  mutate(\n    group = findInterval(emp_andares, c(1, 5, 10, 20, 35)),\n    group = factor(\n      group,\n      labels = c(\"1\", \"1 a 5\", \"5 a 10\", \"10 a 20\", \"20 a 35\")\n      )\n  )\n\nggplot(filter(sub, group == \"10 a 20\"), aes(x = lon, y = lat)) +\n  geom_point(aes(size = emp_unid), alpha = 0.1) +\n  geom_density_2d_filled(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=80%}\n:::\n:::\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_bin2d() +\n  scale_fill_viridis_c(option = \"inferno\")\n\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_bin2d(aes(weight = pc_emp_atu / 1e9)) +\n  scale_fill_viridis_c(option = \"inferno\")\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-10-1.png){fig-align='center' width=100%}\n:::\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-10-2.png){fig-align='center' width=100%}\n:::\n:::\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_hex(bins = 15) +\n  scale_fill_viridis_c()\n\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_hex(bins = 15, aes(weight = pc_emp_atu / 1e9)) +\n  scale_fill_viridis_c()\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=100%}\n:::\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-11-2.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Objetos espaciais\n\nApós um longo e raivoso interlúdio chegamos, finalmente, aos mapas estáticos que utilizam, de fato, objetos espaciais. Vou discutir apenas objetos espaciais no formato de vetores (*vector shape file*) já que eles são mais prevalentes nas ciências socias em geral.\n\nHá três peças fundamentais que vamos ver: pontos, linhas e polígonos. Nos três casos, usa-se a mesma função `geom_sf()` para montar a visualização. Os elementos estéticos seguem a mesma lógica das funções `geom_point()`, `geom_line()` e `geom_rect()`, respectivamente. Assim, para tornar um objeto espacial, em formato de linha, mais grosso, usa-se `linewidth = 2`, por exemplo.\n\nVou começar assumindo um conhecimento mínimo de `R` apesar deste ser um capítulo já avançado na série de tutoriais de ggplot2.\n\nA estrutura de objetos espaciais é um `sf`/`data.frame` ou um \"spatial data frame\". Este objeto é essencialmente igual a um `data.frame` convencional, mas ele possui uma coluna especial chamada `geom` ou `geometry`. Para criar um objeto `sf` a partir de um `data.frame` ou `tibble` usa-se a função `st_as_sf`.\n\nO tipo mais simples de objeto geométrico é o ponto, definido por uma coordenada horizontal e uma coordenada vertical. O exemplo abaixo mostra como criar um spatial data.frame de pontos a partir dos dados de latitude e longitude do CEM. Note que é preciso escolher um sistema de projeção e eu escolho o [SIRGAS 2000 EPSG: 4674](https://epsg.io/4674), um sistema de projeção de referência para a América Latina. Para verificar o tipo de geometria dos objetos uso `st_geometry`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(dplyr)\n\npoints_cem <- st_as_sf(cem08, coords = c(\"lon\", \"lat\"), crs = 4674)\n\nst_geometry(points_cem)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGeometry set for 394 features \nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -46.79478 ymin: -23.70684 xmax: -46.43215 ymax: -23.45133\nGeodetic CRS:  SIRGAS 2000\nFirst 5 geometries:\n```\n:::\n:::\n\n\nPara gerar um gráfico a partir dos nossos dados, usa-se a função `geom_sf`, sem argumento algum. Note que este gráfico é idêntico ao que geramos antes usando `geom_point`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(points_cem) +\n  geom_sf()\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-13-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nComo comentei, há três tipos principais de objetos geométricos: *pontos*, *linhas* e *polígonos*. É possível gerar linhas e polígonos arbitrários a partir de coordenadas usando as funções do pacote `sf`. Na prática, é pouco usual criar objetos geométricos desta maneira e a sintaxe para desenhar mesmo formas geométricas simples como triângulos e quadrados é bastante trabalhosa, como o código abaixo deixa evidente.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Define as coordenadas do quadrado\nquadrado = list(\n  rbind(\n    c(0, 0),\n    c(0, 1),\n    c(1, 1),\n    c(1, 0),\n    #> Note que é preciso repetir (0, 0)\n    c(0, 0)\n  )\n)\n#> Converte as coordenads em um POLYGON\nquadrado <- st_polygon(quadrado)\n#> Converte em SFC\nquadrado <- st_sfc(quadrado)\n#> Plota o quadrado\nggplot(quadrado) +\n  geom_sf()\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nEsta coluna não pode ser dropada pelas maneiras usuais.\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\nVamos começar importando um shapefile dos estados do Brasil, usando o excelente {geobr}.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nufs <- geobr::read_state(showProgress = FALSE)\n\nufs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 27 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -66.81025 ymin: -13.6937 xmax: -59.77435 ymax: -7.969294\nGeodetic CRS:  SIRGAS 2000\nFirst 10 features:\n   code_state abbrev_state name_state code_region name_region\n1          11           RO   Rondônia           1       Norte\n2          12           AC       Acre           1       Norte\n3          13           AM   Amazonas           1       Norte\n4          14           RR    Roraima           1       Norte\n5          15           PA       Pará           1       Norte\n6          16           AP      Amapá           1       Norte\n7          17           TO  Tocantins           1       Norte\n8          21           MA   Maranhão           2    Nordeste\n9          22           PI      Piauí           2    Nordeste\n10         23           CE      Ceará           2    Nordeste\n                             geom\n1  MULTIPOLYGON (((-63.32721 -...\n2  MULTIPOLYGON (((-73.18253 -...\n3  MULTIPOLYGON (((-67.32609 2...\n4  MULTIPOLYGON (((-60.20051 5...\n5  MULTIPOLYGON (((-54.95431 2...\n6  MULTIPOLYGON (((-51.1797 4....\n7  MULTIPOLYGON (((-48.35878 -...\n8  MULTIPOLYGON (((-45.84073 -...\n9  MULTIPOLYGON (((-41.74605 -...\n10 MULTIPOLYGON (((-41.16703 -...\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(ufs) +\n  geom_sf()\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-17-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nComo mencionei acima, a função `geom_sf` aceita vários argumentos estéticos já que ela desenha pontos, linhas e polígonos. No caso do mapa abaixo, `color` define a cor do contorno/fronteira do polígono, enquanto `fill` define a cor do interior do polígono.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(ufs) +\n  geom_sf(color = \"#000000\", aes(fill = name_region)) +\n  scale_fill_brewer(name = \"\", type = \"qual\") +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-18-1.png){fig-align='center' width=80%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(ufs) +\n  geom_sf(color = \"#000000\", aes(fill = name_region)) +\n  scale_fill_brewer(name = \"\", type = \"qual\") +\n  theme(legend.position = \"top\") +\n  coord_sf(xlim = c(-60, -48), ylim = c(-35, -20))\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-19-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n## Mapas coropléticos\n\nUm mapa coroplético é um mapa colorido, em que as cores representam valores de alguma variável.\n\n### Juntando shapes e dados\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nrented <- tibble::tribble(\n  ~abbrev_state, ~share_apto, ~share_rented, ~name_region, \n  #------------#------------#--------------#------------#      \n           \"RO\",           8,          11.1, \"Norte\", \n           \"AC\",        7.47,          6.93, \"Norte\",\n           \"AM\",        15.8,          7.26, \"Norte\",\n           \"RR\",        14.3,          11.7, \"Norte\", \n           \"PA\",        4.53,          6.39, \"Norte\",\n           \"AP\",        10.7,          6.34, \"Norte\",\n           \"TO\",        3.17,          11.7, \"Norte\", \n           \"MA\",        4.06,          5.74, \"Nordeste\",\n           \"PI\",        4.08,          5.15, \"Nordeste\",\n           \"CE\",        9.85,          9.68, \"Nordeste\",\n           \"RN\",        9.27,          10.8, \"Nordeste\", \n           \"PB\",        11.9,          9.18, \"Nordeste\",\n           \"PE\",        10.4,          9.98, \"Nordeste\",\n           \"AL\",        6.32,          10.0, \"Nordeste\", \n           \"SE\",        12.0,            11, \"Nordeste\",   \n           \"BA\",        12.0,          7.61, \"Nordeste\",\n           \"MG\",        14.0,          10.5, \"Sudeste\", \n           \"ES\",        21.7,          10.7, \"Sudeste\", \n           \"RJ\",        26.8,          10.7, \"Sudeste\", \n           \"SP\",        19.4,          12.7, \"Sudeste\", \n           \"PR\",        11.9,          11.7, \"Sul\", \n           \"SC\",          17,          11.8, \"Sul\", \n           \"RS\",        16.5,          8.46, \"Sul\",\n           \"MS\",        3.67,          11.9, \"Centro Oeste\", \n           \"MT\",        3.29,          12.7, \"Centro Oeste\", \n           \"GO\",        9.88,          13.6, \"Centro Oeste\", \n           \"DF\",        35.4,          17.8, \"Centro Oeste\"\n  )\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nufs_rent <- left_join(ufs, rented, by = \"abbrev_state\")\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(ufs_rent) + \n  geom_sf(aes(fill = share_rented)) +\n  scale_fill_distiller(direction = 1) +\n  coord_sf(xlim = c(NA, -35))\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-22-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n### Temas para mapas\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbase_map <- ggplot(ufs_rent) + \n  geom_sf(aes(fill = share_rented)) +\n  scale_fill_distiller(direction = 1, palette = 2) +\n  coord_sf(xlim = c(NA, -35))\n\nbase_map + \n  ggtitle(\"theme_map()\") +\n  ggthemes::theme_map()\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-23-1.png){fig-align='center' fig-pos='hold' width=100%}\n:::\n\n```{.r .cell-code}\nbase_map + \n  ggtitle(\"theme_void()\") +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-23-2.png){fig-align='center' fig-pos='hold' width=100%}\n:::\n:::\n\n\n\n### Discretizando dados contínuos\n\nO olho humano não é particularmente apto a distinguir diferenças sutis entre cores, quando dispotas lado a lado. Neste sentido, pode ser difícil captar certas nuances nos mapas coropléticos acima.\n\nHá três maneiras simples de agrupar dados contínuos para fazer mapas:\n\n1. Usar alguma variação de percentil, isto, quintis, decis, etc.\n2. Usar o algoritmo de Jenks.\n3. Definir quebras manualmente.\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n### Usando labels\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(ufs_rent) + \n  geom_sf(aes(fill = share_rented)) +\n  geom_sf_label(aes(label = share_rented), size = 2) +\n  scale_fill_distiller(direction = 1) +\n  coord_sf(xlim = c(NA, -35))\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-25-1.png){fig-align='center' width=80%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nzones <- st_read(here::here(\"static/data/districts.gpkg\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `districts' from data source \n  `/Users/viniciusoike/Documents/GitHub/restateinsight/static/data/districts.gpkg' \n  using driver `GPKG'\nSimple feature collection with 134 features and 7 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -47.20853 ymin: -24.06423 xmax: -45.69483 ymax: -23.1834\nGeodetic CRS:  WGS 84\n```\n:::\n:::\n\n\n### Encontrando os pontos dentro dos polígonos\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\narea_ponderacao <- geobr::read_weighting_area(3550308, showProgress = FALSE)\n\ncem2010 <- filter(cem, ano_lanc == 2010)\n\ncem2010 <- st_as_sf(cem2010, coords = c(\"lon\", \"lat\"), crs = 4674)\n\njoined <- cem2010 |> \n  st_join(area_ponderacao) |> \n  filter(!is.na(code_weighting))\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = area_ponderacao) + \n  geom_sf(data = cem2010, size = 0.1)\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-28-1.png){fig-align='center' width=80%}\n:::\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = area_ponderacao) + \n  geom_sf(data = joined, size = 0.1)\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-28-2.png){fig-align='center' width=80%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntab_price_m2 <- joined |> \n  st_drop_geometry() |> \n  summarise(\n    avg_m2 = weighted.mean(pc_m2_au, emp_unid),\n    .by = \"code_weighting\"\n    )\n\nprice_areas <- left_join(area_ponderacao, tab_price_m2, by = 'code_weighting')\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(price_areas) + \n  geom_sf(aes(fill = avg_m2)) +\n  scale_fill_viridis_c(option = \"inferno\")\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-30-1.png){fig-align='center' width=80%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbbox <- st_bbox(\n  c(ymin = -23.612637, ymax = -23.520459, xmin = -46.714894, xmax = -46.525062)\n  )\n\nbbox <- st_as_sfc(bbox)\nbbox <- st_as_sf(bbox, crs = 4674)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngrid <- bbox |> \n  st_transform(crs = 32722) |> \n  st_make_grid(cellsize = 500) |> \n  st_as_sf()\n\nggplot(grid) + geom_sf()\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-32-1.png){fig-align='center' width=80%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngrid$gid <- 1:nrow(grid)\ngrid <- st_transform(grid, crs = 4674)\n\npoints_grid <- cem2010 |> \n  st_join(grid) |> \n  filter(!is.na(gid))\n\ntab_count = points_grid |> \n  st_drop_geometry() |> \n  summarise(count = sum(emp_unid), .by = \"gid\")\n\ngrid_count = left_join(grid, tab_count, by = \"gid\")\n\nggplot(grid_count) + \n  geom_sf(aes(fill = count)) +\n  coord_sf()\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-33-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n## Mapas com elementos de mapas\n\nPara introduzir os mapas com \"elementos de mapas\"\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(osmdata)\n\n## osmdata -----------------------------------------------------------------\n\n# Define bbox\nbbox <- getbb(\"Liberdade, São Paulo, Brazil\")\n# Base query\nqr <- opq(bbox)\n\n# Add feature requests to query\n\n# All roads\nqr_roads <- add_osm_feature(qr, key = \"highway\")\n# Only big roads\nqr_big_streets <- add_osm_feature(\n  qr,\n  key = \"highway\",\n  value = c(\"motorway\", \"primary\", \"motorway_link\", \"primary_link\")\n)\n# Only medium roads\nqr_med_streets <- add_osm_feature(\n  qr,\n  key = \"highway\",\n  value = c(\"secondary\", \"tertiary\", \"secondary_link\", \"tertiary_link\")\n)\n# Only small roads\nqr_small_streets <- add_osm_feature(\n  qr,\n  key = \"highway\",\n  value = c(\"residential\", \"living_street\", \"unclassified\", \"service\",\n            \"footway\")\n)\n# Download\nroads <- osmdata_sf(q = qr_roads)\nbig_streets <- osmdata_sf(q = qr_big_streets)\nmed_streets <- osmdata_sf(q = qr_med_streets)\nsmall_streets <- osmdata_sf(q = qr_small_streets)\n\ns1 <- big_streets$osm_lines %>%\n  st_transform(crs = 4674)\n\ns2 <- med_streets$osm_lines %>%\n  st_transform(crs = 4674)\n\ns3 <- small_streets$osm_lines %>%\n  st_transform(crs = 4674)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(\n    data = s1,\n    key_glyph = draw_key_rect,\n    size = 2\n  ) +\n  geom_sf(\n    data = s2,\n    key_glyph = draw_key_rect,\n    size = 0.6,\n    color = \"gray40\"\n  ) +\n  geom_sf(\n    data = s3,\n    key_glyph = draw_key_rect,\n    size = 0.45,\n    color = \"gray50\"\n  )\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-35-1.png){fig-align='center' width=80%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = s1, key_glyph = draw_key_rect, size = 2) +\n  geom_sf(data = s2, key_glyph = draw_key_rect, size = 0.6) +\n  geom_sf(data = s3, key_glyph = draw_key_rect, size = 0.45) +\n  geom_point(\n    data = rent,\n    aes(x = house_lng, y = house_lat),\n    size = 0.4,\n    color = \"#023047\"\n  ) +\n  geom_density_2d(\n    data = rent,\n    aes(x = house_lng, y = house_lat)\n  ) +\n  labs(x = NULL, y = NULL) +\n  scale_x_continuous(expand = c(0,0)) +\n  scale_y_continuous(expand = c(0,0)) +\n  cowplot::theme_nothing()\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-36-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n### Elevação em São Paulo\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Importa o shape file do limite do município de São Paulo\nborder <- geobr::read_municipality(3550308, showProgress = FALSE)\n\n#> Importa dados com a elevação da cidade\nelevation <- elevatr::get_elev_raster(border, z = 7)\n#> Transforma os dados em polígonos e converte para sf\nelevation <- raster::rasterToPolygons(elevation)\nelevation <- st_as_sf(elevation)\nnames(elevation)[1] <- \"elevation\"\n\n#> Converte CRS e junta o shape de altitude com o shape da cidade\nspo_alti <- elevation %>%\n  st_transform(crs = 4674) %>%\n  st_intersection(border) %>%\n  filter(st_is_valid(.))\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = spo_alti, aes(color = elevation, fill = elevation)) +\n  scale_color_viridis_c(name = \"\", option = \"inferno\", direction = -1) +\n  scale_fill_viridis_c(name = \"\", option = \"inferno\", direction = -1) +\n  coord_sf() +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-38-1.png){fig-align='center' width=80%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njbreaks <- BAMMtools::getJenksBreaks(spo_alti$elevation, k = 8)\njbreaks <- round(jbreaks, -1)\njlabels <- paste(jbreaks, jbreaks[-1], sep = \"--\")\njlabels[length(jlabels)] <- paste0(max(jbreaks), \"+\")\n\nspo_alti <- mutate(spo_alti, jenks_group = factor(findInterval(elevation, jbreaks)))\n\nggplot() +\n  geom_sf(data = spo_alti, aes(color = jenks_group, fill = jenks_group)) +\n  scale_color_viridis_d(name = \"\", labels = jlabels, option = \"inferno\") +\n  scale_fill_viridis_d(name = \"\", labels = jlabels, option = \"inferno\") +\n  coord_sf() +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-39-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n### Elevação das ruas\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nborder = geobr::read_municipality(3548807, showProgress = FALSE)\n\nbbox <- opq(bbox = \"São Caetano do Sul, São Paulo, Brazil\")\n\nroads <- add_osm_feature(\n  bbox,\n  key = \"highway\",\n  value = c(\"primary\", \"secondary\", \"tertiary\", \"residential\")\n  )\n\nroads_sf <- osmdata_sf(roads)\nroads_sf <- roads_sf$osm_lines\nroads_sf <- st_transform(roads_sf, crs = 4674)\nroads_border <- st_intersection(roads_sf, border)\n\naltitude <- elevatr::get_elev_raster(border, z = 9, clip = \"bbox\")\nspo_alti <- raster::rasterToPolygons(altitude)\nspo_alti <- sf::st_as_sf(spo_alti)\nnames(spo_alti)[1] <- \"elevation\"\n\nspo_alti <- spo_alti %>%\n  st_transform(crs = 4674) %>%\n  st_intersection(border) %>%\n  filter(st_is_valid(.))\n\njbreaks <- BAMMtools::getJenksBreaks(spo_alti$elevation, k = 5)\n\nspo_alti <- spo_alti %>%\n  mutate(\n    jenks_group = factor(findInterval(elevation, jbreaks))\n  )\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_streets_altitude <- function(altitude, streets) {\n  \n  stopifnot(any(colnames(altitude) %in% \"jenks_group\"))\n  \n  #> Get all groups\n  groups = levels(altitude$jenks_group)\n  \n  #> For each group get the full polygon and join with streets\n  join_streets = function(group) {\n    \n    poly = altitude %>%\n      filter(jenks_group == group) %>%\n      st_union(.) %>%\n      st_as_sf()\n    \n    joined = suppressWarnings(st_intersection(streets, poly))\n    \n    return(joined)\n    \n  }\n  #> Apply the function to all groups\n  street_levels = parallel::mclapply(groups, join_streets)\n  #> Bind all results together\n  names(street_levels) = groups\n  out = bind_rows(street_levels, .id = \"level\")\n  \n  return(out)\n  \n}\n\nstreets_alti <- get_streets_altitude(spo_alti, roads_border)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = streets_alti, aes(color = level, fill = level)) +\n  scale_fill_viridis_d(option = \"inferno\") +\n  scale_color_viridis_d(option = \"inferno\") +\n  coord_sf() +\n  cowplot::theme_nothing() +\n  theme(\n    legend.position = \"right\"\n  )\n```\n\n::: {.cell-output-display}\n![](12-mapas_files/figure-html/unnamed-chunk-42-1.png){fig-align='center' width=80%}\n:::\n:::\n",
    "supporting": [
      "12-mapas_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/htmlwidgets-1.6.2/htmlwidgets.js\"></script>\n<script src=\"../../site_libs/jquery-1.12.4/jquery.min.js\"></script>\n<link href=\"../../site_libs/leaflet-1.3.1/leaflet.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/leaflet-1.3.1/leaflet.js\"></script>\n<link href=\"../../site_libs/leafletfix-1.0.0/leafletfix.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/proj4-2.6.2/proj4.min.js\"></script>\n<script src=\"../../site_libs/Proj4Leaflet-1.0.1/proj4leaflet.js\"></script>\n<link href=\"../../site_libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/leaflet-binding-2.1.2/leaflet.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}