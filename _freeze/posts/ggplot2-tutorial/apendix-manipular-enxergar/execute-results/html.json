{
  "hash": "730ff5810065908776a62c83cc7073cf",
  "result": {
    "markdown": "---\ntitle: \"Apêndice: manipular para enxergar\"\ndate: '2023-08-04'\ncategories: ['data-visualization', 'ggplot2', 'tutorial-R']\nexecute: \n  message: false\n  warning: false\nformat:\n  html:\n    code-fold: false\n    code-tools: true\n    fig-align: center\n    fig-asp: 0.618\ndraft: true\nfreeze: true\n---\n\n\n\n\n# Limpeza de dados\n\nO primeiro passo para montar uma visualização é ter os dados no formato certo. Em geral, isto envolve três etapas: (1) importar os dados no `R`; (2) limpar os dados; e (3) transformar os dados no formato apropriado. Neste tutorial vamos focar sobretudo nas últimas duas etapas.\n\nDados tabulares são armazenados dentro de objetos chamados `data.frame`. Todo gráfico de `ggplot` começa com um (ou mais) `data.frame`. Apesar de ser possível montar gráficos a partir de vetores de dados dispersos, recomendo fortemente que sempre se utilize dados dentro de `data.frame.` Isto garante um código mais organizado e menos propenso a erros.\n\nApesar de funcionar como um repositório de pacotes, o `R` já vem com diversas funções \"de fábrica\" que permitem a importação e manipulação de dados.\n\nEstas funções que já vem carregadas no `R` são chamadas de funções \"base\". Alguns pacotes foram criados para melhorar estas funções \"base\".\n\nVamos começar instalando o conjunto de pacotes `tidyverse`.\n\n### Você tem um momento para falar sobre o `tidyverse`?\n\nO `tidyverse` é um metapacote, ele instala vários pacotes simultaneamente quando instalado e carrega múltiplos pacotes quando chamado. Estes pacotes formam uma família de pacotes que são unidos por uma filosofia e um objetivos comuns: todos os pacotes têm como objetivo a limpeza de dados e, de maneira geral, seguem o princípio de \"tidy\" data.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Instala o pacote tidyverse\ninstall.packages(\"tidyverse\")\n# Carrega o pacote tidyverse\nlibrary(\"tidyverse\")\n```\n:::\n\n\nTodos os pacotes e funções que vamos utilizar serão carregados nesta única linha de código.\n\n-   `readr` - importação e exportação de dados.\n-   `dplyr` - manipulação de dados.\n-   `tidyr` - manipulação de dados.\n-   `stringr` - manipulacao de strings (`character`)\n-   `forcats` - manipulacao de `factors`\n-   `lubridate` - manipulação de datas (`Date`)\n\nO `tidyverse` inclui ainda mais pacotes, como `rvest` para webscrapping, ou `dbplyr` que permite utilizar comandos do `dplyr` em databases.\n\n## Tabelas\n\nO objeto central da análise de dados é o `data.frame`. Um `data.frame` é uma tabela bidimensional que contém informações: em geral, cada coluna é uma variável diferente e cada linha é uma observação. Este objeto possui propriedades bastante simples:\n\n1.  **Comprimento fixo**. O número de linhas de um `data.frame` é fixo, assim todas as colunas têm o mesmo comprimento.\n2.  **Homogeneidade**. Cada coluna de um `data.frame` é homogênea, isto é, contém um dado de um único tipo. Assim, uma mesma coluna não pode misturar um string e uma Data.\n3.  **Nomes**. Cada coluna tem um nome (único e idiomático). Este nome é utilizado para fazer refrência a esta coluna.\n\nEstas três características garantem a funcionalidade e consistência de um `data.frame`. O comprimento fixo e a homogeneidade, em particular, tornam este tipo de objeto muito conveniente e previsível.\n\n### Construindo tabelas\n\nPara construir um `data.frame` basta chamar a função homônima e declarar as suas colunas seguindo as três propriedades acima. Nos exemplos abaixo, ao invés da função `data.frame` vou utilizar a função `tibble` que é, essencialmente, equivalente, mas que possui algumas pequenas vantagens. No restante do texto as palavras `tibble` e `data.frame` serão utilizadas\n\nNo primeiro exemplo crio uma tabela com três linhas e duas colunas\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndados <- tibble(\n  cidade = c(\"Porto Alegre\", \"São Paulo\", \"Salvador\"),\n  pop22 = c(1.332, 11.451, 2.418)\n)\n```\n:::\n\n\nPara visualizar o resultado basta chamar o objeto por nome ou usar a função `print`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndados\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  cidade       pop22\n  <chr>        <dbl>\n1 Porto Alegre  1.33\n2 São Paulo    11.5 \n3 Salvador      2.42\n```\n:::\n:::\n\n\nPode-se também criar a tabela a partir de vetores/objetos previamente declarados.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncidades <- c(\"Porto Alegre\", \"São Paulo\", \"Salvador\")\npopulacao <- c(1.332, 11.451, 2.418)\n\ndados <- tibble(\n  nome_cidade = cidades,\n  pop22 = populacao\n)\n```\n:::\n\n\nQuando alguma das colunas não tiver o mesmo comprimento das demais, o `R` vai tentar \"reciclar\" os valores desta coluna. Em geral, isto vai causar um erro, mas em alguns casos pode funcionar. No caso abaixo o valor `\"Brasil\"` (de comprimento unitário) é repetido três vezes para \"caber\" dentro da tabela.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndados <- tibble(\n  cidade = c(\"Porto Alegre\", \"São Paulo\", \"Salvador\"),\n  pop22 = c(1.332, 11.451, 2.418),\n  pais = \"Brasil\"\n)\n\ndados\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  cidade       pop22 pais  \n  <chr>        <dbl> <chr> \n1 Porto Alegre  1.33 Brasil\n2 São Paulo    11.5  Brasil\n3 Salvador      2.42 Brasil\n```\n:::\n:::\n\n\n### Propriedades de tabelas\n\nToda coluna de um `data.frame` possuí nomes. Para acessar os nomes usa-se `names`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnames(dados)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"cidade\" \"pop22\"  \"pais\"  \n```\n:::\n\n```{.r .cell-code}\n#> [1] \"cidade\" \"pop22\"  \"pais\"\n```\n:::\n\n\nOs nomes das colunas sempre devem ser únicos. Mesmo no caso em que se tenta criar uma tabela com nomes idênticos, a função `data.frame` evita que isto acontece\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntab <- data.frame(\n  a = c(1, 2, 3),\n  a = c(\"a\", \"b\", \"c\")\n)\n\ntab\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  a a.1\n1 1   a\n2 2   b\n3 3   c\n```\n:::\n:::\n\n\nA função `tibble` é um pouco mais exigente e retorna um erro neste caso\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntab <- tibble(\n  a = c(1, 2, 3),\n  a = c(\"a\", \"b\", \"c\")\n)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `tibble()`:\n! Column name `a` must not be duplicated.\nUse `.name_repair` to specify repair.\nCaused by error in `repaired_names()`:\n! Names must be unique.\n✖ These names are duplicated:\n  * \"a\" at locations 1 and 2.\n```\n:::\n:::\n\n\nPara extrair uma coluna de um `data.frame` temos duas opções. A mais simples e direta é utilizar o operador `$` e chamar o nome da coluna como se fosse um objeto. A segunda opção é utilizar `[[` e chamar o nome da coluna como um string.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Extraindo uma coluna \n\ndados$cidade\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Porto Alegre\" \"São Paulo\"    \"Salvador\"    \n```\n:::\n\n```{.r .cell-code}\n#> [1] \"Porto Alegre\" \"São Paulo\"    \"Salvador\"\n\ndados[[\"cidade\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Porto Alegre\" \"São Paulo\"    \"Salvador\"    \n```\n:::\n\n```{.r .cell-code}\n#> [1] \"Porto Alegre\" \"São Paulo\"    \"Salvador\"\n```\n:::\n\n\n### Importando tabelas\n\nRaramente vamos declarar todas as observações de uma tabela. Na prática, é muito mais comum importar uma tabela de alguma fonte externa como de uma planilha de Excel ou de um arquivo csv. Para cada tipo de arquivo existe uma função `read_*` diferente. Importar dados costuma ser uma tarefa frustrante por três motivos:\n\n1.  Há muitos arquivos para se importar.\n2.  É difícil fazer o `R` encontrar o arquivo.\n3.  Os arquivos têm problemas (valores corrompidos, linhas vazias, etc.)\n\nOs dois primeiros problemas são simples de se resolver. Pode-se importar múltiplos arquivos ao mesmo tempo usando um loop; importar todos os arquivos dentro de uma mesma pasta é trivial, desde que os arquivos sigam o mesmo padrão.\n\nGarantir que o `R` consiga encontrar os arquivos também é simples. Idealmente, todos os arquivos externos devem estar organizados dentro de uma pasta chamada `dados` ou `data` e deve-se chamar estes dados usando funções `read_*`. Uma boa prática é sempre usar \"caminhos relativos\" ao invés de caminhos absolutos.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Ruim\ndat <- read_csv(\"/Users/viniciusoike/Documents/GitHub/projeto/data/income.csv\")\n#> Bom \ndat <- read_csv(\"data/income.csv\")\n#> Ainda melhor\ndat <- read_csv(here::here(\"data/income.csv\"))\n```\n:::\n\n\nO terceiro problema é muito mais complexo e vai exigir mais conhecimento e prática. Em geral, resolve-se a maior parte dos problemas usando algum dos argumentos dentro da função `read_*` como:\n\n-   `skip`: Pula as primeiras k linhas.\n\n-   `na`: Define quais valores devem ser interpretados como valores ausentes.\n\n-   `col_types`: Permite que se declare explicitamente qual o tipo de dado (numérico, data, texto) que está armazenado em cada coluna.\n\n-   `col_names` ou `name_repair`: O primeiro permite que se declare explicitamente o nome que cada coluna vai ter dentro do `R` enquanto o segundo permite que se use uma função que renomeia as colunas.\n\n-   `locale`: Permite selecionar diferentes tipos de padrão de local. Em geral, usa-se `locale = locale(\"pt_BR\")`.\n\n-   range: Este argumento só vale no caso de planilhas de Excel e permite que se importe uma seleção específica da planilha (e.g. \"D4:H115\")\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Input de um csv sujo\ndados <-\n'Data; Valor (R$/m2)\n\"01-maio-2020\";22,3\n\"01-junho-2020\";21,5\n\"06-julho-2021\";X\n\"07-novembro-2022\";22'\n\n#> Lendo o arquivo\ndf <- read_delim(\n  I(dados) ,\n  delim = \";\",\n  #> Usa , como separador decimal; lê meses em português (e.g. maio, junho, etc.)\n  locale = locale(decimal_mark = \",\", date_names = \"pt\", date_format = \"%d-%B-%Y\"),\n  #> Interpreta X como valores ausentes (NA)\n  na = \"x\",\n  #> Renomeia as colunas\n  name_repair = janitor::clean_names\n  )\n```\n:::\n\n\n# Manipulando dados\n\n## O Básico\n\nO pacote `dplyr` é uma das ferramentas mais populares e úteis para manipulação de dados no R. Ele fornece uma série de funções simples e poderosas para filtrar, agrupar, modificar e resumir dados. Neste tutorial, vamos explorar algumas dessas funções e ver como elas podem ser usadas para realizar tarefas comuns de manipulação de dados.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# create example data\ndf <- tibble(\n  x = c(1, 2, 3, 4, 5),\n  y = c(2, 4, 6, 8, 10),\n  z = c(\"a\", \"b\", \"c\", \"d\", \"e\")\n)\n```\n:::\n\n\nAgora, vamos ver algumas das funções mais úteis do dplyr:\n\n| Nome da Função | Tradução          | O que faz                                                        |\n|---------------|---------------|------------------------------------------|\n| `rename`       | Renomear          | Modifica o nome das colunas                                      |\n| `select`       | Selecionar        | Seleciona as colunas                                             |\n| `filter`       | Filtrar           | Filtra/seleciona as linhas segundo alguma condição               |\n| `arrange`      | Arranjar/ordenar  | Ordena as linhas (crescente/decrescente) segundo alguma variável |\n| `summarise`    | Sumarisar/resumir | Aplica alguma função sobre as linhas. Cria uma tabela \"resumo\".  |\n| `group by`     | Agrupar           | Agrupa as linhas segundo alguma variável                         |\n|                |                   |                                                                  |\n\n-   rename(): permite renomear colunas de um tibble\n-   mutate(): permite criar novas colunas baseadas em outras colunas\n-   filter(): permite selecionar apenas as linhas que atendem a determinadas condições\n-   arrange(): permite ordenar os dados por uma ou mais colunas\n-   group_by(): permite agrupar os dados por uma ou mais colunas\n-   summarise(): permite resumir os dados de várias maneiras, como fazer médias, somas, etc.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntbl <- tibble(\n  Cidade = c(\"Porto Alegre\", \"Curitiba\", \"São Paulo\", \"Rio de Janeiro\"),\n  `População` = \n)\n```\n:::\n\n\n### rename\n\nPara renomear as colunas de `data.frame`\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n### select\n\n### mutate\n\n### arrange\n\n### summarise e group_by\n\n## Formato dos dados\n\n# Indo mais a fundo\n\n## Strings e texto\n\n## Números e Datas\n\n## Factors\n\nAgora que temos os dados em um tibble, podemos começar a limpar e transformar os dados. O primeiro passo é verificar se os dados estão no formato tidy. O formato tidy é um padrão para organizar os dados de maneira consistente e fácil de trabalhar. Ele consiste em três regras básicas:\n\nCada coluna deve conter apenas um tipo de variável Cada linha deve conter uma única observação Cada tipo de observação deve ter sua própria tabela\n\nAmbas as funções são muito úteis para criar novas colunas baseadas em condições lógicas. No entanto, é importante lembrar que a linguagem lógica do R é um pouco diferente da linguagem lógica em outras linguagens de programação. Alguns dos operadores lógicos mais comuns são:\n\n\\|: operador \"ou\" &: operador \"e\" !: operador \"não\" ==: operador de igualdade Por exemplo, para verificar se um número é maior que 5 e menor que 10, podemos usar a seguinte condição:\n\nAlém dessas funções, o pacote dplyr também inclui uma série de funções de agregação, como mean(), sum(), median(), sd(), var(), etc. Essas funções são muito úteis quando usamos group_by() e summarise() para resumir os dados.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf <- tibble(\n  id = c(1, 2, 3),\n  value_1 = c(10, 20, 30),\n  value_2 = c(15, 25, 35)\n)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n     id value_1 value_2\n  <dbl>   <dbl>   <dbl>\n1     1      10      15\n2     2      20      25\n3     3      30      35\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npivot_longer(data = df, cols = c(value_1, value_2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n     id name    value\n  <dbl> <chr>   <dbl>\n1     1 value_1    10\n2     1 value_2    15\n3     2 value_1    20\n4     2 value_2    25\n5     3 value_1    30\n6     3 value_2    35\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npivot_longer(data = df, cols = -id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n     id name    value\n  <dbl> <chr>   <dbl>\n1     1 value_1    10\n2     1 value_2    15\n3     2 value_1    20\n4     2 value_2    25\n5     3 value_1    30\n6     3 value_2    35\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npivot_longer(data = df, cols = starts_with(\"value\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n     id name    value\n  <dbl> <chr>   <dbl>\n1     1 value_1    10\n2     1 value_2    15\n3     2 value_1    20\n4     2 value_2    25\n5     3 value_1    30\n6     3 value_2    35\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}