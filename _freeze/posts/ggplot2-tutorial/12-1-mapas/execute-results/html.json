{
  "hash": "60c425a666d29a1cd00374d8e5b75feb",
  "result": {
    "markdown": "---\ntitle: 'You need a map - Parte 1'\ndate: '2024-01-03'\ncategories: ['data visualization', 'ggplot2', 'turorial-R']\ndescription: \"O ggplot2 tem uma ótima interface para a produção de mapas de alta qualidade. Neste primeiro post, mostro como fazer mapas usando os conhecimentos adquiridos até aqui sem a necessidade de se preocupar com objetos geométricos.\"\n---\n\n\n\n\n\n\n# Mapas\n\nEu começo este post com uma confissão: eu sofri muito até conseguir fazer mapas minimamente apresentáveis com o R. Há duas dificuldades bem sérias: primeiro, objetos geométricos são uma classe de objetos bastante complexa; segundo, há inúmeras convenções na elaboração de mapas que escapam completamente aos objetivos do economista.\n\nEste post vai tentar ensinar a fazer mapas, apresentando absolutamente o mínimo necessário sobre convenções cartográficas, tipos de projeção, e geografia de maneira geral. Por questão de completude ele é dividido em três partes: na primeira parte mostro como fazer mapas de pontos de maneira simples sem se preocupar com geometria; na segunda parte mostro como fazer mapas coropléticos, mapas onde as cores usualmente representam o valor das variáveis; por fim, na terceira parte, mostro como fazer mapas estáticos com \"elementos de mapa\" como ruas, avenidas, rios, etc.\n\n# Quero apenas fazer um mapa interativo\n\nSe o seu objetivo é fazer um mapa interativo não use `ggplot`. Comece explorando o `leaflet`. Se o objetivo for menos visualização e mais \"ciência de dados\" e você não quer perder horas customizando cores no {leaflet} use o {tmap} ou {mapview}.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(leaflet)\n\nleaflet() %>%\n  addTiles() %>%\n  setView(lng = -46.6554, lat = -23.5651, zoom = 13)\n```\n\n::: {.cell-output-display}\n```{=html}\n<div class=\"leaflet html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-ccfa43f6302c987d826c\" style=\"width:90%;height:400.464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-ccfa43f6302c987d826c\">{\"x\":{\"options\":{\"crs\":{\"crsClass\":\"L.CRS.EPSG3857\",\"code\":null,\"proj4def\":null,\"projectedBounds\":null,\"options\":{}}},\"calls\":[{\"method\":\"addTiles\",\"args\":[\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",null,null,{\"minZoom\":0,\"maxZoom\":18,\"tileSize\":256,\"subdomains\":\"abc\",\"errorTileUrl\":\"\",\"tms\":false,\"noWrap\":false,\"zoomOffset\":0,\"zoomReverse\":false,\"opacity\":1,\"zIndex\":1,\"detectRetina\":false,\"attribution\":\"&copy; <a href=\\\"https://openstreetmap.org\\\">OpenStreetMap<\\/a> contributors, <a href=\\\"https://creativecommons.org/licenses/by-sa/2.0/\\\">CC-BY-SA<\\/a>\"}]}],\"setView\":[[-23.5651,-46.6554],13,[]]},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\n# Mapas estáticos sem objetos espaciais\n\n## O básico\n\nA abordagem mais simples para tratar dados espaciais é simplesmente tratá-los como dados tabulados quaisquer. Isto funciona perfeitamente bem para objetos geométricos na forma de pontos e linhas, mas torna-se impraticável no caso de polígonos.\n\nNo plano cartesiano, longitude e latitude são literalmente coordenadas; pode-se mapear estas coordenadas como pontos num gráfico de dispersão. Para tornar os exemplos mais aplicados vamos usar a base de [Empreendimentos Residenciais Verticais da Embraesp](https://geoembraesp.embraesp.com.br), disponibilizado pelo [Centro de Estudos da Metrópole da FAU/USP](https://centrodametropole.fflch.usp.br/pt-br/download-de-dados?busca_geral=empreendimentos&items_per_page=20). Os dados compreendem todos os lançamentos residenciais na Região Metropolitana de São Paulo entre 1985 e 2013. Para simplificar nossa análise vamos nos restringir somente aos empreendimentos lançados na capital.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Os pacotes necessários\nlibrary(ggplot2)\nlibrary(sf)\nlibrary(dplyr)\n\n# Para ler os dados dentro do R a partir do Github\ncem <- readr::read_csv(\n  \"https://github.com/viniciusoike/restateinsight/raw/main/static/data/cem_imoveis.zip\"\n  )\n#| Seleciona apenas os empreendimentos lançados em São Paulo (capital)\ncem <- cem |> \n  mutate(code_muni = as.numeric(substr(ap2010, 1, 7))) |> \n  filter(code_muni == 3550308)\n```\n:::\n\n\nNo gráfico abaixo cada ponto é um empreendimento residencial lançado em São Paulo entre 1985 e 2013. Note que os valores de longitude e latitude são fornecidos diretamente aos argumentos `x` e `y`.\n\nA função `coord_sf` fornece mais estrutura ao sistema de coordenadas. Especificamente, esta função garante que os dados plotados compartilhem o mesmo sistema de coordenadas e permite explicitamente definir qual sistema utilizar. No exemplo abaixo uso `crs = sf::st_crs(4326)` que é código para a projeção do [World Geodetic System](https://epsg.io/4326).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(cem, aes(x = lon, y = lat)) +\n  geom_point(size = 0.1) +\n  coord_sf(crs = sf::st_crs(4326))\n```\n\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/unnamed-chunk-5-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\nA principal vantagem de tratar os pontos, simplesmente como pontos, é que podemos aplicar todo o nosso conhecimento acumulado até agora. Os dados no gráfico seguem a mesma lógica dos [gráficos de dispersão, visto anteriormente](https://restateinsight.com/posts/ggplot2-tutorial/1-grafico-dispersao) e a sua manipulação segue as mesmas [convenções de dados tabulares convencionais](https://restateinsight.com/posts/ggplot2-tutorial/apendix-manipular-enxergar).\n\nNo exemplo abaixo, o tamanho de cada círculo é proporcional ao número de unidades do empreendimento e a cor sinaliza se o empreendimento é veritical ou horizontal.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Seleciona somente empreendimentos lançados em 2008\ncem08 <- cem |> \n  filter(ano_lanc == 2008)\n\nggplot(cem08, aes(x = lon, y = lat)) +\n  geom_point(aes(size = emp_unid, color = as.factor(emp_tipo)), alpha = 0.5) +\n  coord_sf(crs = st_crs(4326))\n```\n\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/unnamed-chunk-6-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\nInfelizmente, é necessário repetir o CRS da projeção dos dados em todos os gráficos. No post seguinte, vamos ver como construir objetos \"geométricos\" com o pacote `sf`, que funcionam como um `data.frame` embutido com informação espacial; neste caso, o `ggplot2` sabe qual a projeção a ser utilizada e não é necessário declará-la.\n\nPode-se também fazer [gráficos em facets](https://restateinsight.com/posts/ggplot2-tutorial/9-facets) usando os dados de longitude e latitude. No gráfico abaixo, mostro os lançamentos ano a ano no período 2008-2011.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> Seleciona empreendimentos lançados entre 2008 e 2011\nsub <- cem |> \n  filter(ano_lanc %in% 2008:2011)\n\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_point(size = 0.4) +\n  coord_sf(crs = st_crs(4326)) +\n  facet_wrap(vars(ano_lanc))\n```\n\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/unnamed-chunk-7-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n## Agregando pontos\n\n### Mapas de contorno\n\nPode-se agregar os pontos em mapas de calor (contorno). Há duas funções principais:\n\n-   `geom_density_2d` - que desenha linhas de contorno\n-   `geom_density_2d_filled` - que desenha uma mapa de contorno\n\nNos gráficos abaixo uso apenas a subamostra de lançamentos no período 2008-2011.\n\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_density_2d() +\n  coord_sf(crs = st_crs(4326)) +\n  theme(legend.position = \"none\")\n\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_density_2d_filled() +\n  coord_sf(crs = st_crs(4326)) +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/unnamed-chunk-8-1.png){fig-align='center' width=100%}\n:::\n\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/unnamed-chunk-8-2.png){fig-align='center' width=100%}\n:::\n:::\n\n\nTalvez o argumento mais útil destas funções seja o `bins` ou `binwidth`, similar ao argumento de `geom_histogram`. Os mapas abaixo mostram como este argumento controla o número de quebras nas linhas de contorno. A função que calcula os contornos é a `MASS::kde2d()` e, em geral, ela escolhe bons valores para o número de bins.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_density_2d_filled(bins = 5) +\n  coord_sf(crs = st_crs(4326))\n\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_density_2d_filled(bins = 8) +\n  coord_sf(crs = st_crs(4326))\n\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_density_2d_filled(bins = 10) +\n  coord_sf(crs = st_crs(4326))\n\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_density_2d_filled(bins = 15) +\n  coord_sf(crs = st_crs(4326))\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/density-bins-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nNa base de dados do CEM cada linha é um tipo de unidade lançada de um empreendimento (uma tipologia). Assim, é possível (e recorrente) que um mesmo empreendimento apareça em várias linhas. A tabela abaixo mostra os empreendimentos lançados pela Cyrella em 2009. Note como o mesmo empreendimento aparece mais do que uma vez.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsub |> \n  filter(construt_a == \"Cyrela\", ano_lanc == 2009) |> \n  select(data_lanc, name_district, cep, emp_andares, emp_unid, emp_dorm, emp_elev, dorm, banh) |> \n  arrange(data_lanc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 15 × 9\n   data_lanc  name_district cep       emp_andares emp_unid emp_dorm emp_elev\n   <date>     <chr>         <chr>           <dbl>    <dbl>    <dbl>    <dbl>\n 1 2009-03-15 SANTO AMARO   04754-010          27      108      324        3\n 2 2009-03-15 SANTO AMARO   04754-010          27      108      432        3\n 3 2009-05-15 SANTO AMARO   04754-050          27      108      324        3\n 4 2009-05-15 SANTO AMARO   04754-050          27      108      432        3\n 5 2009-08-15 SANTO AMARO   04757-020          26      208      416        5\n 6 2009-08-15 SANTO AMARO   04757-020          26      104      312        3\n 7 2009-08-15 MORUMBI       05653-160           4       42       84        1\n 8 2009-08-15 MORUMBI       05653-160           4      159      318        3\n 9 2009-09-15 SANTO AMARO   04754-010          27      216      864        6\n10 2009-10-15 SANTO AMARO   04757-020          27      108      324        3\n11 2009-10-15 SANTO AMARO   04757-020          27      108      432        3\n12 2009-10-15 CASA VERDE    02452-001          26      104      312        3\n13 2009-11-15 SANTANA       02460-000          20       80      320        3\n14 2009-12-15 MORUMBI       05653-160           4       90       90        5\n15 2009-12-15 MORUMBI       05653-160           4      136      272        7\n    dorm  banh\n   <dbl> <dbl>\n 1     3     2\n 2     4     2\n 3     3     2\n 4     4     2\n 5     2     2\n 6     3     2\n 7     2     2\n 8     2     2\n 9     4     3\n10     3     2\n11     4     2\n12     3     3\n13     4     3\n14     1     1\n15     2     2\n```\n:::\n:::\n\n\nQuando os dados estão na forma de uma \"tabela de frequências\" usualmente usa-se o argumento `weight`. O exemplo abaixo mostra um gráfico de dispersão entre a área útil de cada tipologia e o seu preço final (atualizado pelo IGP-DI). No primeiro caso, cada tipologia tem peso idêntico, ou seja, uma tipologia que foi lançada 200 vezes tem o mesmo peso que uma outra tipologia que foi lançada apenas 20 vezes. No gráfico da direita, o argumento `weight = emp_unid` cria uma peso para cada observação, de tal maneira que as tipologias mais representativas têm peso maior no ajuste.\n\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(sub, aes(x = ar_ut_unid, y = log(pc_tt_atu))) +\n  geom_point() +\n  geom_smooth(method = \"gam\") +\n  scale_y_continuous(limits = c(NA, 16))\n\nggplot(sub, aes(x = ar_ut_unid, y = log(pc_tt_atu))) +\n  geom_point() +\n  geom_smooth(aes(weight = emp_unid), method = \"gam\") +\n  scale_y_continuous(limits = c(NA, 16))\n```\n\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/unnamed-chunk-10-1.png){fig-align='center' width=100%}\n:::\n\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/unnamed-chunk-10-2.png){fig-align='center' width=100%}\n:::\n:::\n\n\nInfelizmente, a função subjacente que a `geom_density_2d` utiliza não funciona diretamente com o argumento `weight`. A solução para contornar isto é criar uma tabela de dados onde as observações são repetidas usando a função `uncount`. Esta função repete as linhas de uma tabela segundo alguma variável: no caso abaixo, cada linha é repetida de acordo com o número de unidades que foram lançadas.\n\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n\n```{.r .cell-code}\ncount_unidades <- sub |> \n  select(emp_code, emp_unid, lat, lon) |> \n  uncount(emp_unid)\n\nggplot(count_unidades, aes(x = lon, y = lat)) +\n  geom_density_2d() +\n  coord_sf(crs = st_crs(4326)) +\n  ggtitle(\"Unidades lançadas\") +\n  labs(x = NULL, y = NULL) +\n  theme(legend.position = \"none\")\n\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_density_2d() +\n  coord_sf(crs = st_crs(4326)) +\n  ggtitle(\"Empreendimentos lançados\") +\n  labs(x = NULL, y = NULL) +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=100%}\n:::\n\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/unnamed-chunk-11-2.png){fig-align='center' width=100%}\n:::\n:::\n\n\nMais a título de curiosidade, também é possível usar adaptar a função `stat_density_2d()` para gerar um mapa similar ao do `geom_count`.\n\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_count() +\n  coord_sf(crs = st_crs(4326))\n\nggplot(sub, aes(x = lon, y = lat)) +\n  stat_density_2d(\n    geom = \"point\",\n    aes(size = after_stat(density)),\n    n = 20,\n    contour = FALSE\n    )\n```\n\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/unnamed-chunk-12-1.png){fig-align='center' width=100%}\n:::\n\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/unnamed-chunk-12-2.png){fig-align='center' width=100%}\n:::\n:::\n\n\nPode-se separar os contornos em grupos com cores distintas. No gráfico abaixo eu separo os empreendimentos pelo número de andares. Vê-se que os empreendimentos horizontais simples, de apenas um andar, estão concentrados no lado nordeste do gráfico. Já os empreendimentos verticais mais elevados (20 a 35 andares) estão concentrados no sudoeste do gráfico (grosso modo, região do Itaim Bibi) e na região oeste (grosso modo, região da Vila Formosa).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsub <- sub |> \n  mutate(\n    group = findInterval(emp_andares, c(1, 5, 10, 20, 35)),\n    group = factor(\n      group,\n      labels = c(\"1\", \"1 a 5\", \"5 a 10\", \"10 a 20\", \"20 a 35\")\n      )\n  )\n\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_density_2d(aes(color = group)) +\n  coord_sf(crs = st_crs(4326)) +\n  scale_color_brewer(name = \"Número de andares\", palette = 6, type = \"qual\") +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/unnamed-chunk-13-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\nComo de costume, é possível sobrepor vários tipos de geoms num mesmo gráfico. O gráfico abaixo mostra a distribuição espacial dos empreendimentos de 10 a 20 andares.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsub <- sub |> \n  mutate(\n    group = findInterval(emp_andares, c(1, 5, 10, 20, 35)),\n    group = factor(\n      group,\n      labels = c(\"1\", \"1 a 5\", \"5 a 10\", \"10 a 20\", \"20 a 35\")\n      )\n  )\n\nggplot(filter(sub, group == \"10 a 20\"), aes(x = lon, y = lat)) +\n  geom_point(aes(size = emp_unid), alpha = 0.1) +\n  geom_density_2d_filled(alpha = 0.5) +\n  coord_sf(crs = st_crs(4326))\n```\n\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n### Mapas com grids\n\nPor fim, vale mencionar duas funções simples que permitem agregar os pontos em um grid regular. Há duas opções de grids:\n\n1.  Quadrados com a função `geom_bin2d()` ou `geom_bin_2d()`\n2.  Hexágonos com a função `geom_hex()`\n\nTanto quadrados como hexágonos tem boas propriedades geométricas que os tornam aptos a agregar dados espaciais.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_bin2d() +\n  scale_fill_viridis_c(option = \"inferno\")\n```\n\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/unnamed-chunk-15-1.png){fig-align='center' width=90%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_bin2d(bins = 10) +\n  coord_sf(crs = st_crs(4326)) +\n  scale_fill_viridis_c(option = \"inferno\")\n\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_bin2d(bins = 15) +\n  coord_sf(crs = st_crs(4326)) +\n  scale_fill_viridis_c(option = \"inferno\")\n\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_bin2d(bins = 25) +\n  coord_sf(crs = st_crs(4326)) +\n  scale_fill_viridis_c(option = \"inferno\")\n\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_bin2d(bins = 50) +\n  coord_sf(crs = st_crs(4326)) +\n  scale_fill_viridis_c(option = \"inferno\")\n```\n:::\n\n\nExiste algum controle sobre a quantidade de quadrados via o argumento `bins` ou `binwidth` (similar ao argumento da função `geom_histogram`).\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/unnamed-chunk-17-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nO padrão da função `geom_bin2d()` é de contar o número de pontos dentro de cada quadrado. Pode-se mudar este valor via o argumento `weight` dentro de `aes`. No gráfico da esquerda, os dados representam o número total de unidades lançadas nos empreendimentos. Já no gráfico da direita, os valores representam o valor total (em R\\$ atualizados pelo IGP-DI) dos empreendimentos lançados\n\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_bin2d(aes(weight = emp_unid), bins = 25) +\n  coord_sf(crs = st_crs(4326)) +\n  ggtitle(\"Número de unidades lançadas\") +\n  scale_fill_viridis_c(option = \"inferno\")\n\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_bin2d(aes(weight = pc_emp_atu / 1e9), bins = 25) +\n  coord_sf(crs = st_crs(4326)) +\n  ggtitle(\"VGV dos empreendimentos\") +\n  scale_fill_viridis_c(option = \"inferno\")\n```\n\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/unnamed-chunk-18-1.png){fig-align='center' width=100%}\n:::\n\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/unnamed-chunk-18-2.png){fig-align='center' width=100%}\n:::\n:::\n\n\nOs mapas com hexágonos funcionam da mesma maneira que os mapas com grids em quadrado. Os mapas com hexágonos se tornaram bastante populares pois emulam o sistema de grid utilizado pela [Uber (H3)](https://h3geo.org). Os códigos abaixo mostram um exemplo simples de como montar gráficos em hexágonos. Para maior controle sobre os hexágonos vale explorar os pacotes [h3](https://github.com/crazycapivara/h3-r) e [h3r](https://github.com/scottmmjackson/h3r).\n\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_hex(bins = 15) +\n  scale_fill_viridis_c()\n\nggplot(sub, aes(x = lon, y = lat)) +\n  geom_hex(bins = 15, aes(weight = pc_emp_atu / 1e9)) +\n  scale_fill_viridis_c()\n```\n\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/unnamed-chunk-19-1.png){fig-align='center' width=100%}\n:::\n\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/unnamed-chunk-19-2.png){fig-align='center' width=100%}\n:::\n:::\n\n\nPor fim, vale notar que as técnicas de agregação de pontos que vimos aqui também funcionam com gráficos de dispersão convencionais. De fato, elas podem ser utilizadas para amenizar problemas de overplotting.\n\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(sub, aes(x = ar_ut_unid, y = log(pc_tt_atu))) +\n  geom_point() +\n  geom_smooth(aes(weight = emp_unid), method = \"gam\") +\n  scale_fill_viridis_c()\n\nggplot(sub, aes(x = ar_ut_unid, y = log(pc_tt_atu))) +\n  geom_bin2d(bins = 50) +\n  geom_smooth(aes(weight = emp_unid), method = \"gam\") +\n  scale_fill_viridis_c()\n```\n\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/unnamed-chunk-20-1.png){fig-align='center' width=100%}\n:::\n\n::: {.cell-output-display}\n![](12-1-mapas_files/figure-html/unnamed-chunk-20-2.png){fig-align='center' width=100%}\n:::\n:::\n\n\n# Resumo\n\nNeste post vimos como utilizar a informação \"crua\" de latitude e longitude para gerar mapas simples de pontos e mapas de calor em geral. Estes mapas, em geral, não costumam servir para publicações ou trabalhos mais sérios, mas podem ser muito úteis para a exploração de dados. As mesmas técnicas de agregação de pontos também podem ser utilizadas em gráficos de dispersão convencionais, para evitar o overplotting.\n\n## Posts Relacionados\n\n-   [Fundamentos: Gráfico de dispersão](https://restateinsight.com/posts/ggplot2-tutorial/1-grafico-dispersao)\n\n-   [Fundamentos: histograma](https://restateinsight.com/posts/ggplot2-tutorial/3-grafico-histograma)\n",
    "supporting": [
      "12-1-mapas_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/htmlwidgets-1.6.2/htmlwidgets.js\"></script>\n<script src=\"../../site_libs/jquery-1.12.4/jquery.min.js\"></script>\n<link href=\"../../site_libs/leaflet-1.3.1/leaflet.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/leaflet-1.3.1/leaflet.js\"></script>\n<link href=\"../../site_libs/leafletfix-1.0.0/leafletfix.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/proj4-2.6.2/proj4.min.js\"></script>\n<script src=\"../../site_libs/Proj4Leaflet-1.0.1/proj4leaflet.js\"></script>\n<link href=\"../../site_libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/leaflet-binding-2.1.2/leaflet.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}