{
  "hash": "770b814a1cf7074f86bd92f3eb736b47",
  "result": {
    "markdown": "---\ntitle: \"Regressão Linear com Séries de Tempo\"\nauthor: \"Vinicius Oike\"\ncategories: ['econometria', 'tutorial-r']\ntitle-block-banner: true\nfig-align: \"center\"\nfig-asp: 0.618\nexecute: \n  warning: false\n  message: false\ndescription: \"Cursos de econometria em séries de tempo às vezes omitem o uso de MQO num contexto de séries de tempo. Neste post discuto brevemente algumas aplicações.\"\n---\n\n\n# Introdução\n\n[Este post foi originalmente escrito no início de 2019. Muitos dos pacotes apresentados aqui evoluíram bastante, mas acredito que o post original ainda tenha bastante valor didático para quem está iniciando seus estudos em econometria e R.]\n\nOs cursos de econometria de séries de tempo, usualmente, começam pelo ensino de modelos lineares univariados para séries estacionárias. Estes modelos são da família ARMA e tentam representar uma série de tempo $y_{t}$ em função de suas defasagens $y_{t-1}, y_{t-2}, \\dots, y_{t-n}$ e de choques aleatórios (inovações) $\\epsilon_{t}, \\epsilon_{t-1}, \\epsilon_{t-2}, \\dots, y_{t-n}$. Contudo, pode ser mais interessante relacionar duas séries de tempo $y_{t}$ e $x_{t}$ diferentes via um modelo linear. Em alguns casos isto pode ser equivalente a um VAR ou VARMA, mas o modelo linear tem a vantagem de ser mais simples de implementar e de interpretar. O tipo de modelo linear que estamos interessados é da forma\n\n$$\n  y_{t} = \\beta_{0} + \\beta_{1}x_{t} + w_{t}\n$$\n\nonde $y_{t}$ é a série que queremos \"explicar\" em função da série $x_{t}$. É evidente que podemos estender este modelo para incluir defasagens das variáveis $x_{t}$ e $y_{t}$, além de incluir outras séries, dummies, efeitos sazonais e tendências temporais.\n\nQuando se usa dados em forma de séries de tempo numa regressão linear, é bastante comum que se enfrente algum nível de autocorrelação nos resíduos. Uma das hipóteses do modelo \"clássico\" de regressão linear é de que as observações são i.i.d., isto é, que os dados são independentes e identicamente distribuídos. Isto obviamente não se aplica no contexto de séries de tempo (os dados não são independentes), então é preciso algum cuidado no uso de modelos de regressão linear. Neste sentido, o diagnósito dos resíduos é o mais importante passo para verificar a qualidade do modelo. Idealmente, os resíduos do modelo devem se comportar como ruído branco (i.e., não devem apresentar autocorrelação).\n\nOutro problema típico deste tipo de análise, chamado de \"regressão espúria\", acontece quando se faz a regressão de séries não-estacionárias. Quaisquer duas séries com tendência serão fortemente linearmente relacionadas. Isto leva a uma regressão com $R^2$ altíssimo e estatísticas-t muito significativas e a vários modelos sem sentido. [Exemplos disto podem ser vistos neste site](https://www.tylervigen.com/spurious-correlations) (em inglês).\n\nAinda assim, há casos em que podemos utilizar estas regressões para encontrar relações úteis. Em particular, se as séries forem cointegradas podemos usar uma metodologia [Engle-Granger](https://en.wikipedia.org/wiki/Error_correction_model#Engle_and_Granger_2-step_approach). Esta abordagem não será discutida neste post.\n\n# Pacotes\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Bases de dados\nlibrary(\"AER\")\nlibrary(\"astsa\")\nlibrary(\"GetBCBData\")\n# Funções para séries de tempo\nlibrary(\"forecast\")\nlibrary(\"tseries\")\nlibrary(\"dyn\")\n# Funções para facilitar a manipulação de dados com datas\nlibrary(\"xts\")\nlibrary(\"lubridate\")\n# Visualização\nlibrary(\"ggplot2\")\n```\n:::\n\n\n# Exemplo: PIB e Consumo\n\nComo primeiro exemplo vamos analisar a variação do PIB. A base de dados `USMacroG` é um conjunto de 12 séries macroeconômicas dos EUA, disponibilizadas pelo livro de econometria do Greene. Como as séries do PIB e do consumo estão em nível precisamos fazer alguma transformação para convertê-los em taxas percentuais. O importante do código abaixo é notar o uso da função `ts.instersect` que serve para emparelhar as séries e transformá-las em colunas de um `data.frame`. O modelo que queremos estimar relaciona as variações do PIB com as variações do consumo da seguinte forma.\n\n$$\n  \\Delta PIB_{t} = \\beta_{0} + \\beta_{1} \\Delta C_{t} + u_{t}\n$$\n\nonde $\\Delta$ representa a variação percentual, isto é, $\\Delta x_{t} = \\frac{x_{t} - x_{t-1}}{x_{t-1}}$. Para estimar o modelo uso a função `lm`. A saída abaixo é essencialmente idêntica à de uma regressão linear de dados em cross-section\n\n\n::: {.cell}\n\n:::\n\n\n$$\n  \\hat{PIB}_{t} = \\underset{(0.00007)}{0.00264} + \\underset{(0.06316)}{0.68428}C_{t}\n$$\n\n\n\n<table style=\"text-align:center\"><tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\"></td><td><em>Dependent variable:</em></td></tr>\n<tr><td></td><td colspan=\"1\" style=\"border-bottom: 1px solid black\"></td></tr>\n<tr><td style=\"text-align:left\"></td><td>PIB (variação)</td></tr>\n<tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\">Consumo (variação)</td><td>0.684<sup>***</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(0.063)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">constante</td><td>0.003<sup>***</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(0.001)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\">Observations</td><td>203</td></tr>\n<tr><td style=\"text-align:left\">R<sup>2</sup></td><td>0.369</td></tr>\n<tr><td style=\"text-align:left\">Adjusted R<sup>2</sup></td><td>0.366</td></tr>\n<tr><td style=\"text-align:left\">Residual Std. Error</td><td>0.008 (df = 201)</td></tr>\n<tr><td style=\"text-align:left\">F Statistic</td><td>117.364<sup>***</sup> (df = 1; 201)</td></tr>\n<tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\"><em>Note:</em></td><td style=\"text-align:right\"><sup>*</sup>p<0.1; <sup>**</sup>p<0.05; <sup>***</sup>p<0.01</td></tr>\n</table>\n\n::: {.cell}\n\n```{.r .cell-code}\n# Carrega os dados\ndata(\"USMacroG\")\nd <- USMacroG\n# Variação percentual do PIB\npib <- d[, \"gdp\"] / lag(d[, \"gdp\"], -1) - 1\n# Variação percentual do Consumo\ncons <- d[, \"consumption\"] / lag(d[, \"consumption\"], -1) - 1\ndados <- ts.intersect(pib, cons, dframe = TRUE)\n# Regressão do PIB contra o Consumo (contas nacionais)\nsummary(fit <- lm(pib ~ cons, data = dados))\n```\n:::\n\n\nComo há apenas duas séries podemos visualizar a sua relação num gráfico de dispersão ou mesmo num gráfico de linha.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Scatterplot\nplot(pib ~ cons, data = dados)\n# Linha de regressão em vermelho\nabline(coef(fit), col = \"red\")\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Gráfico de linha\nplot.ts(pib)\nlines(cons, col = \"red\")\nlegend(\"topright\", legend = c(\"PIB\", \"Consumo\"), col = 1:2, lty = 1)\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-6-2.png){width=672}\n:::\n:::\n\n\nAinda que práticas, as funções base do R para visualização não são muito elegantes e há vários pacotes que oferecem opções mais interessantes. O popular pacote `ggplot2`, em particular, foi atualmente integrado ao pacote `forecast` nas funções `autoplot` e `autolayer`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dados, aes(x = cons, y = pib)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE)\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n\n```{.r .cell-code}\nautoplot(pib) +\n  autolayer(cons) +\n  theme_light()\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-7-2.png){width=672}\n:::\n:::\n\n\nÉ sempre importante verificar a presença de autocorrelação nos resíduos do modelo - este problema é especialmente presente em contextos de séries de tempo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nu <- resid(fit)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nforecast::ggAcf(u)\nforecast::ggPacf(u)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nNeste caso parece não haver grande problema já que a maior parte das autocorrelações estão dentro do intervalo de confiança (com exceção do segundo lag). Há testes mais formais, como o Breusch-Godfrey ou Ljung-Box, para verificar a presença de autocorrelação nos resíduos de um modelo. Em ambos os casos, queremos testar se os resíduos do modelo se comportam como ruído branco e, idealmente, queremos não-rejeitar a hipótese nula (isto é, busca-se um p-valor \"grande\"). O teste BG está implementado no pacote `lmtest` que é carregado automaticamente junto com o pacote `AER`. Ele essencialmente faz uma regressão linear entre os resíduos do modelo com defasagens da variável explicada ($y$) e dos próprios resíduos e verifica se os coeficientes estimados são significativos (diferentes de zero). O código abaixo mostra como fazer o teste para a segunda ordem.\n\n$$\n  \\hat{u}_{t} = \\alpha_{0} + \\alpha_{1}C_{t} + \\alpha_{2}\\hat{u}_{t-1} + \\alpha_{3}\\hat{u}_{t-2} + \\epsilon_{t}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbgtest(fit, order = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tBreusch-Godfrey test for serial correlation of order up to 2\n\ndata:  fit\nLM test = 4.8858, df = 2, p-value = 0.08691\n```\n:::\n:::\n\n\nA tabela abaixo reporta o valor do teste para diversas ordens. Como se vê, não há evidências de que exista correlação serial nos resíduos do modelo. Caso houvesse autocorrelação, uma saída seria modelar os resíduos como um processo ARMA e estimar o modelo conjuntamente por máxima verossimilhança. Isto é, seria um modelo de [regressão linear com erros ARMA](https://pt.wikipedia.org/wiki/ARMA#Generaliza%C3%A7%C3%B5es). Discuto mais sobre este tipo de modelo e como estimá-lo [neste outro post](/regressao-linear-com-series-de-tempo-armax).\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table-striped\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:center;\"> Ordem da defasagem </th>\n   <th style=\"text-align:center;\"> Estatística LM </th>\n   <th style=\"text-align:center;\"> p-valor </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:center;\"> 1 </td>\n   <td style=\"text-align:center;\"> 0.1074866 </td>\n   <td style=\"text-align:center;\"> 0.7430239 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 2 </td>\n   <td style=\"text-align:center;\"> 4.8857641 </td>\n   <td style=\"text-align:center;\"> 0.0869100 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 3 </td>\n   <td style=\"text-align:center;\"> 4.8859138 </td>\n   <td style=\"text-align:center;\"> 0.1803443 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 4 </td>\n   <td style=\"text-align:center;\"> 7.3978074 </td>\n   <td style=\"text-align:center;\"> 0.1163009 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 5 </td>\n   <td style=\"text-align:center;\"> 8.3037142 </td>\n   <td style=\"text-align:center;\"> 0.1402726 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 6 </td>\n   <td style=\"text-align:center;\"> 8.3038739 </td>\n   <td style=\"text-align:center;\"> 0.2166753 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 7 </td>\n   <td style=\"text-align:center;\"> 8.3473089 </td>\n   <td style=\"text-align:center;\"> 0.3029668 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 8 </td>\n   <td style=\"text-align:center;\"> 8.4821106 </td>\n   <td style=\"text-align:center;\"> 0.3878461 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 9 </td>\n   <td style=\"text-align:center;\"> 8.5054023 </td>\n   <td style=\"text-align:center;\"> 0.4841218 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 10 </td>\n   <td style=\"text-align:center;\"> 8.8502628 </td>\n   <td style=\"text-align:center;\"> 0.5463708 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 11 </td>\n   <td style=\"text-align:center;\"> 8.8803034 </td>\n   <td style=\"text-align:center;\"> 0.6329399 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 12 </td>\n   <td style=\"text-align:center;\"> 11.6353655 </td>\n   <td style=\"text-align:center;\"> 0.4753901 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nTambém seria importante verificar se as séries das variações trimestrais do PIB e do consumo são estacionárias. Caso elas não fossem, os resultados da regressão provavelmente seriam espúrios. Contudo, em geral, quando tiramos a diferença percentual de uma série ela se torna estacionária, então deixo esta questão de lado. Discuto mais sobre não-estacionaridade e regressão espúria [neste outro post](/regressao-espuria).\n\n# Decomposição de tendência e sazonalidade\n\nPode-se propor um modelo linear que separa efeitos de tendência e sazonalidade da seguinte forma:\n\n$$\n  y_{t} = T_{t} + S_{t} + u_{t}\n$$\n\nonde $T_{t}$ é uma componente de tendência (em geral, um polinômio ou média móvel) e $S_{t}$ é um componente sazonal. Talvez a forma mais simples deste modelo seja assumir uma tendência linear e incluir dummies sazonais.\n\n$$\n  y_{t} = \\beta_{0} + \\beta_{1}t + \\sum_{k = 2}^{k = 12}\\alpha_{k}d_{k} + u_{t}\n$$\n\nPara facilitar a notação a equação acima assume dados mensais, onde $d_{k}$ é uma variável dummy igual a $1$ quando a observação for referente ao mês $k$. Isto é, $d_{2} = 1$ quando os dados forem do mês de fevereiro, logo, $\\alpha_{2}$ captura o efeito marginal do mês de fevereiro. Não se pode colocar uma dummy para cada mês pois haveria um problema de singularidade na matriz de regressores, mas é claro que quando o dado for do mês de janeiro, todas as dummies terão valor igual a zero.\n\n### Exemplo: Tendência linear\n\n$$\n  y_{t} = \\beta_{0} + \\beta_{1}t + \\epsilon_{t}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdp <- d[, \"gdp\"]\ntime_trend <- seq_along(gdp)\nfit <- tslm(gdp ~ time_trend)\n```\n:::\n\n\n<table style=\"text-align:center\"><tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\"></td><td><em>Dependent variable:</em></td></tr>\n<tr><td></td><td colspan=\"1\" style=\"border-bottom: 1px solid black\"></td></tr>\n<tr><td style=\"text-align:left\"></td><td>PIB</td></tr>\n<tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\">t</td><td>35.236<sup>***</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(0.449)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">constante</td><td>950.919<sup>***</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(53.065)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\">Observations</td><td>204</td></tr>\n<tr><td style=\"text-align:left\">R<sup>2</sup></td><td>0.968</td></tr>\n<tr><td style=\"text-align:left\">Adjusted R<sup>2</sup></td><td>0.968</td></tr>\n<tr><td style=\"text-align:left\">Residual Std. Error</td><td>377.571 (df = 202)</td></tr>\n<tr><td style=\"text-align:left\">F Statistic</td><td>6,161.458<sup>***</sup> (df = 1; 202)</td></tr>\n<tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\"><em>Note:</em></td><td style=\"text-align:right\"><sup>*</sup>p<0.1; <sup>**</sup>p<0.05; <sup>***</sup>p<0.01</td></tr>\n</table>\n\n\nO gráfico abaixo mostra o ajuste com a linha de tendência em vermelho. Fica claro que os dados nas extremidades da série fogem bastante da tendência. Isto pode tanto ser indício de um mau ajuste, como de que o crescimento recente foi \"acima da tendência\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nautoplot(gdp) +\n  autolayer(fitted(fit)) +\n  scale_color_discrete(name = \"\", label = \"Tendência Linear\") +\n  labs(title = \"PIB (tendência linear)\", x = \"\", y = \"\") +\n  theme_light() +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nParte do motivo de se estimar uma tendência para a série é para poder removê-la da série original. Isto é, queremos fazer \n\n$$\n  y_{t}^{\\text{detrend}} = y_{t} - \\hat{y_{t}} = y_{t} - \\hat{\\beta_{0}} + \\hat{\\beta_{1}}t\n$$\n\nonde $y_{t}^{\\text{detrend}}$ é a série sem tendência. Isto é particularmente útil quando estamos lidando com séries \"tendência-estacionárias\", i.e., séries que se tornam estacionárias quando subtraímos a sua tendência. No caso da série do PIB há algum debate sobre como torná-la estacionária. Em geral, é mais comum tratá-la como \"diferença-estacionária\" e tirar a primeira diferença da série (implicitamente assumindo que ela possui uma raiz unitária). Contudo, há alguma evidência de que a série possa ser \"tendência-estacionária\" quando se considera uma tendência com quebra.\n\nDe qualquer forma, para este modelo simples podemos facilmente computar a série sem tendência. Visualmente, a série não parece estacionária, mas seria necessário fazer algum teste formal para concluir isto com mais certeza.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndetrend <- gdp - fitted(fit)\n\nautoplot(detrend) +\n  theme_light()\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n### Exemplo: Tendências polinomiais (ordens mais altas)\n\nUma forma de estender o modelo acima é considerar ordens polinomiais mais elevadas. De forma geral, o modelo teria a seguinte forma:\n\n$$\n  y_{t} = \\sum_{i = 0}^{k}\\beta_{k}t^{k} + \\epsilon_{t}\n$$\n\nonde $k$ é a ordem que estamos considerando. Para uma tendência cúbica, por exemplo, teríamos:\n\n$$\n  y_{t} = \\beta_{0} + \\beta_{1}t + \\beta_{2}t^{2} + \\beta_{3}t^{3}+ \\epsilon_{t}\n$$\n\nO código abaixo estima justamente este modelo e os resultados são reportados na tabela.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrend <- seq_along(time_trend)\nfit_poly <- tslm(gdp ~ poly(trend, 3, raw = TRUE))\n```\n:::\n\n\n<table style=\"text-align:center\"><tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\"></td><td><em>Dependent variable:</em></td></tr>\n<tr><td></td><td colspan=\"1\" style=\"border-bottom: 1px solid black\"></td></tr>\n<tr><td style=\"text-align:left\"></td><td>PIB</td></tr>\n<tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\">t</td><td>22.411<sup>***</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(1.566)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">t2</td><td>-0.011</td></tr>\n<tr><td style=\"text-align:left\"></td><td>(0.018)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">t3</td><td>0.0004<sup>***</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(0.0001)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">constante</td><td>1,563.528<sup>***</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(37.166)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\">Observations</td><td>204</td></tr>\n<tr><td style=\"text-align:left\">R<sup>2</sup></td><td>0.996</td></tr>\n<tr><td style=\"text-align:left\">Adjusted R<sup>2</sup></td><td>0.996</td></tr>\n<tr><td style=\"text-align:left\">Residual Std. Error</td><td>130.279 (df = 200)</td></tr>\n<tr><td style=\"text-align:left\">F Statistic</td><td>17,749.800<sup>***</sup> (df = 3; 200)</td></tr>\n<tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\"><em>Note:</em></td><td style=\"text-align:right\"><sup>*</sup>p<0.1; <sup>**</sup>p<0.05; <sup>***</sup>p<0.01</td></tr>\n</table>\n\n::: {.cell}\n\n```{.r .cell-code}\nautoplot(gdp) +\n  autolayer(fitted(fit_poly)) +\n  scale_color_discrete(name = \"\", label = \"Tendência Cúbica\") +\n  theme_light() +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\nComo se vê no gráfico, a tendência cúbica oferece uma aproximação melhor da série original, contudo, há motivos para ter cuidado com este tipo de modelo. À medida que se aumenta a ordem do polinômio, o ajuste da tendência vai progressivamente melhorando. Isto é problemático por pelo menos três motivos: (1) enquanto talvez exista algum argumento que justifique uma tendência cúbica nos dados do PIB, é difícil imaginar algum para explicar por que o PIB exibe uma tendência polinomial de ordem 10, 17, 21, etc; (2) ordens altas geralmente implicam num [*sobreajuste*](https://pt.wikipedia.org/wiki/Sobreajuste) dos dados, isto é, o modelo vai se tornar muito bom em explicar o conjunto atual de dados, mas será péssimo para fazer previsões; (3) cada parâmetro do modelo é estimado com algum erro, então quanto mais parâmetros forem incluídos no modelo, maior será este erro.\n\nO gráfico abaixo mostra o ajuste com polinômios de ordens diferentes. Note como as tendências com ordens de polinômios mais elevados apresentam um ajuste melhor aos dados. Isto é especialmente verdadeiro no começo e no final da série.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-20-2.png){width=672}\n:::\n:::\n\n\n### Exemplo: tendência e sazonalidade (aditiva) na produção industrial\n\nO código abaixo estima um modelo como da equação acima para o índice de produção industrial mensal do FED. Os resultados estão apresentados na tabela. A regressão encontra efeitos significativos e positivos para os meses de junho, setembro e outubro.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(prodn)\nfit <- tslm(prodn ~ trend + season)\n```\n:::\n\n\n<table style=\"text-align:center\"><tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\"></td><td><em>Dependent variable:</em></td></tr>\n<tr><td></td><td colspan=\"1\" style=\"border-bottom: 1px solid black\"></td></tr>\n<tr><td style=\"text-align:left\"></td><td>Production</td></tr>\n<tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\">Trend</td><td>0.291<sup>***</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(0.003)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">Feb</td><td>1.806</td></tr>\n<tr><td style=\"text-align:left\"></td><td>(1.610)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">Mar</td><td>2.128</td></tr>\n<tr><td style=\"text-align:left\"></td><td>(1.610)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">Apr</td><td>1.950</td></tr>\n<tr><td style=\"text-align:left\"></td><td>(1.610)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">May</td><td>1.936</td></tr>\n<tr><td style=\"text-align:left\"></td><td>(1.610)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">Jun</td><td>3.649<sup>**</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(1.610)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">Jul</td><td>-1.429</td></tr>\n<tr><td style=\"text-align:left\"></td><td>(1.610)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">Aug</td><td>1.776</td></tr>\n<tr><td style=\"text-align:left\"></td><td>(1.611)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">Sep</td><td>4.105<sup>**</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(1.611)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">Oct</td><td>4.208<sup>***</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(1.611)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">Nov</td><td>2.294</td></tr>\n<tr><td style=\"text-align:left\"></td><td>(1.611)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">Dec</td><td>-0.320</td></tr>\n<tr><td style=\"text-align:left\"></td><td>(1.611)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">Intercept</td><td>28.727<sup>***</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(1.266)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\">Observations</td><td>372</td></tr>\n<tr><td style=\"text-align:left\">R<sup>2</sup></td><td>0.962</td></tr>\n<tr><td style=\"text-align:left\">Adjusted R<sup>2</sup></td><td>0.961</td></tr>\n<tr><td style=\"text-align:left\">Residual Std. Error</td><td>6.340 (df = 359)</td></tr>\n<tr><td style=\"text-align:left\">F Statistic</td><td>755.242<sup>***</sup> (df = 12; 359)</td></tr>\n<tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\"><em>Note:</em></td><td style=\"text-align:right\"><sup>*</sup>p<0.1; <sup>**</sup>p<0.05; <sup>***</sup>p<0.01</td></tr>\n</table>\n\n\nAo visualizar o ajuste dos dados vê-se também a limitação desta abordagem. Implicitamente se assume que o efeito sazonal é sempre o mesmo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nautoplot(prodn) +\n  autolayer(fitted(fit)) +\n  theme_light() +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n### Exemplo: tendência e sazonalidade (multiplicativa)\n\nCom os mesmos dados do exemplo anterior queremos estimar um modelo da forma\n\n$$\n   y_{t} = T_{t}\\cdot S_{t}\\cdot u_{t}\n$$\n\nO código abaixo estima este modelo usando a função `decompose` do pacote base do R e apresenta os resultados visualmente. O primeiro quadrante do gráfico mostra a série original. Os quadrantes seguintes mostram a parte sazonal, a tendência (polinomial) e o resíduo, i.e., a série dessazonalidada.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit <- decompose(prodn, type = \"multiplicative\") \nautoplot(fit) +\n  theme_light()\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nAcf(na.omit(fit)$random)\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nautoplot(stl(prodn, s.window = \"periodic\")) +\n  theme_light()\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n\n# Regressão com variáveis defasadas\n\nUma especificação bastante comum é descrever o comportamento de uma variável em função de seus valores passados. Isto pode refletir, por exemplo, algum componente inercial nos dados em que o valor da inflação do mês de outubro está correlacionada ao valor da inflação no mês de setembro. Também é possível estender este modelo incluindo os valores contemporâneos e defasados de outras variáveis. Pode-se especular, por exemplo, que o desempenho das vendas de um setor seja função da renda no mesmo período (mês, trimestre, etc.) e em períodos anteriores. Ou seja, queremos \"explicar\" a série $y$ em função de seus valores passados ($y_{t-1}, y_{t-2}, \\dots$) e dos valores contemporâneos e passados de outras séries ($x_{t-1}, z_{t-1}, \\dots$).\n\n## Exemplo simples\n\nUm modelo para explicar $y$ em função de seu valor defasado em um período, do valor contemporâneo de $x$ e do valor defasado de $x$ em um período.\n\n$$\n  y_{t} = \\beta_{0} + \\beta_{1}y_{t - 1} + \\beta_{2}x_{t} + \\beta_{3}x_{t - 1} + w_{t}\n$$\n\nNote que o modelo acima não seria muito útil para gerar previsões de $y_{t + 1}$ pois ele exigiria conhecimento de $x_{t + 1}$. Então, seria necessário primeiro prever o valor de $x_{t + 1}$ para computar uma estimativa para $y_{t + 1}$. \n\n$$\n\\mathbb{E}(y_{t + 1} | \\mathbb{I}_{t}) = \\beta_{0} + \\beta_{1}y_{t} + \\beta_{2}x_{t + 1} + \\beta_{3}x_{t}\n$$\n\n## Exemplo: Índice de Produção Industrial\n\nPara o exemplo abaixo uso o pacote `GetBCBData` para carregar a série do Índice de Produção Industrial (IPI).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Baixa os dados\nipi <- gbcbd_get_series(21859, first.date = as.Date(\"2002-01-01\"))\n# Converte a série para ts\nprod <- ts(ipi$value, start = c(2002, 01), frequency = 12)\n# Gráfico da série\nautoplot(prod) +\n  labs(title = \"Índice de Produção Industiral - geral (2012 = 100)\") +\n  theme_light()\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\nPode-se visualizar a relação linear entre valores correntes e defasados do IPI usando a função `lag.plot`. Na imagem abaixo, cada quadrado mostra um gráfico de dispersão dos valores do IPI em $t$ contra os valores do IPI em $t-k$. Alguns lags parecem não exibir muita relação como o lag 6. Já o primeiro e último lag parecem apresentar uma relação linear mais acentuada.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngglagplot(prod, 12, do.lines = FALSE, colour = FALSE) +\n  theme_light()\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\nComo exemplo, podemos propor o modelo abaixo para o IPI. A escolha dos lags aqui foi um tanto arbitrária e há métodos mais apropriados para escolhê-los.\n\n$$\n  IPI_{t} = \\beta_{0} + \\beta_{1}IPI_{t - 1} + \\beta_{2}IPI_{t - 2} + \\beta_{3}IPI_{t - 4} + \\beta_{2}IPI_{t - 12}\n$$\n\nPara estimar este modelo no R há um pequeno inconveniente da função `lag` que, na verdade, funciona como um operador *foreward*. Além disso, agora a função base `lm` (e por conseguinte, também a função `tslm`) se prova um tanto inconveniente, pois ela não funciona bem com variáveis defasadas. Para usar a função `lm` seria necessário primeiro \"emparelhar\" as diferentes defasagens da série, isto é, seria necessário criar um `data.frame` (ou `ts`) em que cada coluna mostra os valores das defasagens escolhidas. Por motivo de completude, deixo um código de exemplo que faz isto. Na prática, vale mais a pena escolher alguma outra função como `dynlm::dynlm` ou `dyn::dyn$lm`. O código abaixo usa o `forecast::tslm`, mas nos exemplos seguintes uso o `dyn::dyn$lm`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exemplo usando forecast::tslm (tb funcionaria com stats::lm)\ndf <- ts.intersect(\n  prod, lag(prod, -1), lag(prod, -2), lag(prod, -4), lag(prod, -12),\n  dframe = TRUE\n  )\n\nfit <- tslm(prod ~ ., data = df)\n```\n:::\n\n\nPode-se contornar o problema da função `lag` definindo uma nova função, `L`, que funciona da maneira desejada. O código abaixo estima a regressão usando `dyn::dyn$lm`. A sintaxe dentro da função é praticamente idêntica à que vimos acima com as funções `lm` e `tslm`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define uma função L\nL <- function(x, k) {lag(x, -k)}\nfit <- dyn$lm(prod ~ L(prod, 1) + L(prod, 2) + L(prod, 4) + L(prod, 12))\n```\n:::\n\n\nOs resultados da regressão acima estão resumidos na tabela abaixo.\n\n\n\n<table style=\"text-align:center\"><tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\"></td><td><em>Dependent variable:</em></td></tr>\n<tr><td></td><td colspan=\"1\" style=\"border-bottom: 1px solid black\"></td></tr>\n<tr><td style=\"text-align:left\"></td><td>ipi</td></tr>\n<tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\">ipi [1]</td><td>0.453<sup>***</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(0.057)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">ipi [4]</td><td>0.128<sup>**</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(0.062)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">ipi [8]</td><td>-0.110<sup>***</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(0.042)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">ipi [12]</td><td>0.443<sup>***</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(0.040)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">constante</td><td>9.479<sup>**</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(3.990)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\">Observations</td><td>243</td></tr>\n<tr><td style=\"text-align:left\">R<sup>2</sup></td><td>0.783</td></tr>\n<tr><td style=\"text-align:left\">Adjusted R<sup>2</sup></td><td>0.779</td></tr>\n<tr><td style=\"text-align:left\">Residual Std. Error</td><td>5.305 (df = 238)</td></tr>\n<tr><td style=\"text-align:left\">F Statistic</td><td>214.814<sup>***</sup> (df = 4; 238)</td></tr>\n<tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\"><em>Note:</em></td><td style=\"text-align:right\"><sup>*</sup>p<0.1; <sup>**</sup>p<0.05; <sup>***</sup>p<0.01</td></tr>\n</table>\n\n\nPodemos combinar a informação de outros indicadores industriais para adicionar informação potencialmente relevante para nossa regressão. Neste exemplo, uso outros indicadores industriais para encontrar aqueles que \"ajudam a explicar\" o indicador geral.\n\nO código abaixo importa uma série de indicadores industriais e junta todos eles num único objeto `ts`.\n\nOs códigos utilizados são diretamente copiados do [sistema de séries temporais do BCB](https://www3.bcb.gov.br/sgspub/localizarseries/localizarSeries.do?method=prepararTelaLocalizarSeries).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Codigos das series do BACEN\ncodigos_series = c(21859, 21861:21868)\n# Vetor com nomes para facilitar o uso dos dados\nnomes = c(\n  \"geral\", \"extrativa_mineral\", \"transformacao\", \"capital\", \"intermediarios\",\n  \"consumo\", \"consumo_duraveis\", \"semiduraveis_e_nao_duraveis\",\n  \"insumos_da_construcao_civil\"\n  )\n# Junta estes dados num data.frame que serve de dicionário (metadata)\ndicionario <- data.frame(id.num = codigos_series, nome_serie = nomes)\n\n# Baixa todas as series\nseries <- gbcbd_get_series(codigos_series, first.date = as.Date(\"2002-01-01\"))\n# Junta as séries com o dicionário\nseries <- merge(series, dicionario, by = \"id.num\")\n# Converte para wide usando os nomes do dicionario como nome das colunas\nseries_wide <- reshape2::dcast(series, ref.date ~ nome_serie, value.var = \"value\")\n# Convert para ts\nseries <- ts(as.matrix(series_wide[, -1]), start = c(2002, 1), frequency = 12)\n\n# Visualizar todas as series\nautoplot(series) +\n  facet_wrap(vars(series)) +\n  scale_color_viridis_d() +\n  theme_light() +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\nFeito o trabalho de importação dos dados podemos propor um modelo simples que toma o valor defasado das variáveis. Novamente a escolha das defasagens e dos regressores foi completamente arbitrária. O modelo estimado usa defasagens de outras séries para modelar o comportamento da série do índice de produção da indústria de tranformação\n\n$$\n  Transf_{t} = \\beta_{0} + \\beta_{1}Durav_{t - 1} + \\beta_{2}Durav_{t - 12} + \\beta_{3}Capital_{t - 1} + \\beta_{4}Capital_{t - 6} + \\beta_{5}Transf_{t - 1} + \\alpha_{1}t + \\sum_{k = 2}^{12}\\alpha_{k}d_{k}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit <- dyn$lm(\n  transformacao ~ L(consumo_duraveis, 1) + L(consumo_duraveis, 12) +\n                  L(capital, 1) + L(capital, 6) +\n                  L(intermediarios, 12) +\n                  L(transformacao, 1) +\n                  time(transformacao) + as.factor(cycle(transformacao)),\n  data = series\n  )\n\nautoplot(series[, 1]) +\n  autolayer(fitted(fit)) +\n  theme_light()\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\nOlhando apenas para as observações mais recentes vemos que, com exceção do período da pandemia, o ajuste aos dados é relativamente satisfatório.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filtra apenas as observações mais recentes, após jan/2015\nprod_recente <- window(prod, start = c(2015, 1))\n# Reestima o modelo\nsummary(fit <- tslm(prod_recente ~ trend + season))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\ntslm(formula = prod_recente ~ trend + season)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-22.7099  -1.7468   0.5251   2.3851   8.6932 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 95.79792    1.75401  54.616  < 2e-16 ***\ntrend       -0.04667    0.01648  -2.832 0.005760 ** \nseason2     -2.56444    2.20212  -1.165 0.247428    \nseason3      5.54889    2.20231   2.520 0.013598 *  \nseason4      0.09888    2.27037   0.044 0.965362    \nseason5      7.25805    2.27007   3.197 0.001942 ** \nseason6      8.26722    2.26989   3.642 0.000461 ***\nseason7     14.48889    2.26983   6.383 8.46e-09 ***\nseason8     17.81056    2.26989   7.846 1.08e-11 ***\nseason9     14.05723    2.27007   6.192 1.96e-08 ***\nseason10    16.36640    2.27037   7.209 2.05e-10 ***\nseason11     9.46307    2.27079   4.167 7.31e-05 ***\nseason12    -1.24026    2.27133  -0.546 0.586444    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.671 on 86 degrees of freedom\nMultiple R-squared:  0.7233,\tAdjusted R-squared:  0.6847 \nF-statistic: 18.73 on 12 and 86 DF,  p-value: < 2.2e-16\n```\n:::\n\n```{.r .cell-code}\nautoplot(prod_recente) +\n  autolayer(fitted(fit)) +\n  theme_light() +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n# Dummies\n\nNa análise de sazonalidade já lidamos com dummies, mas vale a pena discutí-las num contexto mais amplo. Pode-se usar variáveis dummy para estimar o efeito de certos eventos extraordinários (greves, atentados, crise externa, etc.) ou mesmo o efeito de eventos recorrentes e previsíveis (feriados, dias úteis, alguma estação do ano, etc.).\n\n### Exemplo: Efeito de greves e preços administrados no IPCA\n\n$$\n  \\text{IPCA}_{t} = \\beta_{0} + \\beta_{1}\\text{gcam}_{t} + \\beta_{2}\\text{g2013}_{t} + \\beta_{3}\\text{padm}_{t} + \\text{dsaz} + \\varepsilon_{t}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nipca <- gbcbd_get_series(433, first.date = as.Date(\"1995-01-01\"))\nipca$ref.date <- as.Date(ipca$ref.date, format = \"%d/%m/%Y\")\nindex <- as.POSIXct(ipca$ref.date)\nipca <-  xts(x = ipca$value, order.by = index)\nipca <- ipca[\"2003-05/2019-06-01\"]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# dummy greve caminhoneiro\ngreve_caminhao <- xts(rep(0, length(ipca)), order.by = index(ipca))\ngreve_caminhao[\"2018-05\"] <- 1\n\n# greves 2013\ngreve_2013 <- xts(rep(0, length(ipca)), order.by = index(ipca))\ngreve_2013[\"2018-07\"] <- 1\n\n# precos_adm\nprecos_adm <- xts(rep(0, length(ipca)), order.by = index(ipca))\nprecos_adm[\"2015-01/2015-04\"] <- 1\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx = cbind(ipca, greve_caminhao, greve_2013, precos_adm)\nx = ts(coredata(x), start = c(year(index(x))[1], month(index(x))[1]), frequency = 12)\n\nipca = x[, 1]\ngreve_caminhao = x[, 2]\ngreve_2013 = x[, 3]\nprecos_adm = x[, 4]\n\ntslm(ipca ~ greve_caminhao + greve_2013 + precos_adm + season)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\ntslm(formula = ipca ~ greve_caminhao + greve_2013 + precos_adm + \n    season)\n\nCoefficients:\n   (Intercept)  greve_caminhao      greve_2013      precos_adm         season2  \n      0.568698        1.040000       -0.377333        0.510833       -0.081250  \n       season3         season4         season5         season6         season7  \n     -0.089375       -0.157500       -0.348698       -0.261823       -0.281365  \n       season8         season9        season10        season11        season12  \n     -0.188698       -0.096823       -0.112448       -0.001198        0.083802  \n```\n:::\n\n```{.r .cell-code}\nfit <- dyn$lm(ipca ~ L(ipca, 1) + greve_caminhao + greve_2013 + precos_adm +\n                     as.factor(cycle(ipca)))\n```\n:::\n\n\nNa tabela abaixo omito os interceptos das dummies sazonais\n\n\n\n<table style=\"text-align:center\"><tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\"></td><td><em>Dependent variable:</em></td></tr>\n<tr><td></td><td colspan=\"1\" style=\"border-bottom: 1px solid black\"></td></tr>\n<tr><td style=\"text-align:left\"></td><td>IPCA</td></tr>\n<tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\">ipca [1]</td><td>0.508<sup>***</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(0.061)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">Greve (2018)</td><td>1.039<sup>***</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(0.206)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">Greve (2013)</td><td>-0.390<sup>*</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(0.206)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">Preços adm</td><td>0.212<sup>*</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(0.109)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">constante</td><td>0.108</td></tr>\n<tr><td style=\"text-align:left\"></td><td>(0.071)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td style=\"text-align:left\">Constant</td><td>0.256<sup>***</sup></td></tr>\n<tr><td style=\"text-align:left\"></td><td>(0.063)</td></tr>\n<tr><td style=\"text-align:left\"></td><td></td></tr>\n<tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\">Observations</td><td>192</td></tr>\n<tr><td style=\"text-align:left\">R<sup>2</sup></td><td>0.517</td></tr>\n<tr><td style=\"text-align:left\">Adjusted R<sup>2</sup></td><td>0.476</td></tr>\n<tr><td style=\"text-align:left\">Residual Std. Error</td><td>0.199 (df = 176)</td></tr>\n<tr><td style=\"text-align:left\">F Statistic</td><td>12.567<sup>***</sup> (df = 15; 176)</td></tr>\n<tr><td colspan=\"2\" style=\"border-bottom: 1px solid black\"></td></tr><tr><td style=\"text-align:left\"><em>Note:</em></td><td style=\"text-align:right\"><sup>*</sup>p<0.1; <sup>**</sup>p<0.05; <sup>***</sup>p<0.01</td></tr>\n</table>\n\n::: {.cell}\n\n:::\n\n\n# Previsão (alguns problemas)\n\nModelos de regressão linear podem também ser usados para fazer previsões. A princípio os valores futuros de uma série podem ser computados usando os valores estimados dos $\\beta_{i}$. Num modelo linear de $y_{t}$ em função de $k$ séries de tempo, como o abaixo, podemos calcular o valor de $\\hat{y_{t}}$\n\n$$\n  \\hat{y_{t}} = \\hat{\\beta_{0}} + \\hat{\\beta_{1}}x_{1, t} + \\hat{\\beta_{2}}x_{2, t} + \\dots + \\hat{\\beta_{k}}x_{k, t}\n$$\n\ncontudo, o valor de $y_{t + 1}$ exige o conhecimento do valor de todas as $k$ séries em $t+1$. O mesmo vale quando usamos variáveis defasadas como regressores. Há diversas formas de resolver este problema. Uma solução simples seria tomar o valor médio dos regressores para formar as previsões. Outra solução seria propor modelos ARMA simples para cada uma das séries $x_{k, t}$ e usar estas previsões dentro do modelo linear para $y_{t}$. Alternativamente, pode-se também montar cenários futuros hipotéticos definindo valores pré-estabelecidos para as variáveis regressoras.\n\nHá também alguns casos mais simples, em que o valor futuro das variáveis regressoras é conhecido. Por exemplo, pode-se modelar a demanda por energia elétrica numa região como função de uma dummy de estação (verão x não-verão) e de dia útil (dia útil x dia não-útil). É bastante simples fazer previsões futuras neste caso pois sabe-se de antemão todos os valores futuros das séries que se está usando para \"explicar\" a demanda por energia elétrica. Já se o mesmo modelo considerasse também o PIB desta região como variável na regressão, seria mais complexo prever os valores futuros da demanda por energia, pois seria necessário saber também os valores futuros do PIB.\n\n## Exemplo: tendência e sazonalidade\n\nÉ relativamente simples prever os valores futuros de modelos de tendência e sazonalidade determinísticas. Como o adjetivo \"determinístico\" sugere sabe-se de antemão todos os valores que esta série vai exibir. O exemplo abaixo estima um modelo simples para a demanda por passagens aéreas (voos internacionais).\n\nVale notar que não se costuma fazer previsões de longo prazo com este tipo de modelo, pois a hipótese de que a sazonalidade/tendência continua exatamente igual ao longo do tempo vai se tornando cada vez mais frágil. A curto prazo, contudo, pode ser razoável supor que este modelo linear simples ofereça uma boa aproximação da realidade.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit <- tslm(AirPassengers ~ trend + season)\n\nautoplot(forecast(fit, h = 24), include = 24) +\n  theme_light()\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-41-1.png){width=672}\n:::\n:::\n\n\n## Exemplo: previsão de cenário\n\nNo caso da regressão acima do IPCA, pode-se estimar o impacto de uma nova greve dos caminhoneiros. [Mal sabiamos que em 2020 teriamos um evento extraordinário...].\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndummies = cbind(greve_caminhao, greve_2013, precos_adm)\nfit <- Arima(ipca, order = c(1, 0, 0), xreg = coredata(dummies))\ngreve_caminhao_2020 = c(rep(0, 9), 1, 0, 0)\nnovo_xreg = cbind(greve_caminhao = greve_caminhao_2020, greve_2013 = rep(0, 12), precos_adm = rep(0, 12))\n\nautoplot(forecast(fit, xreg = novo_xreg), include = 20) +\n  theme_light()\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-42-1.png){width=672}\n:::\n:::\n\n\n## Exemplo: variáveis defasadas\n\nPode ser um tanto difícil fazer previsões com modelos que usam informação de outras séries. Num modelo simples como $y_{t} = \\beta_{0} + \\beta_{1}x_{t - 1}$ para prever valores futuros de $y_{t}$ é preciso fazer previsõs para a série $x_{t}$, pois, $y_{t + 2}$ é função linear de $x_{t + 1}$. Há muitas maneiras de abordar este problema e eu provavelmente vou discutir mais sobre as alternativas num post futuro. O exemplo abaixo mostra como usar informação disponível de outras séries\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_ajustada <-\n  ts.intersect(transf = series[, \"transformacao\"],\n               lag(series[, \"consumo_duraveis\"], -1),\n               lag(series[, \"consumo_duraveis\"], -12),\n               lag(series[, \"capital\"], -1),\n               lag(series[, \"capital\"], -6),\n               lag(series[, \"intermediarios\"], -12),\n               lag(series[, \"transformacao\"], -1),\n               dframe = TRUE\n               )\nfit <- tslm(transf ~ ., data = df_ajustada)\nsub <- df_ajustada[(length(df_ajustada[, \"transf\"]) - 12):length(df_ajustada[, \"transf\"]), ]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nautoplot(forecast(fit, sub), include = 36) +\n  theme_light()\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n:::\n\n\nPode-se, como de costume, separar os dados em *train* e *test* para avaliar a qualidade das previsões dentro da amostra.\n\n# Conclusões\n\nModelos linares podem ser bastante úteis na análise de séries de tempo. Neste post, discuti brevemente a aplicação destes modelos num contexto de decomposição clássica, análise de regressão e de previsão. Há muitos aspectos interessantes que ainda podem ser explorados.\n\n[Como comentei no início do post, este texto foi originalmente escrito no início de 2019. De lá pra cá muitas coisas mudaram, mas acredito que a informação aqui continua sendo bastante útil. Talvez no futuro eu reescreva este post utilizando somente o pacote `forecast` e mostrando algumas maneiras mais simples de montar o código, evitando a multiplicidade de objetos `ts`, `xts`, etc.]",
    "supporting": [
      "post_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"../../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}